{"version":3,"file":"observe-slot-text-0a9e1768.js","sources":["../../../../packages/shared/lib/observe-slot-text.js"],"sourcesContent":["const observedSlotElement = Symbol('observedSlotElement');\nconst slotElementObserver = Symbol('slotElementObserver');\nconst startObserving = Symbol('startObserving');\nexport function ObserveSlotText(constructor, slotSelector = '#slot') {\n    return class SlotTextObservingElement extends constructor {\n        constructor() {\n            super(...arguments);\n            this.slotHasContent = false;\n        }\n        manageObservedSlot() {\n            this[observedSlotElement] = (this[observedSlotElement] ||\n                (this.shadowRoot\n                    ? this.shadowRoot.querySelector(slotSelector)\n                    : undefined));\n            if (!this[observedSlotElement]) {\n                return;\n            }\n            const slot = this[observedSlotElement];\n            let assignedNodes = slot.assignedNodes\n                ? slot.assignedNodes()\n                : [...this.childNodes].filter((node) => {\n                    const el = node;\n                    return !el.hasAttribute('slot');\n                });\n            assignedNodes = assignedNodes.filter((node) => {\n                if (node.tagName) {\n                    return true;\n                }\n                return node.textContent ? node.textContent.trim() : false;\n            });\n            this.slotHasContent = assignedNodes.length > 0;\n            this.requestUpdate();\n        }\n        firstUpdated(changedProperties) {\n            super.firstUpdated(changedProperties);\n            this.manageObservedSlot();\n        }\n        [startObserving]() {\n            const config = { characterData: true, subtree: true };\n            if (!this[slotElementObserver]) {\n                const callback = (mutationsList) => {\n                    for (const mutation of mutationsList) {\n                        /* istanbul ignore else */\n                        if (mutation.type === 'characterData') {\n                            this.manageObservedSlot();\n                        }\n                    }\n                };\n                this[slotElementObserver] = new MutationObserver(callback);\n            }\n            this[slotElementObserver].observe(this, config);\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this[startObserving]();\n        }\n        disconnectedCallback() {\n            /* istanbul ignore else */\n            if (this[slotElementObserver]) {\n                this[slotElementObserver].disconnect();\n            }\n            super.disconnectedCallback();\n        }\n    };\n}\n//# sourceMappingURL=observe-slot-text.js.map"],"names":["constructor","slotSelector","slotHasContent","observedSlotElement","this","shadowRoot","querySelector","undefined","slot","assignedNodes","_toConsumableArray","childNodes","filter","node","hasAttribute","tagName","textContent","trim","length","requestUpdate","changedProperties","manageObservedSlot","startObserving","slotElementObserver","MutationObserver","mutationsList","type","_this2","observe","characterData","subtree","disconnect","Symbol"],"mappings":"kMA4BM,SACFA,OACAC,yDAAe,sGAQJC,gBAAiB,0EAGfC,GAAwBC,KAAKD,KAC7BC,KAAKC,WACAD,KAAKC,WAAWC,cAAcL,QAC9BM,GACLH,KAAKD,QAGJK,EAAOJ,KAAKD,GACdM,EAAgBD,EAAKC,cACnBD,EAAKC,gBACLC,EAAIN,KAAKO,YAAYC,QAAO,SAACC,UACdA,EACAC,aAAa,WAElCL,EAAgBA,EAAcG,QAAO,SAACC,WAC7BA,EAAqBE,WAGnBF,EAAKG,aAAcH,EAAKG,YAAYC,eAE1Cf,eAAiBO,EAAcS,OAAS,OACxCC,sDAGcC,mDACAA,QACdC,4BAGAC,kCAEAlB,KAAKmB,GAAsB,MAWvBA,GAAuB,IAAIC,kBAVf,SACbC,0CAEuBA,iDAAe,CAEZ,0BAATC,MACTC,EAAKN,iHAMhBE,GAAqBK,QAAQxB,KAdnB,CAAEyB,eAAe,EAAMC,SAAS,2GAmB1CR,oDAKDlB,KAAKmB,SACAA,GAAqBQ,6EAhEQ/B,OAnBlD,IAAMG,EAAsB6B,OAAO,uBAC7BT,EAAsBS,OAAO,uBAC7BV,EAAiBU,OAAO"}