(window["webpackJsonp"] = window["webpackJsonp"] || []).push([[0],{

/***/ 45:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shady-data.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class ShadyData {
  /** @override */
  toJSON() {
    return {};
  }

}
function ensureShadyDataForNode(node) {
  if (!node.__shady) {
    node.__shady = new ShadyData();
  }

  return node.__shady;
}
function shadyDataForNode(node) {
  return node && node.__shady;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/utils.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {!Object} */

const settings = window['ShadyDOM'] || {};
settings.hasNativeShadowDOM = Boolean(Element.prototype.attachShadow && Node.prototype.getRootNode);
const desc = Object.getOwnPropertyDescriptor(Node.prototype, 'firstChild');
settings.hasDescriptors = Boolean(desc && desc.configurable && desc.get);
settings.inUse = settings['force'] || !settings.hasNativeShadowDOM;
settings.noPatch = settings['noPatch'] || false;
settings.preferPerformance = settings['preferPerformance'];
const IS_IE = navigator.userAgent.match('Trident');
settings.IS_IE = IS_IE;
const canUpgrade = () => !settings.IS_IE;
const isTrackingLogicalChildNodes = node => {
  const nodeData = shadyDataForNode(node);
  return nodeData && nodeData.firstChild !== undefined;
};
const utils_isShadyRoot = obj => {
  return Boolean(obj._localName === 'ShadyRoot');
};
const hasShadowRootWithSlot = node => {
  const nodeData = shadyDataForNode(node);
  let root = nodeData && nodeData.root;
  return root && root._hasInsertionPoint();
};
let utils_p = Element.prototype;
let matches = utils_p.matches || utils_p.matchesSelector || utils_p.mozMatchesSelector || utils_p.msMatchesSelector || utils_p.oMatchesSelector || utils_p.webkitMatchesSelector;
const matchesSelector = (element, selector) => {
  return matches.call(element, selector);
};
const mixin = (target, source) => {
  for (var i in source) {
    target[i] = source[i];
  }

  return target;
}; // NOTE, prefer MutationObserver over Promise for microtask timing
// for consistency x-platform.

let twiddle = document.createTextNode('');
let utils_content = 0;
let queue = [];
new MutationObserver(() => {
  while (queue.length) {
    // catch errors in user code...
    try {
      queue.shift()();
    } catch (e) {
      // enqueue another record and throw
      twiddle.textContent = utils_content++;
      throw e;
    }
  }
}).observe(twiddle, {
  characterData: true
}); // use MutationObserver to get microtask async timing.

const microtask = callback => {
  queue.push(callback);
  twiddle.textContent = utils_content++;
};
const hasDocumentContains = Boolean(document.contains);
const contains = (container, node) => {
  while (node) {
    if (node == container) {
      return true;
    }

    node = node[SHADY_PREFIX + 'parentNode'];
  }

  return false;
};

const getNodeHTMLCollectionName = node => node.getAttribute('id') || node.getAttribute('name');

const isValidHTMLCollectionName = name => name !== 'length' && isNaN(name);

const createPolyfilledHTMLCollection = nodes => {
  // Note: loop in reverse so that the first named item matches the named property
  for (let l = nodes.length - 1; l >= 0; l--) {
    const node = nodes[l];
    const name = getNodeHTMLCollectionName(node);

    if (name && isValidHTMLCollectionName(name)) {
      nodes[name] = node;
    }
  }

  nodes.item = function (index) {
    return nodes[index];
  };

  nodes.namedItem = function (name) {
    if (isValidHTMLCollectionName(name) && nodes[name]) {
      return nodes[name];
    }

    for (const node of nodes) {
      const nodeName = getNodeHTMLCollectionName(node);

      if (nodeName == name) {
        return node;
      }
    }

    return null;
  };

  return nodes;
};
const NATIVE_PREFIX = '__shady_native_';
const SHADY_PREFIX = '__shady_';
const nativeChildNodesArray = parent => {
  const result = [];

  for (let n = parent[NATIVE_PREFIX + 'firstChild']; n; n = n[NATIVE_PREFIX + 'nextSibling']) {
    result.push(n);
  }

  return result;
};
const childNodesArray = parent => {
  const result = [];

  for (let n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
    result.push(n);
  }

  return result;
};
/**
 * Patch a group of accessors on an object only if it exists or if the `force`
 * argument is true.
 * @param {!Object} proto
 * @param {!Object} descriptors
 * @param {string=} prefix
 * @param {Array=} disallowedPatches
 */

const patchProperties = (proto, descriptors, prefix = '', disallowedPatches) => {
  for (let p in descriptors) {
    const newDescriptor = descriptors[p];

    if (disallowedPatches && disallowedPatches.indexOf(p) >= 0) {
      continue;
    }

    newDescriptor.configurable = true;
    const name = prefix + p; // NOTE: we prefer writing directly because some browsers
    // have descriptors that are writable but not configurable (e.g.
    // `appendChild` on older browsers)

    if (newDescriptor.value) {
      proto[name] = newDescriptor.value;
    } else {
      // NOTE: this can throw if 'force' is used so catch the error.
      try {
        Object.defineProperty(proto, name, newDescriptor);
      } catch (e) {// this error is harmless so we just trap it.
      }
    }
  }
};
/** @type {!function(new:HTMLElement)} */

const NativeHTMLElement = window['customElements'] && window['customElements']['nativeHTMLElement'] || HTMLElement; // note, this is not a perfect polyfill since it doesn't include symbols

/** @return {!Object<!ObjectPropertyDescriptor>} */

const getOwnPropertyDescriptors = obj => {
  const descriptors = {};
  Object.getOwnPropertyNames(obj).forEach(name => {
    descriptors[name] = Object.getOwnPropertyDescriptor(obj, name);
  });
  return descriptors;
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/flush.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
 // render enqueuer/flusher

let flushList = [];
let scheduled;
function enqueue(callback) {
  if (!scheduled) {
    scheduled = true;
    microtask(flush);
  }

  flushList.push(callback);
}
function flush() {
  scheduled = false;
  let didFlush = Boolean(flushList.length);

  while (flushList.length) {
    flushList.shift()();
  }

  return didFlush;
}
flush['list'] = flushList;
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/observe-changes.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



class observe_changes_AsyncObserver {
  constructor() {
    this._scheduled = false;
    this.addedNodes = [];
    this.removedNodes = [];
    this.callbacks = new Set();
  }

  schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      microtask(() => {
        this.flush();
      });
    }
  }

  flush() {
    if (this._scheduled) {
      this._scheduled = false;
      let mutations = this.takeRecords();

      if (mutations.length) {
        this.callbacks.forEach(function (cb) {
          cb(mutations);
        });
      }
    }
  }

  takeRecords() {
    if (this.addedNodes.length || this.removedNodes.length) {
      let mutations = [{
        addedNodes: this.addedNodes,
        removedNodes: this.removedNodes
      }];
      this.addedNodes = [];
      this.removedNodes = [];
      return mutations;
    }

    return [];
  }

} // TODO(sorvell): consider instead polyfilling MutationObserver
// directly so that users do not have to fork their code.
// Supporting the entire api may be challenging: e.g. filtering out
// removed nodes in the wrong scope and seeing non-distributing
// subtree child mutations.


let observeChildren = function (node, callback) {
  const sd = ensureShadyDataForNode(node);

  if (!sd.observer) {
    sd.observer = new observe_changes_AsyncObserver();
  }

  sd.observer.callbacks.add(callback);
  let observer = sd.observer;
  return {
    _callback: callback,
    _observer: observer,
    _node: node,

    takeRecords() {
      return observer.takeRecords();
    }

  };
};
let unobserveChildren = function (handle) {
  let observer = handle && handle._observer;

  if (observer) {
    observer.callbacks.delete(handle._callback);

    if (!observer.callbacks.size) {
      ensureShadyDataForNode(handle._node).observer = null;
    }
  }
};
function filterMutations(mutations, target) {
  /** @const {Node} */
  const targetRootNode = target.getRootNode();
  return mutations.map(function (mutation) {
    /** @const {boolean} */
    const mutationInScope = targetRootNode === mutation.target.getRootNode();

    if (mutationInScope && mutation.addedNodes) {
      let nodes = Array.from(mutation.addedNodes).filter(function (n) {
        return targetRootNode === n.getRootNode();
      });

      if (nodes.length) {
        mutation = Object.create(mutation);
        Object.defineProperty(mutation, 'addedNodes', {
          value: nodes,
          configurable: true
        });
        return mutation;
      }
    } else if (mutationInScope) {
      return mutation;
    }
  }).filter(function (m) {
    return m;
  });
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/innerHTML.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
// Cribbed from ShadowDOM polyfill
// https://github.com/webcomponents/webcomponentsjs/blob/master/src/ShadowDOM/wrappers/HTMLElement.js#L28
/////////////////////////////////////////////////////////////////////////////
// innerHTML and outerHTML
// http://www.whatwg.org/specs/web-apps/current-work/multipage/the-end.html#escapingString
let escapeAttrRegExp = /[&\u00A0"]/g;
let escapeDataRegExp = /[&\u00A0<>]/g;

function escapeReplace(c) {
  switch (c) {
    case '&':
      return '&amp;';

    case '<':
      return '&lt;';

    case '>':
      return '&gt;';

    case '"':
      return '&quot;';

    case '\u00A0':
      return '&nbsp;';
  }
}

function escapeAttr(s) {
  return s.replace(escapeAttrRegExp, escapeReplace);
}

function escapeData(s) {
  return s.replace(escapeDataRegExp, escapeReplace);
}

function makeSet(arr) {
  let set = {};

  for (let i = 0; i < arr.length; i++) {
    set[arr[i]] = true;
  }

  return set;
} // http://www.whatwg.org/specs/web-apps/current-work/#void-elements


let voidElements = makeSet(['area', 'base', 'br', 'col', 'command', 'embed', 'hr', 'img', 'input', 'keygen', 'link', 'meta', 'param', 'source', 'track', 'wbr']);
let plaintextParents = makeSet(['style', 'script', 'xmp', 'iframe', 'noembed', 'noframes', 'plaintext', 'noscript']);
/**
 * @param {Node} node
 * @param {Node} parentNode
 * @param {Function=} callback
 */

function getOuterHTML(node, parentNode, callback) {
  switch (node.nodeType) {
    case Node.ELEMENT_NODE:
      {
        let tagName = node.localName;
        let s = '<' + tagName;
        let attrs = node.attributes;

        for (let i = 0, attr; attr = attrs[i]; i++) {
          s += ' ' + attr.name + '="' + escapeAttr(attr.value) + '"';
        }

        s += '>';

        if (voidElements[tagName]) {
          return s;
        }

        return s + getInnerHTML(node, callback) + '</' + tagName + '>';
      }

    case Node.TEXT_NODE:
      {
        let data =
        /** @type {Text} */
        node.data;

        if (parentNode && plaintextParents[parentNode.localName]) {
          return data;
        }

        return escapeData(data);
      }

    case Node.COMMENT_NODE:
      {
        return '<!--' +
        /** @type {Comment} */
        node.data + '-->';
      }

    default:
      {
        window.console.error(node);
        throw new Error('not implemented');
      }
  }
}
/**
 * @param {Node} node
 * @param {Function=} callback
 */

function getInnerHTML(node, callback) {
  if (node.localName === 'template') {
    node =
    /** @type {HTMLTemplateElement} */
    node.content;
  }

  let s = '';
  let c$ = callback ? callback(node) : node.childNodes;

  for (let i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {
    s += getOuterHTML(child, node, callback);
  }

  return s;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-native.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



const hasDescriptors = settings.hasDescriptors;
const patch_native_NATIVE_PREFIX = NATIVE_PREFIX; // Object on which raw native methods are stored.
// e.g. `nativeMethods.querySelector.call(node, selector)`
// same as `node.querySelector(selector)`

const nativeMethods = {
  /** @this {Element} */
  querySelector(selector) {
    return this[patch_native_NATIVE_PREFIX + 'querySelector'](selector);
  },

  /** @this {Element} */
  querySelectorAll(selector) {
    return this[patch_native_NATIVE_PREFIX + 'querySelectorAll'](selector);
  }

}; // Object on which raw native accessors are available via `accessorName(node)`.
// e.g. `nativeTree.firstChild(node)`
// same as `node.firstChild`

const nativeTree = {};

const installNativeAccessor = name => {
  nativeTree[name] = node => node[patch_native_NATIVE_PREFIX + name];
};

const installNativeMethod = (name, fn) => {
  if (!nativeMethods[name]) {
    nativeMethods[name] = fn;
  }
};

const defineNativeAccessors = (proto, descriptors) => {
  patchProperties(proto, descriptors, patch_native_NATIVE_PREFIX); // make native accessors available to users

  for (let prop in descriptors) {
    installNativeAccessor(prop);
  }
};

const copyProperties = (proto, list = []) => {
  for (let i = 0; i < list.length; i++) {
    const name = list[i];
    const descriptor = Object.getOwnPropertyDescriptor(proto, name);

    if (descriptor) {
      Object.defineProperty(proto, patch_native_NATIVE_PREFIX + name, descriptor); // make native methods/accessors available to users

      if (descriptor.value) {
        installNativeMethod(name, descriptor.value);
      } else {
        installNativeAccessor(name);
      }
    }
  }
};
/** @type {!TreeWalker} */


const nodeWalker = document.createTreeWalker(document, NodeFilter.SHOW_ALL, null, false);
/** @type {!TreeWalker} */

const elementWalker = document.createTreeWalker(document, NodeFilter.SHOW_ELEMENT, null, false);
/** @type {!Document} */

const inertDoc = document.implementation.createHTMLDocument('inert');

const clearNode = node => {
  let firstChild;

  while (firstChild = node[patch_native_NATIVE_PREFIX + 'firstChild']) {
    node[patch_native_NATIVE_PREFIX + 'removeChild'](firstChild);
  }
};

const ParentNodeAccessors = ['firstElementChild', 'lastElementChild', 'children', 'childElementCount'];
const ParentNodeMethods = ['querySelector', 'querySelectorAll' // 'append', 'prepend'
];
const addNativePrefixedProperties = () => {
  // EventTarget
  const eventProps = ['dispatchEvent', 'addEventListener', 'removeEventListener'];

  if (window.EventTarget) {
    copyProperties(window.EventTarget.prototype, eventProps);
  } else {
    copyProperties(Node.prototype, eventProps);
    copyProperties(Window.prototype, eventProps);
  } // Node


  if (hasDescriptors) {
    copyProperties(Node.prototype, ['parentNode', 'firstChild', 'lastChild', 'previousSibling', 'nextSibling', 'childNodes', 'parentElement', 'textContent']);
  } else {
    defineNativeAccessors(Node.prototype, {
      parentNode: {
        /** @this {Node} */
        get() {
          nodeWalker.currentNode = this;
          return nodeWalker.parentNode();
        }

      },
      firstChild: {
        /** @this {Node} */
        get() {
          nodeWalker.currentNode = this;
          return nodeWalker.firstChild();
        }

      },
      lastChild: {
        /** @this {Node} */
        get() {
          nodeWalker.currentNode = this;
          return nodeWalker.lastChild();
        }

      },
      previousSibling: {
        /** @this {Node} */
        get() {
          nodeWalker.currentNode = this;
          return nodeWalker.previousSibling();
        }

      },
      nextSibling: {
        /** @this {Node} */
        get() {
          nodeWalker.currentNode = this;
          return nodeWalker.nextSibling();
        }

      },
      // TODO(sorvell): make this a NodeList or whatever
      childNodes: {
        /** @this {Node} */
        get() {
          const nodes = [];
          nodeWalker.currentNode = this;
          let n = nodeWalker.firstChild();

          while (n) {
            nodes.push(n);
            n = nodeWalker.nextSibling();
          }

          return nodes;
        }

      },
      parentElement: {
        /** @this {Node} */
        get() {
          elementWalker.currentNode = this;
          return elementWalker.parentNode();
        }

      },
      textContent: {
        /** @this {Node} */
        get() {
          /* eslint-disable no-case-declarations */
          switch (this.nodeType) {
            case Node.ELEMENT_NODE:
            case Node.DOCUMENT_FRAGMENT_NODE:
              // TODO(sorvell): This cannot be a single TreeWalker that's reused
              // at least for Safari 9, but it's unclear why.
              const textWalker = document.createTreeWalker(this, NodeFilter.SHOW_TEXT, null, false);
              let content = '',
                  n;

              while (n = textWalker.nextNode()) {
                // TODO(sorvell): can't use textContent since we patch it on Node.prototype!
                // However, should probably patch it only on element.
                content += n.nodeValue;
              }

              return content;

            default:
              return this.nodeValue;
          }
        },

        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)

        /** @this {Node} */
        set(value) {
          if (typeof value === 'undefined' || value === null) {
            value = '';
          }

          switch (this.nodeType) {
            case Node.ELEMENT_NODE:
            case Node.DOCUMENT_FRAGMENT_NODE:
              clearNode(this); // Document fragments must have no childnodes if setting a blank string

              if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {
                // Note: old Chrome versions require 2nd argument here
                this[patch_native_NATIVE_PREFIX + 'insertBefore'](document.createTextNode(value), undefined);
              }

              break;

            default:
              // TODO(sorvell): can't do this if patch nodeValue.
              this.nodeValue = value;
              break;
          }
        }

      }
    });
  }

  copyProperties(Node.prototype, ['appendChild', 'insertBefore', 'removeChild', 'replaceChild', 'cloneNode', 'contains']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement

  copyProperties(HTMLElement.prototype, ['parentElement', 'contains']);
  const ParentNodeWalkerDescriptors = {
    firstElementChild: {
      /** @this {ParentNode} */
      get() {
        elementWalker.currentNode = this;
        return elementWalker.firstChild();
      }

    },
    lastElementChild: {
      /** @this {ParentNode} */
      get() {
        elementWalker.currentNode = this;
        return elementWalker.lastChild();
      }

    },
    children: {
      /** @this {ParentNode} */
      get() {
        let nodes = [];
        elementWalker.currentNode = this;
        let n = elementWalker.firstChild();

        while (n) {
          nodes.push(n);
          n = elementWalker.nextSibling();
        }

        return createPolyfilledHTMLCollection(nodes);
      }

    },
    childElementCount: {
      /** @this {ParentNode} */
      get() {
        if (this.children) {
          return this.children.length;
        }

        return 0;
      }

    }
  }; // Element

  if (hasDescriptors) {
    copyProperties(Element.prototype, ParentNodeAccessors);
    copyProperties(Element.prototype, ['previousElementSibling', 'nextElementSibling', 'innerHTML', 'className']); // NOTE, on some browsers IE 11 / Edge 15 some properties are incorrectly on HTMLElement

    copyProperties(HTMLElement.prototype, ['children', 'innerHTML', 'className']);
  } else {
    defineNativeAccessors(Element.prototype, ParentNodeWalkerDescriptors);
    defineNativeAccessors(Element.prototype, {
      previousElementSibling: {
        /** @this {Element} */
        get() {
          elementWalker.currentNode = this;
          return elementWalker.previousSibling();
        }

      },
      nextElementSibling: {
        /** @this {Element} */
        get() {
          elementWalker.currentNode = this;
          return elementWalker.nextSibling();
        }

      },
      innerHTML: {
        /** @this {Element} */
        get() {
          return getInnerHTML(this, nativeChildNodesArray);
        },

        // Needed on browsers that do not proper accessors (e.g. old versions of Chrome)

        /** @this {Element} */
        set(value) {
          const content = this.localName === 'template' ?
          /** @type {HTMLTemplateElement} */
          this.content : this;
          clearNode(content);
          const containerName = this.localName || 'div';
          let htmlContainer;

          if (!this.namespaceURI || this.namespaceURI === inertDoc.namespaceURI) {
            htmlContainer = inertDoc.createElement(containerName);
          } else {
            htmlContainer = inertDoc.createElementNS(this.namespaceURI, containerName);
          }

          htmlContainer.innerHTML = value;
          const newContent = this.localName === 'template' ?
          /** @type {HTMLTemplateElement} */
          htmlContainer.content : htmlContainer;
          let firstChild;

          while (firstChild = newContent[patch_native_NATIVE_PREFIX + 'firstChild']) {
            // Note: old Chrome versions require 2nd argument here
            content[patch_native_NATIVE_PREFIX + 'insertBefore'](firstChild, undefined);
          }
        }

      },
      className: {
        /** @this {Element} */
        get() {
          return this.getAttribute('class') || '';
        },

        /** @this {Element} */
        set(value) {
          this.setAttribute('class', value);
        }

      }
    });
  }

  copyProperties(Element.prototype, ['setAttribute', 'getAttribute', 'hasAttribute', 'removeAttribute', // on older Safari, these are on Element.
  'focus', 'blur']);
  copyProperties(Element.prototype, ParentNodeMethods); // HTMLElement

  copyProperties(HTMLElement.prototype, ['focus', 'blur']); // HTMLTemplateElement

  if (window.HTMLTemplateElement) {
    copyProperties(window.HTMLTemplateElement.prototype, ['innerHTML']);
  } // DocumentFragment


  if (hasDescriptors) {
    // NOTE, IE 11 does not have on DocumentFragment
    // firstElementChild
    // lastElementChild
    copyProperties(DocumentFragment.prototype, ParentNodeAccessors);
  } else {
    defineNativeAccessors(DocumentFragment.prototype, ParentNodeWalkerDescriptors);
  }

  copyProperties(DocumentFragment.prototype, ParentNodeMethods); // Document

  if (hasDescriptors) {
    copyProperties(Document.prototype, ParentNodeAccessors);
    copyProperties(Document.prototype, ['activeElement']);
  } else {
    defineNativeAccessors(Document.prototype, ParentNodeWalkerDescriptors);
  }

  copyProperties(Document.prototype, ['importNode', 'getElementById']);
  copyProperties(Document.prototype, ParentNodeMethods);
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-instances.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const InsideDescriptors = getOwnPropertyDescriptors({
  /** @this {Node} */
  get childNodes() {
    return this[SHADY_PREFIX + 'childNodes'];
  },

  /** @this {Node} */
  get firstChild() {
    return this[SHADY_PREFIX + 'firstChild'];
  },

  /** @this {Node} */
  get lastChild() {
    return this[SHADY_PREFIX + 'lastChild'];
  },

  /** @this {Node} */
  get childElementCount() {
    return this[SHADY_PREFIX + 'childElementCount'];
  },

  /** @this {Node} */
  get children() {
    return this[SHADY_PREFIX + 'children'];
  },

  /** @this {Node} */
  get firstElementChild() {
    return this[SHADY_PREFIX + 'firstElementChild'];
  },

  /** @this {Node} */
  get lastElementChild() {
    return this[SHADY_PREFIX + 'lastElementChild'];
  },

  /** @this {Node} */
  get shadowRoot() {
    return this[SHADY_PREFIX + 'shadowRoot'];
  }

});
const TextContentInnerHTMLDescriptors = getOwnPropertyDescriptors({
  /** @this {Node} */
  get textContent() {
    return this[SHADY_PREFIX + 'textContent'];
  },

  /** @this {Node} */
  set textContent(value) {
    this[SHADY_PREFIX + 'textContent'] = value;
  },

  /** @this {Node} */
  get innerHTML() {
    return this[SHADY_PREFIX + 'innerHTML'];
  },

  /** @this {Node} */
  set innerHTML(value) {
    return this[SHADY_PREFIX + 'innerHTML'] = value;
  }

});
const OutsideDescriptors = getOwnPropertyDescriptors({
  /** @this {Node} */
  get parentElement() {
    return this[SHADY_PREFIX + 'parentElement'];
  },

  /** @this {Node} */
  get parentNode() {
    return this[SHADY_PREFIX + 'parentNode'];
  },

  /** @this {Node} */
  get nextSibling() {
    return this[SHADY_PREFIX + 'nextSibling'];
  },

  /** @this {Node} */
  get previousSibling() {
    return this[SHADY_PREFIX + 'previousSibling'];
  },

  /** @this {Node} */
  get nextElementSibling() {
    return this[SHADY_PREFIX + 'nextElementSibling'];
  },

  /** @this {Node} */
  get previousElementSibling() {
    return this[SHADY_PREFIX + 'previousElementSibling'];
  },

  /** @this {Node} */
  get className() {
    return this[SHADY_PREFIX + 'className'];
  },

  /** @this {Node} */
  set className(value) {
    return this[SHADY_PREFIX + 'className'] = value;
  }

});

for (let prop in InsideDescriptors) {
  InsideDescriptors[prop].enumerable = false;
}

for (let prop in TextContentInnerHTMLDescriptors) {
  TextContentInnerHTMLDescriptors[prop].enumerable = false;
}

for (let prop in OutsideDescriptors) {
  OutsideDescriptors[prop].enumerable = false;
}

const noInstancePatching = settings.hasDescriptors || settings.noPatch; // ensure an element has patched "outside" accessors; no-op when not needed

let patchOutsideElementAccessors = noInstancePatching ? function () {} : function (element) {
  const sd = ensureShadyDataForNode(element);

  if (!sd.__outsideAccessors) {
    sd.__outsideAccessors = true;
    patchProperties(element, OutsideDescriptors);
  }
}; // ensure an element has patched "inside" accessors; no-op when not needed

let patchInsideElementAccessors = noInstancePatching ? function () {} : function (element) {
  const sd = ensureShadyDataForNode(element);

  if (!sd.__insideAccessors) {
    sd.__insideAccessors = true;
    patchProperties(element, InsideDescriptors); // NOTE: There are compatibility issues with patches for `textContent`
    // and `innerHTML` between CE and SD. Since SD patches are applied
    // via `ShadyDOM.patch` and CE patches are applied as the tree is walked,
    // SD patches overwrite CE patches.
    // * When SD is in patching mode, SD calls through to native
    // methods not patched by CE (since SD is at the bottom) and CE does not
    // upgrade, connect, or disconnect elements. Therefore do *not patch*
    // these accessors in this case.
    // * When SD is in `noPatch` mode, the SD patches call through to
    // "native" methods that are patched by CE (since CE is at the bottom).
    // Therefore continue to patch in this case.
    // If customElements is not loaded, then these accessors should be
    // patched so they work correctly.

    if (!window['customElements'] || settings.noPatch) {
      patchProperties(element, TextContentInnerHTMLDescriptors);
    }
  }
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-events.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


/*
Make this name unique so it is unlikely to conflict with properties on objects passed to `addEventListener`
https://github.com/webcomponents/shadydom/issues/173
*/

const
/** string */
eventWrappersName = "__eventWrappers".concat(Date.now());
/** @type {?function(!Event): boolean} */

const composedGetter = (() => {
  const composedProp = Object.getOwnPropertyDescriptor(Event.prototype, 'composed');
  return composedProp ? ev => composedProp.get.call(ev) : null;
})();

const supportsEventOptions = (() => {
  let supported = false;
  let eventOptions = {
    get capture() {
      supported = true;
    }

  };

  const listener = () => {}; // NOTE: These will be unpatched at this point.


  window.addEventListener('test', listener, eventOptions);
  window.removeEventListener('test', listener, eventOptions);
  return supported;
})();

const parseEventOptions = optionsOrCapture => {
  let capture, once, passive, shadyTarget;

  if (optionsOrCapture && typeof optionsOrCapture === 'object') {
    capture = Boolean(optionsOrCapture.capture);
    once = Boolean(optionsOrCapture.once);
    passive = Boolean(optionsOrCapture.passive);
    shadyTarget = optionsOrCapture.__shadyTarget;
  } else {
    capture = Boolean(optionsOrCapture);
    once = false;
    passive = false;
  }

  return {
    shadyTarget,
    capture,
    once,
    passive,
    nativeEventOptions: supportsEventOptions ? optionsOrCapture : capture
  };
}; // https://github.com/w3c/webcomponents/issues/513#issuecomment-224183937


const alwaysComposed = {
  'blur': true,
  'focus': true,
  'focusin': true,
  'focusout': true,
  'click': true,
  'dblclick': true,
  'mousedown': true,
  'mouseenter': true,
  'mouseleave': true,
  'mousemove': true,
  'mouseout': true,
  'mouseover': true,
  'mouseup': true,
  'wheel': true,
  'beforeinput': true,
  'input': true,
  'keydown': true,
  'keyup': true,
  'compositionstart': true,
  'compositionupdate': true,
  'compositionend': true,
  'touchstart': true,
  'touchend': true,
  'touchmove': true,
  'touchcancel': true,
  'pointerover': true,
  'pointerenter': true,
  'pointerdown': true,
  'pointermove': true,
  'pointerup': true,
  'pointercancel': true,
  'pointerout': true,
  'pointerleave': true,
  'gotpointercapture': true,
  'lostpointercapture': true,
  'dragstart': true,
  'drag': true,
  'dragenter': true,
  'dragleave': true,
  'dragover': true,
  'drop': true,
  'dragend': true,
  'DOMActivate': true,
  'DOMFocusIn': true,
  'DOMFocusOut': true,
  'keypress': true
};
const unpatchedEvents = {
  'DOMAttrModified': true,
  'DOMAttributeNameChanged': true,
  'DOMCharacterDataModified': true,
  'DOMElementNameChanged': true,
  'DOMNodeInserted': true,
  'DOMNodeInsertedIntoDocument': true,
  'DOMNodeRemoved': true,
  'DOMNodeRemovedFromDocument': true,
  'DOMSubtreeModified': true
  /**
   * Some EventTarget subclasses are not Node subclasses, and you cannot call
   * `getRootNode()` on them.
   *
   * @param {!(Node|EventTarget)} eventTarget
   * @return {!(Node|EventTarget)}
   */

};

function getRootNodeWithFallback(eventTarget) {
  if (eventTarget instanceof Node) {
    return eventTarget[SHADY_PREFIX + 'getRootNode']();
  } else {
    return eventTarget;
  }
}

function pathComposer(startNode, composed) {
  let composedPath = [];
  let current = startNode;
  let startRoot = getRootNodeWithFallback(startNode);

  while (current) {
    composedPath.push(current);

    if (current[SHADY_PREFIX + 'assignedSlot']) {
      current = current[SHADY_PREFIX + 'assignedSlot'];
    } else if (current.nodeType === Node.DOCUMENT_FRAGMENT_NODE && current.host && (composed || current !== startRoot)) {
      current = current.host;
    } else {
      current = current[SHADY_PREFIX + 'parentNode'];
    }
  } // event composedPath includes window when startNode's ownerRoot is document


  if (composedPath[composedPath.length - 1] === document) {
    composedPath.push(window);
  }

  return composedPath;
}

const patch_events_composedPath = event => {
  if (!event.__composedPath) {
    event.__composedPath = pathComposer(event.target, true);
  }

  return event.__composedPath;
};

function retarget(refNode, path) {
  if (!utils_isShadyRoot) {
    return refNode;
  } // If ANCESTOR's root is not a shadow root or ANCESTOR's root is BASE's
  // shadow-including inclusive ancestor, return ANCESTOR.


  let refNodePath = pathComposer(refNode, true);
  let p$ = path;

  for (let i = 0, ancestor, lastRoot, root, rootIdx; i < p$.length; i++) {
    ancestor = p$[i];
    root = getRootNodeWithFallback(ancestor);

    if (root !== lastRoot) {
      rootIdx = refNodePath.indexOf(root);
      lastRoot = root;
    }

    if (!utils_isShadyRoot(root) || rootIdx > -1) {
      return ancestor;
    }
  }
}

let EventPatches = {
  /**
   * @this {Event}
   */
  get composed() {
    if (this.__composed === undefined) {
      // if there's an original `composed` getter on the Event prototype, use that
      if (composedGetter) {
        // TODO(web-padawan): see https://github.com/webcomponents/shadydom/issues/275
        this.__composed = this.type === 'focusin' || this.type === 'focusout' || composedGetter(this); // If the event is trusted, or `isTrusted` is not supported, check the list of always composed events
      } else if (this.isTrusted !== false) {
        this.__composed = alwaysComposed[this.type];
      }
    }

    return (
      /** @type {!Event} */
      this.__composed || false
    );
  },

  /**
   * @this {Event}
   */
  composedPath() {
    if (!this.__composedPath) {
      this.__composedPath = pathComposer(this['__target'], this.composed);
    }

    return (
      /** @type {!Event} */
      this.__composedPath
    );
  },

  /**
   * @this {Event}
   */
  get target() {
    return retarget(this.currentTarget || this['__previousCurrentTarget'], this.composedPath());
  },

  // http://w3c.github.io/webcomponents/spec/shadow/#event-relatedtarget-retargeting

  /**
   * @this {Event}
   */
  get relatedTarget() {
    if (!this.__relatedTarget) {
      return null;
    }

    if (!this.__relatedTargetComposedPath) {
      this.__relatedTargetComposedPath = pathComposer(this.__relatedTarget, true);
    } // find the deepest node in relatedTarget composed path that is in the same root with the currentTarget


    return retarget(this.currentTarget || this['__previousCurrentTarget'],
    /** @type {!Event} */
    this.__relatedTargetComposedPath);
  },

  /**
   * @this {Event}
   */
  stopPropagation() {
    Event.prototype.stopPropagation.call(this);
    this.__propagationStopped = true;
  },

  /**
   * @this {Event}
   */
  stopImmediatePropagation() {
    Event.prototype.stopImmediatePropagation.call(this);
    this.__immediatePropagationStopped = true;
    this.__propagationStopped = true;
  }

};

function mixinComposedFlag(Base) {
  // NOTE: avoiding use of `class` here so that transpiled output does not
  // try to do `Base.call` with a dom construtor.
  let klazz = function (type, options) {
    let event = new Base(type, options);
    event.__composed = options && Boolean(options['composed']);
    return event;
  }; // put constructor properties on subclass


  klazz.__proto__ = Base;
  klazz.prototype = Base.prototype;
  return klazz;
}

let nonBubblingEventsToRetarget = {
  'focus': true,
  'blur': true
};
/**
 * Check if the event has been retargeted by comparing original `target`, and calculated `target`
 * @param {Event} event
 * @return {boolean} True if the original target and calculated target are the same
 */

function hasRetargeted(event) {
  return event['__target'] !== event.target || event.__relatedTarget !== event.relatedTarget;
}
/**
 *
 * @param {Event} event
 * @param {Node} node
 * @param {string} phase
 */


function fireHandlers(event, node, phase) {
  let hs = node.__handlers && node.__handlers[event.type] && node.__handlers[event.type][phase];

  if (hs) {
    for (let i = 0, fn; fn = hs[i]; i++) {
      if (hasRetargeted(event) && event.target === event.relatedTarget) {
        return;
      }

      fn.call(node, event);

      if (event.__immediatePropagationStopped) {
        return;
      }
    }
  }
}

function retargetNonBubblingEvent(e) {
  let path = e.composedPath();
  let node; // override `currentTarget` to let patched `target` calculate correctly

  Object.defineProperty(e, 'currentTarget', {
    get: function () {
      return node;
    },
    configurable: true
  });

  for (let i = path.length - 1; i >= 0; i--) {
    node = path[i]; // capture phase fires all capture handlers

    fireHandlers(e, node, 'capture');

    if (e.__propagationStopped) {
      return;
    }
  } // set the event phase to `AT_TARGET` as in spec


  Object.defineProperty(e, 'eventPhase', {
    get() {
      return Event.AT_TARGET;
    }

  }); // the event only needs to be fired when owner roots change when iterating the event path
  // keep track of the last seen owner root

  let lastFiredRoot;

  for (let i = 0; i < path.length; i++) {
    node = path[i];
    const nodeData = shadyDataForNode(node);
    const root = nodeData && nodeData.root;

    if (i === 0 || root && root === lastFiredRoot) {
      fireHandlers(e, node, 'bubble'); // don't bother with window, it doesn't have `getRootNode` and will be last in the path anyway

      if (node !== window) {
        lastFiredRoot = node[SHADY_PREFIX + 'getRootNode']();
      }

      if (e.__propagationStopped) {
        return;
      }
    }
  }
}

function listenerSettingsEqual(savedListener, node, type, capture, once, passive) {
  let {
    node: savedNode,
    type: savedType,
    capture: savedCapture,
    once: savedOnce,
    passive: savedPassive
  } = savedListener;
  return node === savedNode && type === savedType && capture === savedCapture && once === savedOnce && passive === savedPassive;
}

function findListener(wrappers, node, type, capture, once, passive) {
  for (let i = 0; i < wrappers.length; i++) {
    if (listenerSettingsEqual(wrappers[i], node, type, capture, once, passive)) {
      return i;
    }
  }

  return -1;
}
/**
 * Firefox can throw on accessing eventWrappers inside of `removeEventListener` during a selenium run
 * Try/Catch accessing eventWrappers to work around
 * https://bugzilla.mozilla.org/show_bug.cgi?id=1353074
 */

function getEventWrappers(eventLike) {
  let wrappers = null;

  try {
    wrappers = eventLike[eventWrappersName];
  } catch (e) {} // eslint-disable-line no-empty


  return wrappers;
}

function targetNeedsPathCheck(node) {
  return utils_isShadyRoot(node) || node.localName === 'slot';
}
/**
 * @this {EventTarget}
 */


function addEventListener(type, fnOrObj, optionsOrCapture) {
  const {
    capture,
    once,
    passive,
    shadyTarget,
    nativeEventOptions
  } = parseEventOptions(optionsOrCapture);

  if (!fnOrObj) {
    return;
  }

  const handlerType = typeof fnOrObj; // bail if `fnOrObj` is not a function, not an object

  if (handlerType !== 'function' && handlerType !== 'object') {
    return;
  } // bail if `fnOrObj` is an object without a `handleEvent` method


  if (handlerType === 'object' && (!fnOrObj.handleEvent || typeof fnOrObj.handleEvent !== 'function')) {
    return;
  }

  if (unpatchedEvents[type]) {
    return this[NATIVE_PREFIX + 'addEventListener'](type, fnOrObj, nativeEventOptions);
  } // hack to let ShadyRoots have event listeners
  // event listener will be on host, but `currentTarget`
  // will be set to shadyroot for event listener


  let target = shadyTarget || this;
  let wrappers = fnOrObj[eventWrappersName];

  if (wrappers) {
    // The callback `fn` might be used for multiple nodes/events. Since we generate
    // a wrapper function, we need to keep track of it when we remove the listener.
    // It's more efficient to store the node/type/options information as Array in
    // `fn` itself rather than the node (we assume that the same callback is used
    // for few nodes at most, whereas a node will likely have many event listeners).
    // NOTE(valdrin) invoking external functions is costly, inline has better perf.
    // Stop if the wrapper function has already been created.
    if (findListener(wrappers, target, type, capture, once, passive) > -1) {
      return;
    }
  } else {
    fnOrObj[eventWrappersName] = [];
  }
  /**
   * @this {HTMLElement}
   * @param {Event} e
   */


  const wrapperFn = function (e) {
    // Support `once` option.
    if (once) {
      this[SHADY_PREFIX + 'removeEventListener'](type, fnOrObj, optionsOrCapture);
    }

    if (!e['__target']) {
      patchEvent(e);
    }

    let lastCurrentTargetDesc;

    if (target !== this) {
      // replace `currentTarget` to make `target` and `relatedTarget` correct for inside the shadowroot
      lastCurrentTargetDesc = Object.getOwnPropertyDescriptor(e, 'currentTarget');
      Object.defineProperty(e, 'currentTarget', {
        get() {
          return target;
        },

        configurable: true
      });
    }

    e['__previousCurrentTarget'] = e['currentTarget']; // Always check if a shadowRoot or slot is in the current event path.
    // If it is not, the event was generated on either the host of the shadowRoot
    // or a children of the host.

    if (targetNeedsPathCheck(target) && e.composedPath().indexOf(target) == -1) {
      return;
    } // There are two critera that should stop events from firing on this node
    // 1. the event is not composed and the current node is not in the same root as the target
    // 2. when bubbling, if after retargeting, relatedTarget and target point to the same node


    if (e.composed || e.composedPath().indexOf(target) > -1) {
      if (hasRetargeted(e) && e.target === e.relatedTarget) {
        if (e.eventPhase === Event.BUBBLING_PHASE) {
          e.stopImmediatePropagation();
        }

        return;
      } // prevent non-bubbling events from triggering bubbling handlers on shadowroot, but only if not in capture phase


      if (e.eventPhase !== Event.CAPTURING_PHASE && !e.bubbles && e.target !== target && !(target instanceof Window)) {
        return;
      }

      let ret = handlerType === 'function' ? fnOrObj.call(target, e) : fnOrObj.handleEvent && fnOrObj.handleEvent(e);

      if (target !== this) {
        // replace the "correct" `currentTarget`
        if (lastCurrentTargetDesc) {
          Object.defineProperty(e, 'currentTarget', lastCurrentTargetDesc);
          lastCurrentTargetDesc = null;
        } else {
          delete e['currentTarget'];
        }
      }

      return ret;
    }
  }; // Store the wrapper information.


  fnOrObj[eventWrappersName].push({
    // note: use target here which is either a shadowRoot
    // (when the host element is proxy'ing the event) or this element
    node: target,
    type: type,
    capture: capture,
    once: once,
    passive: passive,
    wrapperFn: wrapperFn
  });

  if (nonBubblingEventsToRetarget[type]) {
    this.__handlers = this.__handlers || {};
    this.__handlers[type] = this.__handlers[type] || {
      'capture': [],
      'bubble': []
    };

    this.__handlers[type][capture ? 'capture' : 'bubble'].push(wrapperFn);
  } else {
    this[NATIVE_PREFIX + 'addEventListener'](type, wrapperFn, nativeEventOptions);
  }
}
/**
 * @this {EventTarget}
 */

function removeEventListener(type, fnOrObj, optionsOrCapture) {
  if (!fnOrObj) {
    return;
  }

  const {
    capture,
    once,
    passive,
    shadyTarget,
    nativeEventOptions
  } = parseEventOptions(optionsOrCapture);

  if (unpatchedEvents[type]) {
    return this[NATIVE_PREFIX + 'removeEventListener'](type, fnOrObj, nativeEventOptions);
  }

  let target = shadyTarget || this; // Search the wrapped function.

  let wrapperFn = undefined;
  let wrappers = getEventWrappers(fnOrObj);

  if (wrappers) {
    let idx = findListener(wrappers, target, type, capture, once, passive);

    if (idx > -1) {
      wrapperFn = wrappers.splice(idx, 1)[0].wrapperFn; // Cleanup.

      if (!wrappers.length) {
        fnOrObj[eventWrappersName] = undefined;
      }
    }
  }

  this[NATIVE_PREFIX + 'removeEventListener'](type, wrapperFn || fnOrObj, nativeEventOptions);

  if (wrapperFn && nonBubblingEventsToRetarget[type] && this.__handlers && this.__handlers[type]) {
    const arr = this.__handlers[type][capture ? 'capture' : 'bubble'];
    const idx = arr.indexOf(wrapperFn);

    if (idx > -1) {
      arr.splice(idx, 1);
    }
  }
}

function activateFocusEventOverrides() {
  for (let ev in nonBubblingEventsToRetarget) {
    window[NATIVE_PREFIX + 'addEventListener'](ev, function (e) {
      if (!e['__target']) {
        patchEvent(e);
        retargetNonBubblingEvent(e);
      }
    }, true);
  }
}

const EventPatchesDescriptors = getOwnPropertyDescriptors(EventPatches);
const SHADY_PROTO = '__shady_patchedProto';
const SHADY_SOURCE_PROTO = '__shady_sourceProto';

function patchEvent(event) {
  event['__target'] = event.target;
  event.__relatedTarget = event.relatedTarget; // attempt to patch prototype (via cache)

  if (settings.hasDescriptors) {
    const proto = Object.getPrototypeOf(event);

    if (!Object.hasOwnProperty(proto, SHADY_PROTO)) {
      const patchedProto = Object.create(proto);
      patchedProto[SHADY_SOURCE_PROTO] = proto;
      patchProperties(patchedProto, EventPatchesDescriptors);
      proto[SHADY_PROTO] = patchedProto;
    }

    event.__proto__ = proto[SHADY_PROTO]; // and fallback to patching instance
  } else {
    patchProperties(event, EventPatchesDescriptors);
  }
}

let PatchedEvent = mixinComposedFlag(Event);
let PatchedCustomEvent = mixinComposedFlag(CustomEvent);
let PatchedMouseEvent = mixinComposedFlag(MouseEvent);
function patchEvents() {
  activateFocusEventOverrides();
  window.Event = PatchedEvent;
  window.CustomEvent = PatchedCustomEvent;
  window.MouseEvent = PatchedMouseEvent;
}
function patchClick() {
  // Fix up `Element.prototype.click()` if `isTrusted` is supported, but `composed` isn't
  if (!composedGetter && Object.getOwnPropertyDescriptor(Event.prototype, 'isTrusted')) {
    /** @this {Element} */
    const composedClickFn = function () {
      const ev = new MouseEvent('click', {
        bubbles: true,
        cancelable: true,
        composed: true
      });
      this[SHADY_PREFIX + 'dispatchEvent'](ev);
    };

    if (Element.prototype.click) {
      Element.prototype.click = composedClickFn;
    } else if (HTMLElement.prototype.click) {
      HTMLElement.prototype.click = composedClickFn;
    }
  }
}
const eventPropertyNames = Object.getOwnPropertyNames(Document.prototype).filter(name => name.substring(0, 2) === 'on');
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/array-splice.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function newSplice(index, removed, addedCount) {
  return {
    index: index,
    removed: removed,
    addedCount: addedCount
  };
}

const EDIT_LEAVE = 0;
const EDIT_UPDATE = 1;
const EDIT_ADD = 2;
const EDIT_DELETE = 3; // Note: This function is *based* on the computation of the Levenshtein
// "edit" distance. The one change is that "updates" are treated as two
// edits - not one. With Array splices, an update is really a delete
// followed by an add. By retaining this, we optimize for "keeping" the
// maximum array items in the original array. For example:
//
//   'xxxx123' -> '123yyyy'
//
// With 1-edit updates, the shortest path would be just to update all seven
// characters. With 2-edit updates, we delete 4, leave 3, and add 4. This
// leaves the substring '123' intact.

function calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  // "Deletion" columns
  let rowCount = oldEnd - oldStart + 1;
  let columnCount = currentEnd - currentStart + 1;
  let distances = new Array(rowCount); // "Addition" rows. Initialize null column.

  for (let i = 0; i < rowCount; i++) {
    distances[i] = new Array(columnCount);
    distances[i][0] = i;
  } // Initialize null row


  for (let j = 0; j < columnCount; j++) distances[0][j] = j;

  for (let i = 1; i < rowCount; i++) {
    for (let j = 1; j < columnCount; j++) {
      if (equals(current[currentStart + j - 1], old[oldStart + i - 1])) distances[i][j] = distances[i - 1][j - 1];else {
        let north = distances[i - 1][j] + 1;
        let west = distances[i][j - 1] + 1;
        distances[i][j] = north < west ? north : west;
      }
    }
  }

  return distances;
} // This starts at the final weight, and walks "backward" by finding
// the minimum previous weight recursively until the origin of the weight
// matrix.


function spliceOperationsFromEditDistances(distances) {
  let i = distances.length - 1;
  let j = distances[0].length - 1;
  let current = distances[i][j];
  let edits = [];

  while (i > 0 || j > 0) {
    if (i == 0) {
      edits.push(EDIT_ADD);
      j--;
      continue;
    }

    if (j == 0) {
      edits.push(EDIT_DELETE);
      i--;
      continue;
    }

    let northWest = distances[i - 1][j - 1];
    let west = distances[i - 1][j];
    let north = distances[i][j - 1];
    let min;
    if (west < north) min = west < northWest ? west : northWest;else min = north < northWest ? north : northWest;

    if (min == northWest) {
      if (northWest == current) {
        edits.push(EDIT_LEAVE);
      } else {
        edits.push(EDIT_UPDATE);
        current = northWest;
      }

      i--;
      j--;
    } else if (min == west) {
      edits.push(EDIT_DELETE);
      i--;
      current = west;
    } else {
      edits.push(EDIT_ADD);
      j--;
      current = north;
    }
  }

  edits.reverse();
  return edits;
}
/**
 * Splice Projection functions:
 *
 * A splice map is a representation of how a previous array of items
 * was transformed into a new array of items. Conceptually it is a list of
 * tuples of
 *
 *   <index, removed, addedCount>
 *
 * which are kept in ascending index order of. The tuple represents that at
 * the |index|, |removed| sequence of items were removed, and counting forward
 * from |index|, |addedCount| items were added.
 */

/**
 * Lacking individual splice mutation information, the minimal set of
 * splices can be synthesized given the previous state and final state of an
 * array. The basic approach is to calculate the edit distance matrix and
 * choose the shortest path through it.
 *
 * Complexity: O(l * p)
 *   l: The length of the current array
 *   p: The length of the old array
 */


function calcSplices(current, currentStart, currentEnd, old, oldStart, oldEnd) {
  let prefixCount = 0;
  let suffixCount = 0;
  let splice;
  let minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);
  if (currentStart == 0 && oldStart == 0) prefixCount = sharedPrefix(current, old, minLength);
  if (currentEnd == current.length && oldEnd == old.length) suffixCount = sharedSuffix(current, old, minLength - prefixCount);
  currentStart += prefixCount;
  oldStart += prefixCount;
  currentEnd -= suffixCount;
  oldEnd -= suffixCount;
  if (currentEnd - currentStart == 0 && oldEnd - oldStart == 0) return [];

  if (currentStart == currentEnd) {
    splice = newSplice(currentStart, [], 0);

    while (oldStart < oldEnd) splice.removed.push(old[oldStart++]);

    return [splice];
  } else if (oldStart == oldEnd) return [newSplice(currentStart, [], currentEnd - currentStart)];

  let ops = spliceOperationsFromEditDistances(calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));
  splice = undefined;
  let splices = [];
  let index = currentStart;
  let oldIndex = oldStart;

  for (let i = 0; i < ops.length; i++) {
    switch (ops[i]) {
      case EDIT_LEAVE:
        if (splice) {
          splices.push(splice);
          splice = undefined;
        }

        index++;
        oldIndex++;
        break;

      case EDIT_UPDATE:
        if (!splice) splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;

      case EDIT_ADD:
        if (!splice) splice = newSplice(index, [], 0);
        splice.addedCount++;
        index++;
        break;

      case EDIT_DELETE:
        if (!splice) splice = newSplice(index, [], 0);
        splice.removed.push(old[oldIndex]);
        oldIndex++;
        break;
    }
  }

  if (splice) {
    splices.push(splice);
  }

  return splices;
}

function sharedPrefix(current, old, searchLength) {
  for (let i = 0; i < searchLength; i++) if (!equals(current[i], old[i])) return i;

  return searchLength;
}

function sharedSuffix(current, old, searchLength) {
  let index1 = current.length;
  let index2 = old.length;
  let count = 0;

  while (count < searchLength && equals(current[--index1], old[--index2])) count++;

  return count;
}

function equals(currentValue, previousValue) {
  return currentValue === previousValue;
}

function calculateSplices(current, previous) {
  return calcSplices(current, 0, current.length, previous, 0, previous.length);
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/link-nodes.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




function linkNode(node, container, containerData, ref_node) {
  patchOutsideElementAccessors(node);
  ref_node = ref_node || null;
  const nodeData = ensureShadyDataForNode(node);
  const ref_nodeData = ref_node ? ensureShadyDataForNode(ref_node) : null; // update ref_node.previousSibling <-> node

  nodeData.previousSibling = ref_node ? ref_nodeData.previousSibling : container[SHADY_PREFIX + 'lastChild'];
  let psd = shadyDataForNode(nodeData.previousSibling);

  if (psd) {
    psd.nextSibling = node;
  } // update node <-> ref_node


  let nsd = shadyDataForNode(nodeData.nextSibling = ref_node);

  if (nsd) {
    nsd.previousSibling = node;
  } // update node <-> container


  nodeData.parentNode = container;

  if (ref_node) {
    if (ref_node === containerData.firstChild) {
      containerData.firstChild = node;
    }
  } else {
    containerData.lastChild = node;

    if (!containerData.firstChild) {
      containerData.firstChild = node;
    }
  } // remove caching of childNodes


  containerData.childNodes = null;
}

const recordInsertBefore = (node, container, ref_node) => {
  patchInsideElementAccessors(container);
  const containerData = ensureShadyDataForNode(container);

  if (containerData.firstChild !== undefined) {
    containerData.childNodes = null;
  } // handle document fragments


  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    // Note, documentFragments should not have logical DOM so there's
    // no need update that. It is possible to append a ShadowRoot, but we're
    // choosing not to support that.
    const first = node[NATIVE_PREFIX + 'firstChild'];

    for (let n = first; n; n = n[NATIVE_PREFIX + 'nextSibling']) {
      linkNode(n, container, containerData, ref_node);
    }
  } else {
    linkNode(node, container, containerData, ref_node);
  }
};
const recordRemoveChild = (node, container) => {
  const nodeData = ensureShadyDataForNode(node);
  const containerData = ensureShadyDataForNode(container);

  if (node === containerData.firstChild) {
    containerData.firstChild = nodeData.nextSibling;
  }

  if (node === containerData.lastChild) {
    containerData.lastChild = nodeData.previousSibling;
  }

  let p = nodeData.previousSibling;
  let n = nodeData.nextSibling;

  if (p) {
    ensureShadyDataForNode(p).nextSibling = n;
  }

  if (n) {
    ensureShadyDataForNode(n).previousSibling = p;
  } // When an element is removed, logical data is no longer tracked.
  // Explicitly set `undefined` here to indicate this. This is disginguished
  // from `null` which is set if info is null.


  nodeData.parentNode = nodeData.previousSibling = nodeData.nextSibling = undefined;

  if (containerData.childNodes !== undefined) {
    // remove caching of childNodes
    containerData.childNodes = null;
  }
};
/**
 * @param  {!Node|DocumentFragment} node
 * @param  {!Node|DocumentFragment=} adoptedParent
 */

const recordChildNodes = (node, adoptedParent) => {
  const nodeData = ensureShadyDataForNode(node);

  if (!adoptedParent && nodeData.firstChild !== undefined) {
    return;
  } // remove caching of childNodes


  nodeData.childNodes = null;
  const first = nodeData.firstChild = node[NATIVE_PREFIX + 'firstChild'];
  nodeData.lastChild = node[NATIVE_PREFIX + 'lastChild'];
  patchInsideElementAccessors(node);

  for (let n = first, previous; n; n = n[NATIVE_PREFIX + 'nextSibling']) {
    const sd = ensureShadyDataForNode(n);
    sd.parentNode = adoptedParent || node;
    sd.nextSibling = n[NATIVE_PREFIX + 'nextSibling'];
    sd.previousSibling = previous || null;
    previous = n;
    patchOutsideElementAccessors(n);
  }
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/style-scoping.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

let style_scoping_scopingShim = null;
function getScopingShim() {
  if (!style_scoping_scopingShim) {
    style_scoping_scopingShim = window['ShadyCSS'] && window['ShadyCSS']['ScopingShim'];
  }

  return style_scoping_scopingShim || null;
}
/**
 * @param {!Node} node
 * @param {string} attr
 * @param {string} value
 */

function scopeClassAttribute(node, attr, value) {
  const scopingShim = getScopingShim();

  if (scopingShim && attr === 'class') {
    scopingShim['setElementClass'](node, value);
    return true;
  }

  return false;
}
/**
 * @param {!Node} node
 * @param {string} newScopeName
 */

function addShadyScoping(node, newScopeName) {
  const scopingShim = getScopingShim();

  if (!scopingShim) {
    return;
  }

  scopingShim['scopeNode'](node, newScopeName);
}
/**
 * @param {!Node} node
 * @param {string} currentScopeName
 */

function removeShadyScoping(node, currentScopeName) {
  const scopingShim = getScopingShim();

  if (!scopingShim) {
    return;
  }

  scopingShim['unscopeNode'](node, currentScopeName);
}
/**
 * @param {!Node} node
 * @param {string} newScopeName
 * @param {string} oldScopeName
 */

function replaceShadyScoping(node, newScopeName, oldScopeName) {
  const scopingShim = getScopingShim();

  if (!scopingShim) {
    return;
  }

  if (oldScopeName) {
    removeShadyScoping(node, oldScopeName);
  }

  addShadyScoping(node, newScopeName);
}
/**
 * @param {!Node} node
 * @param {string} newScopeName
 * @return {boolean}
 */

function currentScopeIsCorrect(node, newScopeName) {
  const scopingShim = getScopingShim();

  if (!scopingShim) {
    return true;
  }

  if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
    // NOTE: as an optimization, only check that all the top-level children
    // have the correct scope.
    let correctScope = true;

    for (let n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
      correctScope = correctScope && currentScopeIsCorrect(n, newScopeName);
    }

    return correctScope;
  }

  if (node.nodeType !== Node.ELEMENT_NODE) {
    return true;
  }

  const currentScope = scopingShim['currentScopeForNode'](node);
  return currentScope === newScopeName;
}
/**
 * @param {!Node} node
 * @return {string}
 */

function currentScopeForNode(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return '';
  }

  const scopingShim = getScopingShim();

  if (!scopingShim) {
    return '';
  }

  return scopingShim['currentScopeForNode'](node);
}
/**
 * Walk over a node's tree and apply visitorFn to each element node
 *
 * @param {Node} node
 * @param {function(!Node):void} visitorFn
 */

function treeVisitor(node, visitorFn) {
  if (!node) {
    return;
  } // this check is necessary if `node` is a Document Fragment


  if (node.nodeType === Node.ELEMENT_NODE) {
    visitorFn(node);
  }

  for (let n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
    if (n.nodeType === Node.ELEMENT_NODE) {
      treeVisitor(n, visitorFn);
    }
  }
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Node.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





const doc = window.document;
const preferPerformance = settings.preferPerformance;
const nativeIsConnectedAccessors =
/** @type {ObjectPropertyDescriptor} */
Object.getOwnPropertyDescriptor(Node.prototype, 'isConnected');
const nativeIsConnected = nativeIsConnectedAccessors && nativeIsConnectedAccessors.get;
function Node_clearNode(node) {
  let firstChild;

  while (firstChild = node[SHADY_PREFIX + 'firstChild']) {
    node[SHADY_PREFIX + 'removeChild'](firstChild);
  }
}

function removeOwnerShadyRoot(node) {
  // optimization: only reset the tree if node is actually in a root
  if (hasCachedOwnerRoot(node)) {
    for (let n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
      removeOwnerShadyRoot(n);
    }
  }

  const nodeData = shadyDataForNode(node);

  if (nodeData) {
    nodeData.ownerShadyRoot = undefined;
  }
}

function hasCachedOwnerRoot(node) {
  const nodeData = shadyDataForNode(node);
  return Boolean(nodeData && nodeData.ownerShadyRoot !== undefined);
}
/**
 * Finds the first flattened node that is composed in the node's parent.
 * If the given node is a slot, then the first flattened node is returned
 * if it exists, otherwise advance to the node's nextSibling.
 * @param {Node} node within which to find first composed node
 * @returns {Node} first composed node
 */


function firstComposedNode(node) {
  let composed = node;

  if (node && node.localName === 'slot') {
    const nodeData = shadyDataForNode(node);
    const flattened = nodeData && nodeData.flattenedNodes;
    composed = flattened && flattened.length ? flattened[0] : firstComposedNode(node[SHADY_PREFIX + 'nextSibling']);
  }

  return composed;
}
/**
 * @param {Node} node
 * @param {Node=} addedNode
 * @param {Node=} removedNode
 */


function scheduleObserver(node, addedNode, removedNode) {
  const nodeData = shadyDataForNode(node);
  const observer = nodeData && nodeData.observer;

  if (observer) {
    if (addedNode) {
      observer.addedNodes.push(addedNode);
    }

    if (removedNode) {
      observer.removedNodes.push(removedNode);
    }

    observer.schedule();
  }
}

const NodePatches = getOwnPropertyDescriptors({
  /** @this {Node} */
  get parentNode() {
    const nodeData = shadyDataForNode(this);
    const l = nodeData && nodeData.parentNode;
    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentNode'];
  },

  /** @this {Node} */
  get firstChild() {
    const nodeData = shadyDataForNode(this);
    const l = nodeData && nodeData.firstChild;
    return l !== undefined ? l : this[NATIVE_PREFIX + 'firstChild'];
  },

  /** @this {Node} */
  get lastChild() {
    const nodeData = shadyDataForNode(this);
    const l = nodeData && nodeData.lastChild;
    return l !== undefined ? l : this[NATIVE_PREFIX + 'lastChild'];
  },

  /** @this {Node} */
  get nextSibling() {
    const nodeData = shadyDataForNode(this);
    const l = nodeData && nodeData.nextSibling;
    return l !== undefined ? l : this[NATIVE_PREFIX + 'nextSibling'];
  },

  /** @this {Node} */
  get previousSibling() {
    const nodeData = shadyDataForNode(this);
    const l = nodeData && nodeData.previousSibling;
    return l !== undefined ? l : this[NATIVE_PREFIX + 'previousSibling'];
  },

  /** @this {Node} */
  get childNodes() {
    let childNodes;

    if (isTrackingLogicalChildNodes(this)) {
      const nodeData = shadyDataForNode(this);

      if (!nodeData.childNodes) {
        nodeData.childNodes = [];

        for (let n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
          nodeData.childNodes.push(n);
        }
      }

      childNodes = nodeData.childNodes;
    } else {
      childNodes = this[NATIVE_PREFIX + 'childNodes'];
    }

    childNodes.item = function (index) {
      return childNodes[index];
    };

    return childNodes;
  },

  /** @this {Node} */
  get parentElement() {
    const nodeData = shadyDataForNode(this);
    let l = nodeData && nodeData.parentNode;

    if (l && l.nodeType !== Node.ELEMENT_NODE) {
      l = null;
    }

    return l !== undefined ? l : this[NATIVE_PREFIX + 'parentElement'];
  },

  /** @this {Node} */
  get isConnected() {
    if (nativeIsConnected && nativeIsConnected.call(this)) {
      return true;
    }

    if (this.nodeType == Node.DOCUMENT_FRAGMENT_NODE) {
      return false;
    } // Fast path for distributed nodes.


    const ownerDocument = this.ownerDocument;

    if (hasDocumentContains) {
      if (ownerDocument[NATIVE_PREFIX + 'contains'](this)) {
        return true;
      }
    } else if (ownerDocument.documentElement && ownerDocument.documentElement[NATIVE_PREFIX + 'contains'](this)) {
      return true;
    } // Slow path for non-distributed nodes.


    let node = this;

    while (node && !(node instanceof Document)) {
      node = node[SHADY_PREFIX + 'parentNode'] || (utils_isShadyRoot(node) ?
      /** @type {ShadowRoot} */
      node.host : undefined);
    }

    return !!(node && node instanceof Document);
  },

  /** @this {Node} */
  get textContent() {
    if (isTrackingLogicalChildNodes(this)) {
      let tc = [];

      for (let n = this[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
        if (n.nodeType !== Node.COMMENT_NODE) {
          tc.push(n[SHADY_PREFIX + 'textContent']);
        }
      }

      return tc.join('');
    } else {
      return this[NATIVE_PREFIX + 'textContent'];
    }
  },

  /**
   * @this {Node}
   * @param {string} value
   */
  set textContent(value) {
    if (typeof value === 'undefined' || value === null) {
      value = '';
    }

    switch (this.nodeType) {
      case Node.ELEMENT_NODE:
      case Node.DOCUMENT_FRAGMENT_NODE:
        if (!isTrackingLogicalChildNodes(this) && settings.hasDescriptors) {
          // may be removing a nested slot but fast path if we know we are not.
          const firstChild = this[SHADY_PREFIX + 'firstChild'];

          if (firstChild != this[SHADY_PREFIX + 'lastChild'] || firstChild && firstChild.nodeType != Node.TEXT_NODE) {
            Node_clearNode(this);
          }

          this[NATIVE_PREFIX + 'textContent'] = value;
        } else {
          Node_clearNode(this); // Document fragments must have no childNodes if setting a blank string

          if (value.length > 0 || this.nodeType === Node.ELEMENT_NODE) {
            this[SHADY_PREFIX + 'insertBefore'](document.createTextNode(value));
          }
        }

        break;

      default:
        // Note, be wary of patching `nodeValue`.
        this.nodeValue = value;
        break;
    }
  },

  // Patched `insertBefore`. Note that all mutations that add nodes are routed
  // here. When a <slot> is added or a node is added to a host with a shadowRoot
  // with a slot, a standard dom `insert` call is aborted and `_asyncRender`
  // is called on the relevant shadowRoot. In all other cases, a standard dom
  // `insert` can be made, but the location and ref_node may need to be changed.

  /**
   * @this {Node}
   * @param {Node} node
   * @param {Node=} ref_node
   */
  insertBefore(node, ref_node) {
    // optimization: assume native insertBefore is ok if the nodes are not in the document.
    if (this.ownerDocument !== doc && node.ownerDocument !== doc) {
      this[NATIVE_PREFIX + 'insertBefore'](node, ref_node);
      return node;
    }

    if (node === this) {
      throw Error("Failed to execute 'appendChild' on 'Node': The new child element contains the parent.");
    }

    if (ref_node) {
      const refData = shadyDataForNode(ref_node);
      const p = refData && refData.parentNode;

      if (p !== undefined && p !== this || p === undefined && ref_node[NATIVE_PREFIX + 'parentNode'] !== this) {
        throw Error("Failed to execute 'insertBefore' on 'Node': The node " + "before which the new node is to be inserted is not a child of this node.");
      }
    }

    if (ref_node === node) {
      return node;
    }
    /** @type {!Array<!HTMLSlotElement>} */


    const slotsAdded = [];
    const ownerRoot = ownerShadyRootForNode(this);
    /** @type {string} */

    const newScopeName = ownerRoot ? ownerRoot.host.localName : currentScopeForNode(this);
    /** @type {string} */

    let oldScopeName; // remove from existing location

    const parentNode = node[SHADY_PREFIX + 'parentNode'];

    if (parentNode) {
      oldScopeName = currentScopeForNode(node);
      const skipUnscoping = // Don't remove scoping if we're inserting into another shadowRoot;
      // this would be unnecessary since it will be re-scoped below
      Boolean(ownerRoot) || // Don't remove scoping if we're being moved between non-shadowRoot
      // locations (the likely case is when moving pre-scoped nodes in a template)
      !ownerShadyRootForNode(node) || // Under preferPerformance, don't remove scoping when moving back into
      // a document fragment that was previously scoped; the assumption is
      // that the user should only move correctly-scoped DOM back into it
      preferPerformance && this['__noInsertionPoint'] !== undefined;
      parentNode[SHADY_PREFIX + 'removeChild'](node, skipUnscoping);
    } // add to new parent


    let allowNativeInsert = true;
    const needsScoping = (!preferPerformance || // Under preferPerformance, only re-scope if we're not coming from a
    // pre-scoped doc fragment or back into a pre-scoped doc fragment
    node['__noInsertionPoint'] === undefined && this['__noInsertionPoint'] === undefined) && !currentScopeIsCorrect(node, newScopeName);
    const needsSlotFinding = ownerRoot && !node['__noInsertionPoint'] && (!preferPerformance || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE);

    if (needsSlotFinding || needsScoping) {
      // NOTE: avoid node.removeChild as this *can* trigger another patched
      // method (e.g. custom elements) and we want only the shady method to run.
      // The following table describes what style scoping actions should happen as a result of this insertion.
      // document -> shadowRoot: replace
      // shadowRoot -> shadowRoot: replace
      // shadowRoot -> shadowRoot of same type: do nothing
      // shadowRoot -> document: allow unscoping
      // document -> document: do nothing
      // The "same type of shadowRoot" and "document to document cases rely on `currentScopeIsCorrect` returning true
      if (needsScoping) {
        // in a document or disconnected tree, replace scoping if necessary
        oldScopeName = oldScopeName || currentScopeForNode(node);
      }

      treeVisitor(node, node => {
        if (needsSlotFinding && node.localName === 'slot') {
          slotsAdded.push(
          /** @type {!HTMLSlotElement} */
          node);
        }

        if (needsScoping) {
          replaceShadyScoping(node, newScopeName, oldScopeName);
        }
      });
    } // if a slot is added, must render containing root.


    if (slotsAdded.length) {
      ownerRoot._addSlots(slotsAdded);

      ownerRoot._asyncRender();
    }

    if (isTrackingLogicalChildNodes(this)) {
      recordInsertBefore(node, this, ref_node); // when inserting into a host with a shadowRoot with slot, use
      // `shadowRoot._asyncRender()` via `attach-shadow` module

      const parentData = shadyDataForNode(this);

      if (hasShadowRootWithSlot(this)) {
        parentData.root._asyncRender();

        allowNativeInsert = false; // when inserting into a host with shadowRoot with NO slot, do nothing
        // as the node should not be added to composed dome anywhere.
      } else if (parentData.root) {
        allowNativeInsert = false;
      }
    }

    if (allowNativeInsert) {
      // if adding to a shadyRoot, add to host instead
      let container = utils_isShadyRoot(this) ?
      /** @type {ShadowRoot} */
      this.host : this; // if ref_node, get the ref_node that's actually in composed dom.

      if (ref_node) {
        ref_node = firstComposedNode(ref_node);
        container[NATIVE_PREFIX + 'insertBefore'](node, ref_node);
      } else {
        container[NATIVE_PREFIX + 'appendChild'](node);
      } // Since ownerDocument is not patched, it can be incorrect after this call
      // if the node is physically appended via distribution. This can result
      // in the custom elements polyfill not upgrading the node if it's in an inert doc.
      // We correct this by calling `adoptNode`.

    } else if (node.ownerDocument !== this.ownerDocument) {
      this.ownerDocument.adoptNode(node);
    }

    scheduleObserver(this, node);
    return node;
  },

  /**
   * @this {Node}
   * @param {Node} node
   */
  appendChild(node) {
    // if this is a shadowRoot and the shadowRoot is passed as `node`
    // then an optimized append has already been performed, so do nothing.
    if (!(this == node && utils_isShadyRoot(node))) {
      return this[SHADY_PREFIX + 'insertBefore'](node);
    }
  },

  /**
   * Patched `removeChild`. Note that all dom "removals" are routed here.
   * Removes the given `node` from the element's `children`.
   * This method also performs dom composition.
   * @this {Node}
   * @param {Node} node
   * @param {boolean=} skipUnscoping
   */
  removeChild(node, skipUnscoping = false) {
    if (this.ownerDocument !== doc) {
      return this[NATIVE_PREFIX + 'removeChild'](node);
    }

    if (node[SHADY_PREFIX + 'parentNode'] !== this) {
      throw Error('The node to be removed is not a child of this node: ' + node);
    }

    let preventNativeRemove;
    let ownerRoot = ownerShadyRootForNode(node);

    const removingInsertionPoint = ownerRoot && ownerRoot._removeContainedSlots(node);

    const parentData = shadyDataForNode(this);

    if (isTrackingLogicalChildNodes(this)) {
      recordRemoveChild(node, this);

      if (hasShadowRootWithSlot(this)) {
        parentData.root._asyncRender();

        preventNativeRemove = true;
      }
    } // unscope a node leaving a ShadowRoot if ShadyCSS is present, and this node
    // is not going to be rescoped in `insertBefore`


    if (getScopingShim() && !skipUnscoping && ownerRoot && node.nodeType !== Node.TEXT_NODE) {
      const oldScopeName = currentScopeForNode(node);
      treeVisitor(node, node => {
        removeShadyScoping(node, oldScopeName);
      });
    }

    removeOwnerShadyRoot(node); // if removing slot, must render containing root

    if (ownerRoot) {
      let changeSlotContent = this && this.localName === 'slot';

      if (changeSlotContent) {
        preventNativeRemove = true;
      }

      if (removingInsertionPoint || changeSlotContent) {
        ownerRoot._asyncRender();
      }
    }

    if (!preventNativeRemove) {
      // if removing from a shadyRoot, remove from host instead
      let container = utils_isShadyRoot(this) ?
      /** @type {ShadowRoot} */
      this.host : this; // not guaranteed to physically be in container; e.g.
      // (1) if parent has a shadyRoot, element may or may not at distributed
      // location (could be undistributed)
      // (2) if parent is a slot, element may not ben in composed dom

      if (!(parentData.root || node.localName === 'slot') || container === node[NATIVE_PREFIX + 'parentNode']) {
        container[NATIVE_PREFIX + 'removeChild'](node);
      }
    }

    scheduleObserver(this, null, node);
    return node;
  },

  /**
   * @this {Node}
   * @param {Node} node
   * @param {Node=} ref_node
   */
  replaceChild(node, ref_node) {
    this[SHADY_PREFIX + 'insertBefore'](node, ref_node);
    this[SHADY_PREFIX + 'removeChild'](ref_node);
    return node;
  },

  /**
   * @this {Node}
   * @param {boolean=} deep
   */
  cloneNode(deep) {
    if (this.localName == 'template') {
      return this[NATIVE_PREFIX + 'cloneNode'](deep);
    } else {
      const n = this[NATIVE_PREFIX + 'cloneNode'](false); // Attribute nodes historically had childNodes, but they have later
      // been removed from the spec.
      // Make sure we do not do a deep clone on them for old browsers (IE11)

      if (deep && n.nodeType !== Node.ATTRIBUTE_NODE) {
        for (let c = this[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {
          nc = c[SHADY_PREFIX + 'cloneNode'](true);
          n[SHADY_PREFIX + 'appendChild'](nc);
        }
      }

      return n;
    }
  },

  /**
   * @this {Node}
   * @param {Object=} options
   */
  // TODO(sorvell): implement `options` e.g. `{ composed: boolean }`
  getRootNode(options) {
    // eslint-disable-line no-unused-vars
    if (!this || !this.nodeType) {
      return;
    }

    const nodeData = ensureShadyDataForNode(this);
    let root = nodeData.ownerShadyRoot;

    if (root === undefined) {
      if (utils_isShadyRoot(this)) {
        root = this;
        nodeData.ownerShadyRoot = root;
      } else {
        let parent = this[SHADY_PREFIX + 'parentNode'];
        root = parent ? parent[SHADY_PREFIX + 'getRootNode'](options) : this; // memo-ize result for performance but only memo-ize
        // result if node is in the document. This avoids a problem where a root
        // can be cached while an element is inside a fragment.
        // If this happens and we cache the result, the value can become stale
        // because for perf we avoid processing the subtree of added fragments.

        if (document.documentElement[NATIVE_PREFIX + 'contains'](this)) {
          nodeData.ownerShadyRoot = root;
        }
      }
    }

    return root;
  },

  /** @this {Node} */
  contains(node) {
    return contains(this, node);
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ParentNode.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


/**
 * @param {Node} node
 * @param {Function} matcher
 * @param {Function=} halter
 */

function query(node, matcher, halter) {
  let list = [];
  queryChildNodes(node, matcher, halter, list);
  return list;
}

function queryChildNodes(parent, matcher, halter, list) {
  for (let n = parent[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
    if (n.nodeType === Node.ELEMENT_NODE && queryElement(n, matcher, halter, list)) {
      return true;
    }
  }
}

function queryElement(node, matcher, halter, list) {
  let result = matcher(node);

  if (result) {
    list.push(node);
  }

  if (halter && halter(result)) {
    return result;
  }

  queryChildNodes(node, matcher, halter, list);
} // Needed on Element, DocumentFragment, Document


const ParentNodePatches = getOwnPropertyDescriptors({
  /** @this {Element} */
  get firstElementChild() {
    const nodeData = shadyDataForNode(this);

    if (nodeData && nodeData.firstChild !== undefined) {
      let n = this[SHADY_PREFIX + 'firstChild'];

      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n[SHADY_PREFIX + 'nextSibling'];
      }

      return n;
    } else {
      return this[NATIVE_PREFIX + 'firstElementChild'];
    }
  },

  /** @this {Element} */
  get lastElementChild() {
    const nodeData = shadyDataForNode(this);

    if (nodeData && nodeData.lastChild !== undefined) {
      let n = this[SHADY_PREFIX + 'lastChild'];

      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n[SHADY_PREFIX + 'previousSibling'];
      }

      return n;
    } else {
      return this[NATIVE_PREFIX + 'lastElementChild'];
    }
  },

  /** @this {Element} */
  get children() {
    if (!isTrackingLogicalChildNodes(this)) {
      return this[NATIVE_PREFIX + 'children'];
    }

    return createPolyfilledHTMLCollection(Array.prototype.filter.call(childNodesArray(this), n => {
      return n.nodeType === Node.ELEMENT_NODE;
    }));
  },

  /** @this {Element} */
  get childElementCount() {
    let children = this[SHADY_PREFIX + 'children'];

    if (children) {
      return children.length;
    }

    return 0;
  }

});
const QueryPatches = getOwnPropertyDescriptors({
  // TODO(sorvell): consider doing native QSA and filtering results.

  /**
   * @this {Element}
   * @param  {string} selector
   */
  querySelector(selector) {
    // match selector and halt on first result.
    let result = query(this, function (n) {
      return matchesSelector(n, selector);
    }, function (n) {
      return Boolean(n);
    })[0];
    return result || null;
  },

  /**
   * @this {Element}
   * @param  {string} selector
   * @param  {boolean} useNative
   */
  // TODO(sorvell): `useNative` option relies on native querySelectorAll and
  // misses distributed nodes, see
  // https://github.com/webcomponents/shadydom/pull/210#issuecomment-361435503
  querySelectorAll(selector, useNative) {
    if (useNative) {
      const o = Array.prototype.slice.call(this[NATIVE_PREFIX + 'querySelectorAll'](selector));
      const root = this[SHADY_PREFIX + 'getRootNode']();
      return o.filter(e => e[SHADY_PREFIX + 'getRootNode']() == root);
    }

    return query(this, function (n) {
      return matchesSelector(n, selector);
    });
  }

}); // In preferPerformance mode, create a custom `ParentNodeDocumentOrFragment`
// that optionally does not mixin querySelector/All; this is a performance
// optimization. In noPatch, we need to keep the query patches here in order to
// ensure the query API is available on the wrapper

const ParentNodeDocumentOrFragmentPatches = settings.preferPerformance && !settings.noPatch ? Object.assign({}, ParentNodePatches) : ParentNodePatches;
Object.assign(ParentNodePatches, QueryPatches);
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrFragment.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const DocumentOrFragmentPatches = getOwnPropertyDescriptors({
  /**
   * @this {Element}
   * @param {string} id
   */
  getElementById(id) {
    if (id === '') {
      return null;
    }

    let result = query(this, function (n) {
      return n.id == id;
    }, function (n) {
      return Boolean(n);
    })[0];
    return result || null;
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/DocumentOrShadowRoot.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



function getDocumentActiveElement() {
  if (settings.hasDescriptors) {
    return document[NATIVE_PREFIX + 'activeElement'];
  } else {
    return document.activeElement;
  }
}

const DocumentOrShadowRootPatches = getOwnPropertyDescriptors({
  /** @this {Document|ShadowRoot} */
  get activeElement() {
    let active = getDocumentActiveElement(); // In IE11, activeElement might be an empty object if the document is
    // contained in an iframe.
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10998788/

    if (!active || !active.nodeType) {
      return null;
    }

    let isShadyRoot = !!utils_isShadyRoot(this);

    if (this !== document) {
      // If this node isn't a document or shady root, then it doesn't have
      // an active element.
      if (!isShadyRoot) {
        return null;
      } // If this shady root's host is the active element or the active
      // element is not a descendant of the host (in the composed tree),
      // then it doesn't have an active element.


      if (this.host === active || !this.host[NATIVE_PREFIX + 'contains'](active)) {
        return null;
      }
    } // This node is either the document or a shady root of which the active
    // element is a (composed) descendant of its host; iterate upwards to
    // find the active element's most shallow host within it.


    let activeRoot = ownerShadyRootForNode(active);

    while (activeRoot && activeRoot !== this) {
      active = activeRoot.host;
      activeRoot = ownerShadyRootForNode(active);
    }

    if (this === document) {
      // This node is the document, so activeRoot should be null.
      return activeRoot ? null : active;
    } else {
      // This node is a non-document shady root, and it should be
      // activeRoot.
      return activeRoot === this ? active : null;
    }
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ElementOrShadowRoot.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/** @type {!Document} */

const ElementOrShadowRoot_inertDoc = document.implementation.createHTMLDocument('inert');
const ElementOrShadowRootPatches = getOwnPropertyDescriptors({
  /** @this {Element} */
  get innerHTML() {
    if (isTrackingLogicalChildNodes(this)) {
      const content = this.localName === 'template' ?
      /** @type {HTMLTemplateElement} */
      this.content : this;
      return getInnerHTML(content, childNodesArray);
    } else {
      return this[NATIVE_PREFIX + 'innerHTML'];
    }
  },

  /**
   * @this {Element}
   * @param {string} value
   */
  set innerHTML(value) {
    if (this.localName === 'template') {
      this[NATIVE_PREFIX + 'innerHTML'] = value;
    } else {
      Node_clearNode(this);
      const containerName = this.localName || 'div';
      let htmlContainer;

      if (!this.namespaceURI || this.namespaceURI === ElementOrShadowRoot_inertDoc.namespaceURI) {
        htmlContainer = ElementOrShadowRoot_inertDoc.createElement(containerName);
      } else {
        htmlContainer = ElementOrShadowRoot_inertDoc.createElementNS(this.namespaceURI, containerName);
      }

      if (settings.hasDescriptors) {
        htmlContainer[NATIVE_PREFIX + 'innerHTML'] = value;
      } else {
        htmlContainer.innerHTML = value;
      }

      let firstChild;

      while (firstChild = htmlContainer[SHADY_PREFIX + 'firstChild']) {
        this[SHADY_PREFIX + 'insertBefore'](firstChild);
      }
    }
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/ShadowRoot.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const ShadowRootPatches = getOwnPropertyDescriptors({
  /**
   * @this {ShadowRoot}
   * @param {string} type
   * @param {Function} fn
   * @param {Object|boolean=} optionsOrCapture
   */
  addEventListener(type, fn, optionsOrCapture) {
    if (typeof optionsOrCapture !== 'object') {
      optionsOrCapture = {
        capture: Boolean(optionsOrCapture)
      };
    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child


    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;
    this.host[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);
  },

  /**
   * @this {ShadowRoot}
   * @param {string} type
   * @param {Function} fn
   * @param {Object|boolean=} optionsOrCapture
   */
  removeEventListener(type, fn, optionsOrCapture) {
    if (typeof optionsOrCapture !== 'object') {
      optionsOrCapture = {
        capture: Boolean(optionsOrCapture)
      };
    } // Note, `__shadyTarget` may already be set if an event was added on a <slot> child


    optionsOrCapture.__shadyTarget = optionsOrCapture.__shadyTarget || this;
    this.host[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-shadyRoot.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/








/**
 * @param {!Object} proto
 * @param {string=} prefix
 */

const patchShadyAccessors = (proto, prefix) => {
  patchProperties(proto, ShadowRootPatches, prefix);
  patchProperties(proto, DocumentOrShadowRootPatches, prefix);
  patchProperties(proto, ElementOrShadowRootPatches, prefix); // We ensure ParentNode accessors since these do not exist in Edge/IE on DocumentFragments.

  patchProperties(proto, ParentNodePatches, prefix); // Ensure `shadowRoot` has basic descriptors when we cannot rely
  // on them coming from DocumentFragment.
  //
  // Case 1, noPatching: Because we want noPatch ShadyRoots to have native property
  // names so that they do not have to be wrapped...
  // When we do *not* patch Node/DocumentFragment.prototype
  // we must manually install those properties on ShadyRoot's prototype.
  // Note, it's important to only install these in this mode so as not to stomp
  // over CustomElements polyfill's patches on Node/DocumentFragment methods.

  if (settings.noPatch && !prefix) {
    patchProperties(proto, NodePatches, prefix);
    patchProperties(proto, DocumentOrFragmentPatches, prefix); // Case 2, bad descriptors: Ensure accessors are on ShadowRoot.
    // These descriptors are normally used for instance patching but because
    // ShadyRoot can always be patched, just do it to the prototype.
  } else if (!settings.hasDescriptors) {
    patchProperties(proto, OutsideDescriptors);
    patchProperties(proto, InsideDescriptors);
    patchProperties(proto, TextContentInnerHTMLDescriptors);
  }
};

const patchShadyRoot = proto => {
  proto.__proto__ = DocumentFragment.prototype; // patch both prefixed and not, even when noPatch == true.

  patchShadyAccessors(proto, SHADY_PREFIX);
  patchShadyAccessors(proto); // Ensure native properties are all safely wrapped since ShadowRoot is not an
  // actual DocumentFragment instance.

  Object.defineProperties(proto, {
    nodeType: {
      value: Node.DOCUMENT_FRAGMENT_NODE,
      configurable: true
    },
    nodeName: {
      value: '#document-fragment',
      configurable: true
    },
    nodeValue: {
      value: null,
      configurable: true
    }
  }); // make undefined

  ['localName', 'namespaceURI', 'prefix'].forEach(prop => {
    Object.defineProperty(proto, prop, {
      value: undefined,
      configurable: true
    });
  }); // defer properties to host

  ['ownerDocument', 'baseURI', 'isConnected'].forEach(prop => {
    Object.defineProperty(proto, prop, {
      /** @this {ShadowRoot} */
      get() {
        return this.host[prop];
      },

      configurable: true
    });
  });
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/attach-shadow.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





 // Do not export this object. It must be passed as the first argument to the
// ShadyRoot constructor in `attachShadow` to prevent the constructor from
// throwing. This prevents the user from being able to manually construct a
// ShadyRoot (i.e. `new ShadowRoot()`).

const ShadyRootConstructionToken = {};
const CATCHALL_NAME = '__catchall';
const SHADYROOT_NAME = 'ShadyRoot';
const MODE_CLOSED = 'closed';
let isRendering = settings['deferConnectionCallbacks'] && document.readyState === 'loading';
let rootRendered;

function ancestorList(node) {
  let ancestors = [];

  do {
    ancestors.unshift(node);
  } while (node = node[SHADY_PREFIX + 'parentNode']);

  return ancestors;
}
/**
 * @extends {ShadowRoot}
 */


class attach_shadow_ShadyRoot {
  constructor(token, host, options) {
    if (token !== ShadyRootConstructionToken) {
      throw new TypeError('Illegal constructor');
    }
    /** @type {boolean} */


    this._renderPending;
    /** @type {boolean} */

    this._hasRendered;
    /** @type {?Array<HTMLSlotElement>} */

    this._slotList = null;
    /** @type {?Object<string, Array<HTMLSlotElement>>} */

    this._slotMap;
    /** @type {?Array<HTMLSlotElement>} */

    this._pendingSlots;

    this._init(host, options);
  }

  _init(host, options) {
    // NOTE: set a fake local name so this element can be
    // distinguished from a DocumentFragment when patching.
    // FF doesn't allow this to be `localName`

    /** @type {string} */
    this._localName = SHADYROOT_NAME; // root <=> host

    this.host = host;
    /** @type {!string|undefined} */

    this.mode = options && options.mode;
    recordChildNodes(this.host);
    const hostData = ensureShadyDataForNode(this.host);
    /** @type {!ShadyRoot} */

    hostData.root = this;
    hostData.publicRoot = this.mode !== MODE_CLOSED ? this : null; // setup root

    const rootData = ensureShadyDataForNode(this);
    rootData.firstChild = rootData.lastChild = rootData.parentNode = rootData.nextSibling = rootData.previousSibling = null; // NOTE: optimization flag, only require an asynchronous render
    // to record parsed children if flag is not set.

    if (settings['preferPerformance']) {
      let n;

      while (n = this.host[NATIVE_PREFIX + 'firstChild']) {
        this.host[NATIVE_PREFIX + 'removeChild'](n);
      }
    } else {
      this._asyncRender();
    }
  }

  _asyncRender() {
    if (!this._renderPending) {
      this._renderPending = true;
      enqueue(() => this._render());
    }
  } // returns the oldest renderPending ancestor root.


  _getPendingDistributionRoot() {
    let renderRoot;
    let root = this;

    while (root) {
      if (root._renderPending) {
        renderRoot = root;
      }

      root = root._getDistributionParent();
    }

    return renderRoot;
  } // Returns the shadyRoot `this.host` if `this.host`
  // has children that require distribution.


  _getDistributionParent() {
    let root = this.host[SHADY_PREFIX + 'getRootNode']();

    if (!utils_isShadyRoot(root)) {
      return;
    }

    const nodeData = shadyDataForNode(this.host);

    if (nodeData && nodeData.__childSlotCount > 0) {
      return root;
    }
  } // Renders the top most render pending shadowRoot in the distribution tree.
  // This is safe because when a distribution parent renders, all children render.


  _render() {
    // If this root is not pending, it needs no rendering work. Any pending
    // parent that needs to render wll cause this root to render.
    const root = this._renderPending && this._getPendingDistributionRoot();

    if (root) {
      root._renderSelf();
    }
  }

  _flushInitial() {
    if (!this._hasRendered && this._renderPending) {
      this._render();
    }
  }
  /** @override */


  _renderSelf() {
    // track rendering state.
    const wasRendering = isRendering;
    isRendering = true;
    this._renderPending = false;

    if (this._slotList) {
      this._distribute();

      this._compose();
    } // NOTE: optimization flag, only process parsed children
    // if optimization flag is not set.
    // on initial render remove any undistributed children.


    if (!settings['preferPerformance'] && !this._hasRendered) {
      for (let n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
        const data = shadyDataForNode(n);

        if (n[NATIVE_PREFIX + 'parentNode'] === this.host && (n.localName === 'slot' || !data.assignedSlot)) {
          this.host[NATIVE_PREFIX + 'removeChild'](n);
        }
      }
    }

    this._hasRendered = true;
    isRendering = wasRendering;

    if (rootRendered) {
      rootRendered();
    }
  }

  _distribute() {
    this._validateSlots(); // capture # of previously assigned nodes to help determine if dirty.


    for (let i = 0, slot; i < this._slotList.length; i++) {
      slot = this._slotList[i];

      this._clearSlotAssignedNodes(slot);
    } // distribute host children.


    for (let n = this.host[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
      this._distributeNodeToSlot(n);
    } // fallback content, slotchange, and dirty roots


    for (let i = 0; i < this._slotList.length; i++) {
      const slot = this._slotList[i];
      const slotData = shadyDataForNode(slot); // distribute fallback content

      if (!slotData.assignedNodes.length) {
        for (let n = slot[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
          this._distributeNodeToSlot(n, slot);
        }
      }

      const slotParentData = shadyDataForNode(slot[SHADY_PREFIX + 'parentNode']);
      const slotParentRoot = slotParentData && slotParentData.root;

      if (slotParentRoot && (slotParentRoot._hasInsertionPoint() || slotParentRoot._renderPending)) {
        slotParentRoot._renderSelf();
      }

      this._addAssignedToFlattenedNodes(slotData.flattenedNodes, slotData.assignedNodes);

      let prevAssignedNodes = slotData._previouslyAssignedNodes;

      if (prevAssignedNodes) {
        for (let i = 0; i < prevAssignedNodes.length; i++) {
          shadyDataForNode(prevAssignedNodes[i])._prevAssignedSlot = null;
        }

        slotData._previouslyAssignedNodes = null; // dirty if previously less assigned nodes than previously assigned.

        if (prevAssignedNodes.length > slotData.assignedNodes.length) {
          slotData.dirty = true;
        }
      }
      /* Note: A slot is marked dirty whenever a node is newly assigned to it
      or a node is assigned to a different slot (done in `_distributeNodeToSlot`)
      or if the number of nodes assigned to the slot has decreased (done above);
      */


      if (slotData.dirty) {
        slotData.dirty = false;

        this._fireSlotChange(slot);
      }
    }
  }
  /**
   * Distributes given `node` to the appropriate slot based on its `slot`
   * attribute. If `forcedSlot` is given, then the node is distributed to the
   * `forcedSlot`.
   * Note: slot to which the node is assigned will be marked dirty for firing
   * `slotchange`.
   * @param {Node} node
   * @param {Node=} forcedSlot
   *
   */


  _distributeNodeToSlot(node, forcedSlot) {
    const nodeData = ensureShadyDataForNode(node);
    let oldSlot = nodeData._prevAssignedSlot;
    nodeData._prevAssignedSlot = null;
    let slot = forcedSlot;

    if (!slot) {
      let name = node[SHADY_PREFIX + 'slot'] || CATCHALL_NAME;
      const list = this._slotMap[name];
      slot = list && list[0];
    }

    if (slot) {
      const slotData = ensureShadyDataForNode(slot);
      slotData.assignedNodes.push(node);
      nodeData.assignedSlot = slot;
    } else {
      nodeData.assignedSlot = undefined;
    }

    if (oldSlot !== nodeData.assignedSlot) {
      if (nodeData.assignedSlot) {
        ensureShadyDataForNode(nodeData.assignedSlot).dirty = true;
      }
    }
  }
  /**
   * Clears the assignedNodes tracking data for a given `slot`. Note, the current
   * assigned node data is tracked (via _previouslyAssignedNodes and
   * _prevAssignedSlot) to see if `slotchange` should fire. This data may be out
   *  of date at this time because the assigned nodes may have already been
   * distributed to another root. This is ok since this data is only used to
   * track changes.
   * @param {HTMLSlotElement} slot
   */


  _clearSlotAssignedNodes(slot) {
    const slotData = shadyDataForNode(slot);
    let n$ = slotData.assignedNodes;
    slotData.assignedNodes = [];
    slotData.flattenedNodes = [];
    slotData._previouslyAssignedNodes = n$;

    if (n$) {
      for (let i = 0; i < n$.length; i++) {
        let n = shadyDataForNode(n$[i]);
        n._prevAssignedSlot = n.assignedSlot; // only clear if it was previously set to this slot;
        // this helps ensure that if the node has otherwise been distributed
        // ignore it.

        if (n.assignedSlot === slot) {
          n.assignedSlot = null;
        }
      }
    }
  }

  _addAssignedToFlattenedNodes(flattened, assigned) {
    for (let i = 0, n; i < assigned.length && (n = assigned[i]); i++) {
      if (n.localName == 'slot') {
        const nestedAssigned = shadyDataForNode(n).assignedNodes;

        if (nestedAssigned && nestedAssigned.length) {
          this._addAssignedToFlattenedNodes(flattened, nestedAssigned);
        }
      } else {
        flattened.push(assigned[i]);
      }
    }
  }

  _fireSlotChange(slot) {
    // NOTE: cannot bubble correctly here so not setting bubbles: true
    // Safari tech preview does not bubble but chrome does
    // Spec says it bubbles (https://dom.spec.whatwg.org/#mutation-observers)
    slot[NATIVE_PREFIX + 'dispatchEvent'](new Event('slotchange'));
    const slotData = shadyDataForNode(slot);

    if (slotData.assignedSlot) {
      this._fireSlotChange(slotData.assignedSlot);
    }
  } // Reify dom such that it is at its correct rendering position
  // based on logical distribution.
  // NOTE: here we only compose parents of <slot> elements and not the
  // shadowRoot into the host. The latter is performend via a fast path
  // in the `logical-mutation`.insertBefore.


  _compose() {
    const slots = this._slotList;
    let composeList = [];

    for (let i = 0; i < slots.length; i++) {
      const parent = slots[i][SHADY_PREFIX + 'parentNode'];
      /* compose node only if:
        (1) parent does not have a shadowRoot since shadowRoot has already
        composed into the host
        (2) we're not already composing it
        [consider (n^2) but rare better than Set]
      */

      const parentData = shadyDataForNode(parent);

      if (!(parentData && parentData.root) && composeList.indexOf(parent) < 0) {
        composeList.push(parent);
      }
    }

    for (let i = 0; i < composeList.length; i++) {
      const node = composeList[i];
      const targetNode = node === this ? this.host : node;

      this._updateChildNodes(targetNode, this._composeNode(node));
    }
  } // Returns the list of nodes which should be rendered inside `node`.


  _composeNode(node) {
    let children = [];

    for (let n = node[SHADY_PREFIX + 'firstChild']; n; n = n[SHADY_PREFIX + 'nextSibling']) {
      // Note: if we see a slot here, the nodes are guaranteed to need to be
      // composed here. This is because if there is redistribution, it has
      // already been handled by this point.
      if (this._isInsertionPoint(n)) {
        let flattenedNodes = shadyDataForNode(n).flattenedNodes;

        for (let j = 0; j < flattenedNodes.length; j++) {
          let distributedNode = flattenedNodes[j];
          children.push(distributedNode);
        }
      } else {
        children.push(n);
      }
    }

    return children;
  }

  _isInsertionPoint(node) {
    return node.localName == 'slot';
  } // Ensures that the rendered node list inside `container` is `children`.


  _updateChildNodes(container, children) {
    let composed = nativeChildNodesArray(container);
    let splices = calculateSplices(children, composed); // process removals

    for (let i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {
      for (let j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {
        // check if the node is still where we expect it is before trying
        // to remove it; this can happen if we move a node and
        // then schedule its previous host for distribution resulting in
        // the node being removed here.
        if (n[NATIVE_PREFIX + 'parentNode'] === container) {
          container[NATIVE_PREFIX + 'removeChild'](n);
        } // TODO(sorvell): avoid the need for splicing here.


        composed.splice(s.index + d, 1);
      }

      d -= s.addedCount;
    } // process adds


    for (let i = 0, s, next; i < splices.length && (s = splices[i]); i++) {
      //eslint-disable-line no-redeclare
      next = composed[s.index];

      for (let j = s.index, n; j < s.index + s.addedCount; j++) {
        n = children[j];
        container[NATIVE_PREFIX + 'insertBefore'](n, next);
        composed.splice(j, 0, n);
      }
    }
  }

  _ensureSlotData() {
    this._pendingSlots = this._pendingSlots || [];
    this._slotList = this._slotList || [];
    this._slotMap = this._slotMap || {};
  }

  _addSlots(slots) {
    this._ensureSlotData();

    this._pendingSlots.push(...slots);
  }

  _validateSlots() {
    if (this._pendingSlots && this._pendingSlots.length) {
      this._mapSlots(this._pendingSlots);

      this._pendingSlots = [];
    }
  }
  /**
   * Adds the given slots. Slots are maintained in an dom-ordered list.
   * In addition a map of name to slot is updated.
   */


  _mapSlots(slots) {
    let slotNamesToSort;

    for (let i = 0; i < slots.length; i++) {
      const slot = slots[i]; // ensure insertionPoints's and their parents have logical dom info.
      // save logical tree info
      // a. for shadyRoot
      // b. for insertion points (fallback)
      // c. for parents of insertion points

      recordChildNodes(slot);
      const slotParent = slot[SHADY_PREFIX + 'parentNode'];
      recordChildNodes(slotParent);
      const slotParentData = shadyDataForNode(slotParent);
      slotParentData.__childSlotCount = (slotParentData.__childSlotCount || 0) + 1;

      let name = this._nameForSlot(slot);

      if (this._slotMap[name]) {
        slotNamesToSort = slotNamesToSort || {};
        slotNamesToSort[name] = true;

        this._slotMap[name].push(slot);
      } else {
        this._slotMap[name] = [slot];
      }

      this._slotList.push(slot);
    }

    if (slotNamesToSort) {
      for (let n in slotNamesToSort) {
        this._slotMap[n] = this._sortSlots(this._slotMap[n]);
      }
    }
  }

  _nameForSlot(slot) {
    const name = slot['name'] || slot.getAttribute('name') || CATCHALL_NAME;
    slot.__slotName = name;
    return name;
  }
  /**
   * Slots are kept in an ordered list. Slots with the same name
   * are sorted here by tree order.
   */


  _sortSlots(slots) {
    // NOTE: Cannot use `compareDocumentPosition` because it's not polyfilled,
    // but the code here could be used to polyfill the preceeding/following info
    // in `compareDocumentPosition`.
    return slots.sort((a, b) => {
      let listA = ancestorList(a);
      let listB = ancestorList(b);

      for (var i = 0; i < listA.length; i++) {
        let nA = listA[i];
        let nB = listB[i];

        if (nA !== nB) {
          let c$ = childNodesArray(nA[SHADY_PREFIX + 'parentNode']);
          return c$.indexOf(nA) - c$.indexOf(nB);
        }
      }
    });
  }
  /**
   * Removes from tracked slot data any slots contained within `container` and
   * then updates the tracked data (_slotList and _slotMap).
   * Any removed slots also have their `assignedNodes` removed from comopsed dom.
   */


  _removeContainedSlots(container) {
    if (!this._slotList) {
      return;
    }

    this._validateSlots();

    let didRemove;
    const map = this._slotMap;

    for (let n in map) {
      const slots = map[n];

      for (let i = 0; i < slots.length; i++) {
        const slot = slots[i];

        if (contains(container, slot)) {
          slots.splice(i, 1);

          const x = this._slotList.indexOf(slot);

          if (x >= 0) {
            this._slotList.splice(x, 1);

            const slotParentData = shadyDataForNode(slot[SHADY_PREFIX + 'parentNode']);

            if (slotParentData && slotParentData.__childSlotCount) {
              slotParentData.__childSlotCount--;
            }
          }

          i--;

          this._removeFlattenedNodes(slot);

          didRemove = true;
        }
      }
    }

    return didRemove;
  }

  _updateSlotName(slot) {
    if (!this._slotList) {
      return;
    } // make sure slotMap is initialized with this slot


    this._validateSlots();

    const oldName = slot.__slotName;

    const name = this._nameForSlot(slot);

    if (name === oldName) {
      return;
    } // remove from existing tracking


    let slots = this._slotMap[oldName];
    const i = slots.indexOf(slot);

    if (i >= 0) {
      slots.splice(i, 1);
    } // add to new location and sort if nedessary


    let list = this._slotMap[name] || (this._slotMap[name] = []);
    list.push(slot);

    if (list.length > 1) {
      this._slotMap[name] = this._sortSlots(list);
    }
  }

  _removeFlattenedNodes(slot) {
    const data = shadyDataForNode(slot);
    let n$ = data.flattenedNodes;

    if (n$) {
      for (let i = 0; i < n$.length; i++) {
        let node = n$[i];
        let parent = node[NATIVE_PREFIX + 'parentNode'];

        if (parent) {
          parent[NATIVE_PREFIX + 'removeChild'](node);
        }
      }
    }

    data.flattenedNodes = [];
    data.assignedNodes = [];
  }

  _hasInsertionPoint() {
    this._validateSlots();

    return Boolean(this._slotList && this._slotList.length);
  }

}

patchShadyRoot(attach_shadow_ShadyRoot.prototype);

/**
  Implements a pared down version of ShadowDOM's scoping, which is easy to
  polyfill across browsers.
*/

const attachShadow = (host, options) => {
  if (!host) {
    throw new Error('Must provide a host.');
  }

  if (!options) {
    throw new Error('Not enough arguments.');
  }

  let root; // Optimization for booting up a shadowRoot from a fragment rather than
  // creating one.

  if (options['shadyUpgradeFragment'] && canUpgrade()) {
    root = options['shadyUpgradeFragment'];
    root.__proto__ = ShadowRoot.prototype;

    root._init(host, options);

    recordChildNodes(root, root); // Note: qsa is native when used with noPatch.

    /** @type {?NodeList<Element>} */

    const slotsAdded = root['__noInsertionPoint'] ? null : root.querySelectorAll('slot'); // Reset scoping information so normal scoing rules apply after this.

    root['__noInsertionPoint'] = undefined; // if a slot is added, must render containing root.

    if (slotsAdded && slotsAdded.length) {
      root._addSlots(slotsAdded);

      root._asyncRender();
    }
    /** @type {ShadowRoot} */


    root.host[NATIVE_PREFIX + 'appendChild'](root);
  } else {
    root = new attach_shadow_ShadyRoot(ShadyRootConstructionToken, host, options);
  }

  return root;
}; // Mitigate connect/disconnect spam by wrapping custom element classes.

if (window['customElements'] && settings.inUse && !settings['preferPerformance']) {
  // process connect/disconnect after roots have rendered to avoid
  // issues with reaction stack.
  let connectMap = new Map();

  rootRendered = function () {
    // allow elements to connect
    // save map state (without needing polyfills on IE11)
    const r = [];
    connectMap.forEach((v, k) => {
      r.push([k, v]);
    });
    connectMap.clear();

    for (let i = 0; i < r.length; i++) {
      const e = r[i][0],
            value = r[i][1];

      if (value) {
        e['__shadydom_connectedCallback']();
      } else {
        e['__shadydom_disconnectedCallback']();
      }
    }
  }; // Document is in loading state and flag is set (deferConnectionCallbacks)
  // so process connection stack when `readystatechange` fires.


  if (isRendering) {
    document.addEventListener('readystatechange', () => {
      isRendering = false;
      rootRendered();
    }, {
      once: true
    });
  }
  /*
   * (1) elements can only be connected/disconnected if they are in the expected
   * state.
   * (2) never run connect/disconnect during rendering to avoid reaction stack issues.
   */


  const ManageConnect = (base, connected, disconnected) => {
    let counter = 0;
    const connectFlag = "__isConnected".concat(counter++);

    if (connected || disconnected) {
      /** @this {!HTMLElement} */
      base.prototype.connectedCallback = base.prototype['__shadydom_connectedCallback'] = function () {
        // if rendering defer connected
        // otherwise connect only if we haven't already
        if (isRendering) {
          connectMap.set(this, true);
        } else if (!this[connectFlag]) {
          this[connectFlag] = true;

          if (connected) {
            connected.call(this);
          }
        }
      };
      /** @this {!HTMLElement} */


      base.prototype.disconnectedCallback = base.prototype['__shadydom_disconnectedCallback'] = function () {
        // if rendering, cancel a pending connection and queue disconnect,
        // otherwise disconnect only if a connection has been allowed
        if (isRendering) {
          // This is necessary only because calling removeChild
          // on a node that requires distribution leaves it in the DOM tree
          // until distribution.
          // NOTE: remember this is checking the patched isConnected to determine
          // if the node is in the logical tree.
          if (!this.isConnected) {
            connectMap.set(this, false);
          }
        } else if (this[connectFlag]) {
          this[connectFlag] = false;

          if (disconnected) {
            disconnected.call(this);
          }
        }
      };
    }

    return base;
  };

  const originalDefine = window['customElements']['define'];

  const define = function (name, constructor) {
    const connected = constructor.prototype.connectedCallback;
    const disconnected = constructor.prototype.disconnectedCallback;
    originalDefine.call(window['customElements'], name, ManageConnect(constructor, connected, disconnected)); // unpatch connected/disconnected on class; custom elements tears this off
    // so the patch is maintained, but if the user calls these methods for
    // e.g. testing, they will be as expected.

    constructor.prototype.connectedCallback = connected;
    constructor.prototype.disconnectedCallback = disconnected;
  }; // Note, it would be better to only patch the CustomElementRegistry.prototype,
  // but ShadyCSS patches define directly.


  window.customElements.define = define; // Still patch the registry directly since Safari 10 loses the patch
  // unless this is done.

  Object.defineProperty(window['CustomElementRegistry'].prototype, 'define', {
    value: define,
    configurable: true
  });
}
/** @return {!ShadyRoot|undefined} */


const ownerShadyRootForNode = node => {
  let root = node[SHADY_PREFIX + 'getRootNode']();

  if (utils_isShadyRoot(root)) {
    return root;
  }
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/wrapper.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


/** @implements {IWrapper} */

class wrapper_Wrapper {
  /** @param {!Node} node */
  constructor(node) {
    this.node = node;
  } // node


  addEventListener(name, fn, options) {
    return this.node[SHADY_PREFIX + 'addEventListener'](name, fn, options);
  }

  removeEventListener(name, fn, options) {
    return this.node[SHADY_PREFIX + 'removeEventListener'](name, fn, options);
  }

  appendChild(node) {
    return this.node[SHADY_PREFIX + 'appendChild'](node);
  }

  insertBefore(node, ref_node) {
    return this.node[SHADY_PREFIX + 'insertBefore'](node, ref_node);
  }

  removeChild(node) {
    return this.node[SHADY_PREFIX + 'removeChild'](node);
  }

  replaceChild(node, ref_node) {
    return this.node[SHADY_PREFIX + 'replaceChild'](node, ref_node);
  }

  cloneNode(deep) {
    return this.node[SHADY_PREFIX + 'cloneNode'](deep);
  }

  getRootNode(options) {
    return this.node[SHADY_PREFIX + 'getRootNode'](options);
  }

  contains(node) {
    return this.node[SHADY_PREFIX + 'contains'](node);
  }

  dispatchEvent(event) {
    return this.node[SHADY_PREFIX + 'dispatchEvent'](event);
  } // element


  setAttribute(name, value) {
    this.node[SHADY_PREFIX + 'setAttribute'](name, value);
  } // NOTE: not needed, just here for balance


  getAttribute(name) {
    return this.node[NATIVE_PREFIX + 'getAttribute'](name);
  } // NOTE: not needed, just here for balance


  hasAttribute(name) {
    return this.node[NATIVE_PREFIX + 'hasAttribute'](name);
  }

  removeAttribute(name) {
    this.node[SHADY_PREFIX + 'removeAttribute'](name);
  }

  attachShadow(options) {
    return this.node[SHADY_PREFIX + 'attachShadow'](options);
  }
  /** @return {!Node|undefined} */


  get activeElement() {
    if (utils_isShadyRoot(this.node) || this.node.nodeType === Node.DOCUMENT_NODE) {
      const e = this.node[SHADY_PREFIX + 'activeElement'];
      return e;
    }
  }
  /**
   * Installed for compatibility with browsers (older Chrome/Safari) that do
   * not have a configurable `activeElement` accessor. Enables noPatch and
   * patch mode both to consistently use ShadyDOM.wrap(document)._activeElement.
   * @override
   * @return {!Node|undefined}
   */


  get _activeElement() {
    return this.activeElement;
  } // NOTE: not needed, just here for balance

  /** @override */


  focus() {
    this.node[NATIVE_PREFIX + 'focus']();
  }

  blur() {
    this.node[SHADY_PREFIX + 'blur']();
  } // document


  importNode(node, deep) {
    if (this.node.nodeType === Node.DOCUMENT_NODE) {
      return this.node[SHADY_PREFIX + 'importNode'](node, deep);
    }
  }

  getElementById(id) {
    if (this.node.nodeType === Node.DOCUMENT_NODE) {
      return this.node[SHADY_PREFIX + 'getElementById'](id);
    }
  } // query


  querySelector(selector) {
    return this.node[SHADY_PREFIX + 'querySelector'](selector);
  }

  querySelectorAll(selector, useNative) {
    return this.node[SHADY_PREFIX + 'querySelectorAll'](selector, useNative);
  } // slot


  assignedNodes(options) {
    if (this.node.localName === 'slot') {
      return this.node[SHADY_PREFIX + 'assignedNodes'](options);
    }
  }

  get host() {
    if (utils_isShadyRoot(this.node)) {
      return (
        /** @type {!ShadowRoot} */
        this.node.host
      );
    }
  }

  get parentNode() {
    return this.node[SHADY_PREFIX + 'parentNode'];
  }

  get firstChild() {
    return this.node[SHADY_PREFIX + 'firstChild'];
  }

  get lastChild() {
    return this.node[SHADY_PREFIX + 'lastChild'];
  }

  get nextSibling() {
    return this.node[SHADY_PREFIX + 'nextSibling'];
  }

  get previousSibling() {
    return this.node[SHADY_PREFIX + 'previousSibling'];
  }

  get childNodes() {
    return this.node[SHADY_PREFIX + 'childNodes'];
  }

  get parentElement() {
    return this.node[SHADY_PREFIX + 'parentElement'];
  }

  get firstElementChild() {
    return this.node[SHADY_PREFIX + 'firstElementChild'];
  }

  get lastElementChild() {
    return this.node[SHADY_PREFIX + 'lastElementChild'];
  }

  get nextElementSibling() {
    return this.node[SHADY_PREFIX + 'nextElementSibling'];
  }

  get previousElementSibling() {
    return this.node[SHADY_PREFIX + 'previousElementSibling'];
  }

  get children() {
    return this.node[SHADY_PREFIX + 'children'];
  }

  get childElementCount() {
    return this.node[SHADY_PREFIX + 'childElementCount'];
  }

  get shadowRoot() {
    return this.node[SHADY_PREFIX + 'shadowRoot'];
  }

  get assignedSlot() {
    return this.node[SHADY_PREFIX + 'assignedSlot'];
  }

  get isConnected() {
    return this.node[SHADY_PREFIX + 'isConnected'];
  }

  get innerHTML() {
    return this.node[SHADY_PREFIX + 'innerHTML'];
  }

  set innerHTML(value) {
    this.node[SHADY_PREFIX + 'innerHTML'] = value;
  }

  get textContent() {
    return this.node[SHADY_PREFIX + 'textContent'];
  }

  set textContent(value) {
    this.node[SHADY_PREFIX + 'textContent'] = value;
  }

  get slot() {
    return this.node[SHADY_PREFIX + 'slot'];
  }

  set slot(value) {
    this.node[SHADY_PREFIX + 'slot'] = value;
  }

  get className() {
    return this.node[SHADY_PREFIX + 'className'];
  }

  set className(value) {
    return this.node[SHADY_PREFIX + 'className'] = value;
  }

}

eventPropertyNames.forEach(name => {
  Object.defineProperty(wrapper_Wrapper.prototype, name, {
    /** @this {Wrapper} */
    get() {
      return this.node[SHADY_PREFIX + name];
    },

    /** @this {Wrapper} */
    set(value) {
      this.node[SHADY_PREFIX + name] = value;
    },

    configurable: true
  });
});

const wrapperMap = new WeakMap();
function wrap(obj) {
  if (utils_isShadyRoot(obj) || obj instanceof wrapper_Wrapper) {
    return obj;
  }

  let wrapper = wrapperMap.get(obj);

  if (!wrapper) {
    wrapper = new wrapper_Wrapper(obj);
    wrapperMap.set(obj, wrapper);
  }

  return wrapper;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/EventTarget.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



const EventTargetPatches = getOwnPropertyDescriptors({
  /** @this {Node} */
  dispatchEvent(event) {
    flush();
    return this[NATIVE_PREFIX + 'dispatchEvent'](event);
  },

  addEventListener: addEventListener,
  removeEventListener: removeEventListener
});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slotable.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const SlotablePatches = getOwnPropertyDescriptors({
  /** @this {Node} */
  get assignedSlot() {
    // Force any parent's shadowRoot to flush so that distribution occurs
    // and this node has an assignedSlot.
    const parent = this[SHADY_PREFIX + 'parentNode'];
    const ownerRoot = parent && parent[SHADY_PREFIX + 'shadowRoot'];

    if (ownerRoot) {
      ownerRoot._render();
    }

    const nodeData = shadyDataForNode(this);
    return nodeData && nodeData.assignedSlot || null;
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Element.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




const Element_doc = window.document;
/**
 * Should be called whenever an attribute changes. If the `slot` attribute
 * changes, provokes rendering if necessary. If a `<slot>` element's `name`
 * attribute changes, updates the root's slot map and renders.
 * @param {Node} node
 * @param {string} name
 */

function distributeAttributeChange(node, name) {
  if (name === 'slot') {
    const parent = node[SHADY_PREFIX + 'parentNode'];

    if (hasShadowRootWithSlot(parent)) {
      shadyDataForNode(parent).root._asyncRender();
    }
  } else if (node.localName === 'slot' && name === 'name') {
    let root = ownerShadyRootForNode(node);

    if (root) {
      root._updateSlotName(node);

      root._asyncRender();
    }
  }
}

const ElementPatches = getOwnPropertyDescriptors({
  /** @this {Element} */
  get previousElementSibling() {
    const nodeData = shadyDataForNode(this);

    if (nodeData && nodeData.previousSibling !== undefined) {
      let n = this[SHADY_PREFIX + 'previousSibling'];

      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n[SHADY_PREFIX + 'previousSibling'];
      }

      return n;
    } else {
      return this[NATIVE_PREFIX + 'previousElementSibling'];
    }
  },

  /** @this {Element} */
  get nextElementSibling() {
    const nodeData = shadyDataForNode(this);

    if (nodeData && nodeData.nextSibling !== undefined) {
      let n = this[SHADY_PREFIX + 'nextSibling'];

      while (n && n.nodeType !== Node.ELEMENT_NODE) {
        n = n[SHADY_PREFIX + 'nextSibling'];
      }

      return n;
    } else {
      return this[NATIVE_PREFIX + 'nextElementSibling'];
    }
  },

  /** @this {Element} */
  get slot() {
    return this.getAttribute('slot');
  },

  /** @this {Element} */
  set slot(value) {
    this[SHADY_PREFIX + 'setAttribute']('slot', value);
  },

  // Note: Can be patched on element prototype on all browsers.
  // Must be patched on instance on browsers that support native Shadow DOM
  // but do not have builtin accessors (old Chrome).

  /** @this {Element} */
  get shadowRoot() {
    const nodeData = shadyDataForNode(this);
    return nodeData && nodeData.publicRoot || null;
  },

  /** @this {Element} */
  get className() {
    return this.getAttribute('class') || '';
  },

  /**
   * @this {Element}
   * @param {string} value
   */
  set className(value) {
    this[SHADY_PREFIX + 'setAttribute']('class', value);
  },

  /**
   * @this {Element}
   * @param {string} attr
   * @param {string} value
   */
  setAttribute(attr, value) {
    if (this.ownerDocument !== Element_doc) {
      this[NATIVE_PREFIX + 'setAttribute'](attr, value);
    } else if (!scopeClassAttribute(this, attr, value)) {
      this[NATIVE_PREFIX + 'setAttribute'](attr, value);
      distributeAttributeChange(this, attr);
    }
  },

  /**
   * @this {Element}
   * @param {string} attr
   */
  removeAttribute(attr) {
    this[NATIVE_PREFIX + 'removeAttribute'](attr);
    distributeAttributeChange(this, attr);
  },

  /**
   * @this {Element}
   * @param {!{mode: string}} options
   */
  attachShadow(options) {
    return attachShadow(this, options);
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/HTMLElement.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



const HTMLElementPatches = getOwnPropertyDescriptors({
  /** @this {HTMLElement} */
  blur() {
    const nodeData = shadyDataForNode(this);
    let root = nodeData && nodeData.root;
    let shadowActive = root && root.activeElement;

    if (shadowActive) {
      shadowActive[SHADY_PREFIX + 'blur']();
    } else {
      this[NATIVE_PREFIX + 'blur']();
    }
  }

});
eventPropertyNames.forEach(property => {
  HTMLElementPatches[property] = {
    /** @this {HTMLElement} */
    set: function (fn) {
      const shadyData = ensureShadyDataForNode(this);
      const eventName = property.substring(2);

      if (!shadyData.__onCallbackListeners) {
        shadyData.__onCallbackListeners = {};
      }

      shadyData.__onCallbackListeners[property] && this.removeEventListener(eventName, shadyData.__onCallbackListeners[property]);
      this[SHADY_PREFIX + 'addEventListener'](eventName, fn);
      shadyData.__onCallbackListeners[property] = fn;
    },

    /** @this {HTMLElement} */
    get() {
      const shadyData = shadyDataForNode(this);
      return shadyData && shadyData.__onCallbackListeners && shadyData.__onCallbackListeners[property];
    },

    configurable: true
  };
});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Slot.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



const SlotPatches = getOwnPropertyDescriptors({
  /**
   * @this {HTMLSlotElement}
   * @param {Object=} options
   */
  assignedNodes(options) {
    if (this.localName === 'slot') {
      // Force any containing shadowRoot to flush so that distribution occurs
      // and this node has assignedNodes.
      const root = this[SHADY_PREFIX + 'getRootNode']();

      if (root && utils_isShadyRoot(root)) {
        root._render();
      }

      const nodeData = shadyDataForNode(this);
      return nodeData ? (options && options.flatten ? nodeData.flattenedNodes : nodeData.assignedNodes) || [] : [];
    }
  },

  /**
   * @this {HTMLSlotElement}
   * @param {string} type
   * @param {Function} fn
   * @param {Object|boolean=} optionsOrCapture
   */
  addEventListener(type, fn, optionsOrCapture) {
    // NOTE, check if this is a `slot` because these patches are installed on
    // Element where browsers don't have `<slot>`
    if (this.localName !== 'slot' || type === 'slotchange') {
      addEventListener.call(this, type, fn, optionsOrCapture);
    } else {
      if (typeof optionsOrCapture !== 'object') {
        optionsOrCapture = {
          capture: Boolean(optionsOrCapture)
        };
      }

      const parent = this[SHADY_PREFIX + 'parentNode'];

      if (!parent) {
        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');
      }

      optionsOrCapture.__shadyTarget = this;
      parent[SHADY_PREFIX + 'addEventListener'](type, fn, optionsOrCapture);
    }
  },

  /**
   * @this {HTMLSlotElement}
   * @param {string} type
   * @param {Function} fn
   * @param {Object|boolean=} optionsOrCapture
   */
  removeEventListener(type, fn, optionsOrCapture) {
    // NOTE, check if this is a `slot` because these patches are installed on
    // Element where browsers don't have `<slot>`
    if (this.localName !== 'slot' || type === 'slotchange') {
      removeEventListener.call(this, type, fn, optionsOrCapture);
    } else {
      if (typeof optionsOrCapture !== 'object') {
        optionsOrCapture = {
          capture: Boolean(optionsOrCapture)
        };
      }

      const parent = this[SHADY_PREFIX + 'parentNode'];

      if (!parent) {
        throw new Error('ShadyDOM cannot attach event to slot unless it has a `parentNode`');
      }

      optionsOrCapture.__shadyTarget = this;
      parent[SHADY_PREFIX + 'removeEventListener'](type, fn, optionsOrCapture);
    }
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Document.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

const Document_doc = window.document;
const DocumentPatches = getOwnPropertyDescriptors({
  // note: Though not technically correct, we fast path `importNode`
  // when called on a node not owned by the main document.
  // This allows, for example, elements that cannot
  // contain custom elements and are therefore not likely to contain shadowRoots
  // to cloned natively. This is a fairly significant performance win.

  /**
   * @this {Document}
   * @param {Node} node
   * @param {boolean} deep
   */
  importNode(node, deep) {
    // A template element normally has no children with shadowRoots, so make
    // sure we always make a deep copy to correctly construct the template.content
    if (node.ownerDocument !== Document_doc || node.localName === 'template') {
      return this[NATIVE_PREFIX + 'importNode'](node, deep);
    }

    let n = this[NATIVE_PREFIX + 'importNode'](node, false);

    if (deep) {
      for (let c = node[SHADY_PREFIX + 'firstChild'], nc; c; c = c[SHADY_PREFIX + 'nextSibling']) {
        nc = this[SHADY_PREFIX + 'importNode'](c, true);
        n[SHADY_PREFIX + 'appendChild'](nc);
      }
    }

    return n;
  }

});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patches/Window.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const WindowPatches = getOwnPropertyDescriptors({
  // NOTE: ensure these methods are bound to `window` so that `this` is correct
  // when called directly from global context without a receiver; e.g.
  // `addEventListener(...)`.
  addEventListener: addEventListener.bind(window),
  removeEventListener: removeEventListener.bind(window)
});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/patch-prototypes.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/












 // Some browsers (IE/Edge) have non-standard HTMLElement accessors.

const NonStandardHTMLElement = {};

if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'parentElement')) {
  NonStandardHTMLElement.parentElement = NodePatches.parentElement;
}

if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'contains')) {
  NonStandardHTMLElement.contains = NodePatches.contains;
}

if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'children')) {
  NonStandardHTMLElement.children = ParentNodePatches.children;
}

if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'innerHTML')) {
  NonStandardHTMLElement.innerHTML = ElementOrShadowRootPatches.innerHTML;
}

if (Object.getOwnPropertyDescriptor(HTMLElement.prototype, 'className')) {
  NonStandardHTMLElement.className = ElementPatches.className;
} // Avoid patching `innerHTML` if it does not exist on Element (IE)
// and we can patch accessors (hasDescriptors).


const ElementShouldHaveInnerHTML = !settings.hasDescriptors || 'innerHTML' in Element.prototype; // setup patching

const patchMap = {
  EventTarget: [EventTargetPatches],
  Node: [NodePatches, !window.EventTarget ? EventTargetPatches : null],
  Text: [SlotablePatches],
  Element: [ElementPatches, ParentNodePatches, SlotablePatches, ElementShouldHaveInnerHTML ? ElementOrShadowRootPatches : null, !window.HTMLSlotElement ? SlotPatches : null],
  HTMLElement: [HTMLElementPatches, NonStandardHTMLElement],
  HTMLSlotElement: [SlotPatches],
  DocumentFragment: [ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches],
  Document: [DocumentPatches, ParentNodeDocumentOrFragmentPatches, DocumentOrFragmentPatches, DocumentOrShadowRootPatches],
  Window: [WindowPatches]
};

const getPatchPrototype = name => window[name] && window[name].prototype; // Note, must avoid patching accessors on prototypes when descriptors are not correct
// because the CustomElements polyfill checks if these exist before patching instances.
// CustomElements polyfill *only* cares about these accessors.


const disallowedNativePatches = settings.hasDescriptors ? null : ['innerHTML', 'textContent'];
/** @param {string=} prefix */

const applyPatches = prefix => {
  const disallowed = prefix ? null : disallowedNativePatches;

  for (let p in patchMap) {
    const proto = getPatchPrototype(p);
    patchMap[p].forEach(patch => proto && patch && patchProperties(proto, patch, prefix, disallowed));
  }
};
const addShadyPrefixedProperties = () => {
  // perform shady patches
  applyPatches(SHADY_PREFIX); // install `_activeElement` because some browsers (older Chrome/Safari) do not have
  // a 'configurable' `activeElement` accesssor.

  const descriptor = DocumentOrShadowRootPatches.activeElement;
  Object.defineProperty(document, '_activeElement', descriptor); // On Window, we're patching `addEventListener` which is a weird auto-bound
  // property that is not directly on the Window prototype.

  patchProperties(Window.prototype, WindowPatches, SHADY_PREFIX);
};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadydom/src/shadydom.js
/**
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * Patches elements that interacts with ShadyDOM
 * such that tree traversal and mutation apis act like they would under
 * ShadowDOM.
 *
 * This import enables seemless interaction with ShadyDOM powered
 * custom elements, enabling better interoperation with 3rd party code,
 * libraries, and frameworks that use DOM tree manipulation apis.
 */










if (settings.inUse) {
  let ShadyDOM = {
    // TODO(sorvell): remove when Polymer does not depend on this.
    'inUse': settings.inUse,
    // NOTE: old browsers without prototype accessors (very old Chrome
    // and Safari) need manually patched accessors to properly set
    // `innerHTML` and `textContent` when an element is:
    // (1) inside a shadowRoot
    // (2) does not have special (slot) children itself
    // (3) and setting the property needs to provoke distribution (because
    // a nested slot is added/removed)
    'patch': node => {
      patchInsideElementAccessors(node);
      patchOutsideElementAccessors(node);
      return node;
    },
    'isShadyRoot': utils_isShadyRoot,
    'enqueue': enqueue,
    'flush': flush,
    'flushInitial': root => {
      root._flushInitial();
    },
    'settings': settings,
    'filterMutations': filterMutations,
    'observeChildren': observeChildren,
    'unobserveChildren': unobserveChildren,
    // Set to true to defer native custom elements connection until the
    // document has fully parsed. This enables custom elements that create
    // shadowRoots to be defined while the document is loading. Elements
    // customized as they are created by the parser will successfully
    // render with this flag on.
    'deferConnectionCallbacks': settings['deferConnectionCallbacks'],
    // Set to true to speed up the polyfill slightly at the cost of correctness
    // * does not patch querySelector/All on Document or DocumentFragment
    // * does not wrap connected/disconnected callbacks to de-dup these
    // when using native customElements
    // * does not wait to process children of elements with shadowRoots
    // meaning shadowRoots should not be created while an element is parsing
    // (e.g. if a custom element that creates a shadowRoot is defined before
    // a candidate element in the document below it.
    'preferPerformance': settings['preferPerformance'],
    // Integration point with ShadyCSS to disable styling MutationObserver,
    // as ShadyDOM will now handle dynamic scoping.
    'handlesDynamicScoping': true,
    'wrap': settings.noPatch ? wrap : n => n,
    'Wrapper': wrapper_Wrapper,
    'composedPath': patch_events_composedPath,
    // Set to true to avoid patching regular platform property names. When set,
    // Shadow DOM compatible behavior is only available when accessing DOM
    // API using `ShadyDOM.wrap`, e.g. `ShadyDOM.wrap(element).shadowRoot`.
    // This setting provides a small performance boost, but requires all DOM API
    // access that requires Shadow DOM behavior to be proxied via `ShadyDOM.wrap`.
    'noPatch': settings.noPatch,
    'nativeMethods': nativeMethods,
    'nativeTree': nativeTree
  };
  window['ShadyDOM'] = ShadyDOM; // Modifies native prototypes for Node, Element, etc. to
  // make native platform behavior available at prefixed names, e.g.
  // `utils.NATIVE_PREFIX + 'firstChild'` or `__shady_native_firstChild`.
  // This allows the standard names to be safely patched while retaining the
  // ability for native behavior to be used. This polyfill manipulates DOM
  // by using this saved native behavior.
  // Note, some browsers do not have proper element descriptors for
  // accessors; in this case, native behavior for these accessors is simulated
  // via a TreeWalker.

  addNativePrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to make ShadowDOM
  // behavior available at prefixed names, e.g.
  // `utils.SHADY_PREFIX + 'firstChild` or `__shady_firstChild`. This is done
  // so this polyfill can perform Shadow DOM style DOM manipulation.
  // Because patching normal platform property names is optional, these prefixed
  // names are used internally.

  addShadyPrefixedProperties(); // Modifies native prototypes for Node, Element, etc. to patch
  // regular platform property names to have Shadow DOM compatible API behavior.
  // This applies the utils.SHADY_PREFIX behavior to normal names. For example,
  // if `noPatch` is not set, then `el.__shady_firstChild` is equivalent to
  // `el.firstChild`.
  // NOTE, on older browsers (old Chrome/Safari) native accessors cannot be
  // patched on prototypes (e.g. Node.prototype.firstChild cannot be modified).
  // On these browsers, instance level patching is performed where needed; this
  // instance patching is only done when `noPatch` is *not* set.

  if (!settings.noPatch) {
    applyPatches(); // Patch click event behavior only if we're patching

    patchClick();
  } // For simplicity, patch events unconditionally.
  // Patches the event system to have Shadow DOM compatible behavior (e.g.
  // event retargeting). When `noPatch` is set, retargeting is only available
  // when adding event listeners and dispatching events via `ShadyDOM.wrap`
  // (e.g. `ShadyDOM.wrap(element).addEventListener(...)`).


  patchEvents();
  window.ShadowRoot =
  /** @type {function(new:ShadowRoot)} */
  attach_shadow_ShadyRoot;
}

/***/ }),

/***/ 46:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/css-parse.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/*
Extremely simple css parser. Intended to be not more than what we need
and definitely not necessarily correct =).
*/

/** @unrestricted */

class StyleNode {
  constructor() {
    /** @type {number} */
    this['start'] = 0;
    /** @type {number} */

    this['end'] = 0;
    /** @type {StyleNode} */

    this['previous'] = null;
    /** @type {StyleNode} */

    this['parent'] = null;
    /** @type {Array<StyleNode>} */

    this['rules'] = null;
    /** @type {string} */

    this['parsedCssText'] = '';
    /** @type {string} */

    this['cssText'] = '';
    /** @type {boolean} */

    this['atRule'] = false;
    /** @type {number} */

    this['type'] = 0;
    /** @type {string} */

    this['keyframesName'] = '';
    /** @type {string} */

    this['selector'] = '';
    /** @type {string} */

    this['parsedSelector'] = '';
  }

}

 // given a string of css, return a simple rule tree

/**
 * @param {string} text
 * @return {StyleNode}
 */

function parse(text) {
  text = clean(text);
  return parseCss(lex(text), text);
} // remove stuff we don't care about that may hinder parsing

/**
 * @param {string} cssText
 * @return {string}
 */

function clean(cssText) {
  return cssText.replace(RX.comments, '').replace(RX.port, '');
} // super simple {...} lexer that returns a node tree

/**
 * @param {string} text
 * @return {StyleNode}
 */


function lex(text) {
  let root = new StyleNode();
  root['start'] = 0;
  root['end'] = text.length;
  let n = root;

  for (let i = 0, l = text.length; i < l; i++) {
    if (text[i] === OPEN_BRACE) {
      if (!n['rules']) {
        n['rules'] = [];
      }

      let p = n;
      let previous = p['rules'][p['rules'].length - 1] || null;
      n = new StyleNode();
      n['start'] = i + 1;
      n['parent'] = p;
      n['previous'] = previous;
      p['rules'].push(n);
    } else if (text[i] === CLOSE_BRACE) {
      n['end'] = i + 1;
      n = n['parent'] || root;
    }
  }

  return root;
} // add selectors/cssText to node tree

/**
 * @param {StyleNode} node
 * @param {string} text
 * @return {StyleNode}
 */


function parseCss(node, text) {
  let t = text.substring(node['start'], node['end'] - 1);
  node['parsedCssText'] = node['cssText'] = t.trim();

  if (node['parent']) {
    let ss = node['previous'] ? node['previous']['end'] : node['parent']['start'];
    t = text.substring(ss, node['start'] - 1);
    t = _expandUnicodeEscapes(t);
    t = t.replace(RX.multipleSpaces, ' '); // TODO(sorvell): ad hoc; make selector include only after last ;
    // helps with mixin syntax

    t = t.substring(t.lastIndexOf(';') + 1);
    let s = node['parsedSelector'] = node['selector'] = t.trim();
    node['atRule'] = s.indexOf(AT_START) === 0; // note, support a subset of rule types...

    if (node['atRule']) {
      if (s.indexOf(MEDIA_START) === 0) {
        node['type'] = types.MEDIA_RULE;
      } else if (s.match(RX.keyframesRule)) {
        node['type'] = types.KEYFRAMES_RULE;
        node['keyframesName'] = node['selector'].split(RX.multipleSpaces).pop();
      }
    } else {
      if (s.indexOf(VAR_START) === 0) {
        node['type'] = types.MIXIN_RULE;
      } else {
        node['type'] = types.STYLE_RULE;
      }
    }
  }

  let r$ = node['rules'];

  if (r$) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      parseCss(r, text);
    }
  }

  return node;
}
/**
 * conversion of sort unicode escapes with spaces like `\33 ` (and longer) into
 * expanded form that doesn't require trailing space `\000033`
 * @param {string} s
 * @return {string}
 */


function _expandUnicodeEscapes(s) {
  return s.replace(/\\([0-9a-f]{1,6})\s/gi, function () {
    let code = arguments[1],
        repeat = 6 - code.length;

    while (repeat--) {
      code = '0' + code;
    }

    return '\\' + code;
  });
}
/**
 * stringify parsed css.
 * @param {StyleNode} node
 * @param {boolean=} preserveProperties
 * @param {string=} text
 * @return {string}
 */


function stringify(node, preserveProperties, text = '') {
  // calc rule cssText
  let cssText = '';

  if (node['cssText'] || node['rules']) {
    let r$ = node['rules'];

    if (r$ && !_hasMixinRules(r$)) {
      for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
        cssText = stringify(r, preserveProperties, cssText);
      }
    } else {
      cssText = preserveProperties ? node['cssText'] : removeCustomProps(node['cssText']);
      cssText = cssText.trim();

      if (cssText) {
        cssText = '  ' + cssText + '\n';
      }
    }
  } // emit rule if there is cssText


  if (cssText) {
    if (node['selector']) {
      text += node['selector'] + ' ' + OPEN_BRACE + '\n';
    }

    text += cssText;

    if (node['selector']) {
      text += CLOSE_BRACE + '\n\n';
    }
  }

  return text;
}
/**
 * @param {Array<StyleNode>} rules
 * @return {boolean}
 */

function _hasMixinRules(rules) {
  let r = rules[0];
  return Boolean(r) && Boolean(r['selector']) && r['selector'].indexOf(VAR_START) === 0;
}
/**
 * @param {string} cssText
 * @return {string}
 */


function removeCustomProps(cssText) {
  cssText = removeCustomPropAssignment(cssText);
  return removeCustomPropApply(cssText);
}
/**
 * @param {string} cssText
 * @return {string}
 */


function removeCustomPropAssignment(cssText) {
  return cssText.replace(RX.customProp, '').replace(RX.mixinProp, '');
}
/**
 * @param {string} cssText
 * @return {string}
 */

function removeCustomPropApply(cssText) {
  return cssText.replace(RX.mixinApply, '').replace(RX.varApply, '');
}
/** @enum {number} */


const types = {
  STYLE_RULE: 1,
  KEYFRAMES_RULE: 7,
  MEDIA_RULE: 4,
  MIXIN_RULE: 1000
};
const OPEN_BRACE = '{';
const CLOSE_BRACE = '}'; // helper regexp's

const RX = {
  comments: /\/\*[^*]*\*+([^/*][^*]*\*+)*\//gim,
  port: /@import[^;]*;/gim,
  customProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\n]|$)/gim,
  mixinProp: /(?:^[^;\-\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\n]|$)?/gim,
  mixinApply: /@apply\s*\(?[^);]*\)?\s*(?:[;\n]|$)?/gim,
  varApply: /[^;:]*?:[^;]*?var\([^;]*\)(?:[;\n]|$)?/gim,
  keyframesRule: /^@[^\s]*keyframes/,
  multipleSpaces: /\s+/g
};
const VAR_START = '--';
const MEDIA_START = '@media';
const AT_START = '@';
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-settings.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


const nativeShadow = !(window['ShadyDOM'] && window['ShadyDOM']['inUse']);
let nativeCssVariables_;
/**
 * @param {(ShadyCSSOptions | ShadyCSSInterface)=} settings
 */

function calcCssVariables(settings) {
  if (settings && settings['shimcssproperties']) {
    nativeCssVariables_ = false;
  } else {
    // chrome 49 has semi-working css vars, check if box-shadow works
    // safari 9.1 has a recalc bug: https://bugs.webkit.org/show_bug.cgi?id=155782
    // However, shim css custom properties are only supported with ShadyDOM enabled,
    // so fall back on native if we do not detect ShadyDOM
    // Edge 15: custom properties used in ::before and ::after will also be used in the parent element
    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/12414257/
    nativeCssVariables_ = nativeShadow || Boolean(!navigator.userAgent.match(/AppleWebKit\/601|Edge\/15/) && window.CSS && CSS.supports && CSS.supports('box-shadow', '0 0 0 var(--foo)'));
  }
}
/** @type {string | undefined} */


let style_settings_cssBuild;

if (window.ShadyCSS && window.ShadyCSS.cssBuild !== undefined) {
  style_settings_cssBuild = window.ShadyCSS.cssBuild;
}
/** @type {boolean} */


const disableRuntime = Boolean(window.ShadyCSS && window.ShadyCSS.disableRuntime);

if (window.ShadyCSS && window.ShadyCSS.nativeCss !== undefined) {
  nativeCssVariables_ = window.ShadyCSS.nativeCss;
} else if (window.ShadyCSS) {
  calcCssVariables(window.ShadyCSS); // reset window variable to let ShadyCSS API take its place

  window.ShadyCSS = undefined;
} else {
  calcCssVariables(window['WebComponents'] && window['WebComponents']['flags']);
} // Hack for type error under new type inference which doesn't like that
// nativeCssVariables is updated in a function and assigns the type
// `function(): ?` instead of `boolean`.


const nativeCssVariables =
/** @type {boolean} */
nativeCssVariables_;
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/common-regex.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const VAR_ASSIGN = /(?:^|[;\s{]\s*)(--[\w-]*?)\s*:\s*(?:((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};{])+)|\{([^}]*)\}(?:(?=[;\s}])|$))/gi;
const MIXIN_MATCH = /(?:^|\W+)@apply\s*\(?([^);\n]*)\)?/gi;
const VAR_CONSUMED = /(--[\w-]+)\s*([:,;)]|$)/gi;
const ANIMATION_MATCH = /(animation\s*:)|(animation-name\s*:)/;
const MEDIA_MATCH = /@media\s(.*)/;
const IS_VAR = /^--/;
const BRACKETED = /\{[^}]*\}/g;
const HOST_PREFIX = '(?:^|[^.#[:])';
const HOST_SUFFIX = '($|[.:[\\s>+~])';
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/unscoped-style-handler.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {!Set<string>} */

const styleTextSet = new Set();
const scopingAttribute = 'shady-unscoped';
/**
 * Add a specifically-marked style to the document directly, and only one copy of that style.
 *
 * @param {!HTMLStyleElement} style
 * @return {undefined}
 */

function processUnscopedStyle(style) {
  const text = style.textContent;

  if (!styleTextSet.has(text)) {
    styleTextSet.add(text);
    const newStyle = style.cloneNode(true);
    document.head.appendChild(newStyle);
  }
}
/**
 * Check if a style is supposed to be unscoped
 * @param {!HTMLStyleElement} style
 * @return {boolean} true if the style has the unscoping attribute
 */

function isUnscopedStyle(style) {
  return style.hasAttribute(scopingAttribute);
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-util.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // eslint-disable-line no-unused-vars



/**
 * @param {string|StyleNode} rules
 * @param {function(StyleNode)=} callback
 * @return {string}
 */

function toCssText(rules, callback) {
  if (!rules) {
    return '';
  }

  if (typeof rules === 'string') {
    rules = parse(rules);
  }

  if (callback) {
    forEachRule(rules, callback);
  }

  return stringify(rules, nativeCssVariables);
}
/**
 * @param {HTMLStyleElement} style
 * @return {StyleNode}
 */

function rulesForStyle(style) {
  if (!style['__cssRules'] && style.textContent) {
    style['__cssRules'] = parse(style.textContent);
  }

  return style['__cssRules'] || null;
} // Tests if a rule is a keyframes selector, which looks almost exactly
// like a normal selector but is not (it has nothing to do with scoping
// for example).

/**
 * @param {StyleNode} rule
 * @return {boolean}
 */

function isKeyframesSelector(rule) {
  return Boolean(rule['parent']) && rule['parent']['type'] === types.KEYFRAMES_RULE;
}
/**
 * @param {StyleNode} node
 * @param {Function=} styleRuleCallback
 * @param {Function=} keyframesRuleCallback
 * @param {boolean=} onlyActiveRules
 */

function forEachRule(node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {
  if (!node) {
    return;
  }

  let skipRules = false;
  let type = node['type'];

  if (onlyActiveRules) {
    if (type === types.MEDIA_RULE) {
      let matchMedia = node['selector'].match(MEDIA_MATCH);

      if (matchMedia) {
        // if rule is a non matching @media rule, skip subrules
        if (!window.matchMedia(matchMedia[1]).matches) {
          skipRules = true;
        }
      }
    }
  }

  if (type === types.STYLE_RULE) {
    styleRuleCallback(node);
  } else if (keyframesRuleCallback && type === types.KEYFRAMES_RULE) {
    keyframesRuleCallback(node);
  } else if (type === types.MIXIN_RULE) {
    skipRules = true;
  }

  let r$ = node['rules'];

  if (r$ && !skipRules) {
    for (let i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {
      forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);
    }
  }
} // add a string of cssText to the document.

/**
 * @param {string} cssText
 * @param {string} moniker
 * @param {Node} target
 * @param {Node} contextNode
 * @return {HTMLStyleElement}
 */

function applyCss(cssText, moniker, target, contextNode) {
  let style = createScopeStyle(cssText, moniker);
  applyStyle(style, target, contextNode);
  return style;
}
/**
 * @param {string} cssText
 * @param {string} moniker
 * @return {HTMLStyleElement}
 */

function createScopeStyle(cssText, moniker) {
  let style =
  /** @type {HTMLStyleElement} */
  document.createElement('style');

  if (moniker) {
    style.setAttribute('scope', moniker);
  }

  style.textContent = cssText;
  return style;
}
/**
 * Track the position of the last added style for placing placeholders
 * @type {Node}
 */

let lastHeadApplyNode = null; // insert a comment node as a styling position placeholder.

/**
 * @param {string} moniker
 * @return {!Comment}
 */

function applyStylePlaceHolder(moniker) {
  let placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');
  let after = lastHeadApplyNode ? lastHeadApplyNode['nextSibling'] : null;
  let scope = document.head;
  scope.insertBefore(placeHolder, after || scope.firstChild);
  lastHeadApplyNode = placeHolder;
  return placeHolder;
}
/**
 * @param {HTMLStyleElement} style
 * @param {?Node} target
 * @param {?Node} contextNode
 */

function applyStyle(style, target, contextNode) {
  target = target || document.head;
  let after = contextNode && contextNode.nextSibling || target.firstChild;
  target.insertBefore(style, after);

  if (!lastHeadApplyNode) {
    lastHeadApplyNode = style;
  } else {
    // only update lastHeadApplyNode if the new style is inserted after the old lastHeadApplyNode
    let position = style.compareDocumentPosition(lastHeadApplyNode);

    if (position === Node.DOCUMENT_POSITION_PRECEDING) {
      lastHeadApplyNode = style;
    }
  }
}
/**
 * @param {string} buildType
 * @return {boolean}
 */

function isTargetedBuild(buildType) {
  return nativeShadow ? buildType === 'shadow' : buildType === 'shady';
}
/**
 * Walk from text[start] matching parens and
 * returns position of the outer end paren
 * @param {string} text
 * @param {number} start
 * @return {number}
 */

function findMatchingParen(text, start) {
  let level = 0;

  for (let i = start, l = text.length; i < l; i++) {
    if (text[i] === '(') {
      level++;
    } else if (text[i] === ')') {
      if (--level === 0) {
        return i;
      }
    }
  }

  return -1;
}
/**
 * @param {string} str
 * @param {function(string, string, string, string)} callback
 */

function processVariableAndFallback(str, callback) {
  // find 'var('
  let start = str.indexOf('var(');

  if (start === -1) {
    // no var?, everything is prefix
    return callback(str, '', '', '');
  } //${prefix}var(${inner})${suffix}


  let end = findMatchingParen(str, start + 3);
  let inner = str.substring(start + 4, end);
  let prefix = str.substring(0, start); // suffix may have other variables

  let suffix = processVariableAndFallback(str.substring(end + 1), callback);
  let comma = inner.indexOf(','); // value and fallback args should be trimmed to match in property lookup

  if (comma === -1) {
    // variable, no fallback
    return callback(prefix, inner.trim(), '', suffix);
  } // var(${value},${fallback})


  let value = inner.substring(0, comma).trim();
  let fallback = inner.substring(comma + 1).trim();
  return callback(prefix, value, fallback, suffix);
}
/**
 * @param {Element} element
 * @param {string} value
 */

function setElementClassRaw(element, value) {
  // use native setAttribute provided by ShadyDOM when setAttribute is patched
  if (nativeShadow) {
    element.setAttribute('class', value);
  } else {
    window['ShadyDOM']['nativeMethods']['setAttribute'].call(element, 'class', value);
  }
}
/**
 * @type {function(*):*}
 */

const wrap = window['ShadyDOM'] && window['ShadyDOM']['wrap'] || (node => node);
/**
 * @param {Element | {is: string, extends: string}} element
 * @return {{is: string, typeExtension: string}}
 */

function getIsExtends(element) {
  let localName = element['localName'];
  let is = '',
      typeExtension = '';
  /*
  NOTE: technically, this can be wrong for certain svg elements
  with `-` in the name like `<font-face>`
  */

  if (localName) {
    if (localName.indexOf('-') > -1) {
      is = localName;
    } else {
      typeExtension = localName;
      is = element.getAttribute && element.getAttribute('is') || '';
    }
  } else {
    is =
    /** @type {?} */
    element.is;
    typeExtension =
    /** @type {?} */
    element.extends;
  }

  return {
    is,
    typeExtension
  };
}
/**
 * @param {Element|DocumentFragment} element
 * @return {string}
 */

function gatherStyleText(element) {
  /** @type {!Array<string>} */
  const styleTextParts = [];
  const styles =
  /** @type {!NodeList<!HTMLStyleElement>} */
  element.querySelectorAll('style');

  for (let i = 0; i < styles.length; i++) {
    const style = styles[i];

    if (isUnscopedStyle(style)) {
      if (!nativeShadow) {
        processUnscopedStyle(style);
        style.parentNode.removeChild(style);
      }
    } else {
      styleTextParts.push(style.textContent);
      style.parentNode.removeChild(style);
    }
  }

  return styleTextParts.join('').trim();
}
/**
 * Split a selector separated by commas into an array in a smart way
 * @param {string} selector
 * @return {!Array<string>}
 */

function splitSelectorList(selector) {
  const parts = [];
  let part = '';

  for (let i = 0; i >= 0 && i < selector.length; i++) {
    // A selector with parentheses will be one complete part
    if (selector[i] === '(') {
      // find the matching paren
      const end = findMatchingParen(selector, i); // push the paren block into the part

      part += selector.slice(i, end + 1); // move the index to after the paren block

      i = end;
    } else if (selector[i] === ',') {
      parts.push(part);
      part = '';
    } else {
      part += selector[i];
    }
  } // catch any pieces after the last comma


  if (part) {
    parts.push(part);
  }

  return parts;
}
const CSS_BUILD_ATTR = 'css-build';
/**
 * Return the polymer-css-build "build type" applied to this element
 *
 * @param {!HTMLElement} element
 * @return {string} Can be "", "shady", or "shadow"
 */

function getCssBuild(element) {
  if (style_settings_cssBuild !== undefined) {
    return (
      /** @type {string} */
      style_settings_cssBuild
    );
  }

  if (element.__cssBuild === undefined) {
    // try attribute first, as it is the common case
    const attrValue = element.getAttribute(CSS_BUILD_ATTR);

    if (attrValue) {
      element.__cssBuild = attrValue;
    } else {
      const buildComment = getBuildComment(element);

      if (buildComment !== '') {
        // remove build comment so it is not needlessly copied into every element instance
        removeBuildComment(element);
      }

      element.__cssBuild = buildComment;
    }
  }

  return element.__cssBuild || '';
}
/**
 * Check if the given element, either a <template> or <style>, has been processed
 * by polymer-css-build.
 *
 * If so, then we can make a number of optimizations:
 * - polymer-css-build will decompose mixins into individual CSS Custom Properties,
 * so the ApplyShim can be skipped entirely.
 * - Under native ShadowDOM, the style text can just be copied into each instance
 * without modification
 * - If the build is "shady" and ShadyDOM is in use, the styling does not need
 * scoping beyond the shimming of CSS Custom Properties
 *
 * @param {!HTMLElement} element
 * @return {boolean}
 */

function elementHasBuiltCss(element) {
  return getCssBuild(element) !== '';
}
/**
 * For templates made with tagged template literals, polymer-css-build will
 * insert a comment of the form `<!--css-build:shadow-->`
 *
 * @param {!HTMLElement} element
 * @return {string}
 */

function getBuildComment(element) {
  const buildComment = element.localName === 'template' ?
  /** @type {!HTMLTemplateElement} */
  element.content.firstChild : element.firstChild;

  if (buildComment instanceof Comment) {
    const commentParts = buildComment.textContent.trim().split(':');

    if (commentParts[0] === CSS_BUILD_ATTR) {
      return commentParts[1];
    }
  }

  return '';
}
/**
 * Check if the css build status is optimal, and do no unneeded work.
 *
 * @param {string=} cssBuild CSS build status
 * @return {boolean} css build is optimal or not
 */

function isOptimalCssBuild(cssBuild = '') {
  // CSS custom property shim always requires work
  if (cssBuild === '' || !nativeCssVariables) {
    return false;
  }

  return nativeShadow ? cssBuild === 'shadow' : cssBuild === 'shady';
}
/**
 * @param {!HTMLElement} element
 */

function removeBuildComment(element) {
  const buildComment = element.localName === 'template' ?
  /** @type {!HTMLTemplateElement} */
  element.content.firstChild : element.firstChild;
  buildComment.parentNode.removeChild(buildComment);
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-transformer.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


 // eslint-disable-line no-unused-vars



/* Transforms ShadowDOM styling into ShadyDOM styling

* scoping:

  * elements in scope get scoping selector class="x-foo-scope"
  * selectors re-written as follows:

    div button -> div.x-foo-scope button.x-foo-scope

* :host -> scopeName

* :host(...) -> scopeName...

* ::slotted(...) -> scopeName > ...

* ...:dir(ltr|rtl) -> [dir="ltr|rtl"] ..., ...[dir="ltr|rtl"]

* :host(:dir[rtl]) -> scopeName:dir(rtl) -> [dir="rtl"] scopeName, scopeName[dir="rtl"]

*/

const SCOPE_NAME = 'style-scope';

class style_transformer_StyleTransformer {
  get SCOPE_NAME() {
    return SCOPE_NAME;
  }
  /**
   * Given a node and scope name, add a scoping class to each node
   * in the tree. This facilitates transforming css into scoped rules.
   * @param {!Node} node
   * @param {string} scope
   * @param {boolean=} shouldRemoveScope
   * @deprecated
   */


  dom(node, scope, shouldRemoveScope) {
    const fn = node => {
      this.element(node, scope || '', shouldRemoveScope);
    };

    this._transformDom(node, fn);
  }
  /**
   * Given a node and scope name, add a scoping class to each node in the tree.
   * @param {!Node} node
   * @param {string} scope
   */


  domAddScope(node, scope) {
    const fn = node => {
      this.element(node, scope || '');
    };

    this._transformDom(node, fn);
  }
  /**
   * @param {!Node} startNode
   * @param {!function(!Node)} transformer
   */


  _transformDom(startNode, transformer) {
    if (startNode.nodeType === Node.ELEMENT_NODE) {
      transformer(startNode);
    }

    let c$;

    if (startNode.localName === 'template') {
      const template =
      /** @type {!HTMLTemplateElement} */
      startNode; // In case the template is in svg context, fall back to the node
      // since it won't be an HTMLTemplateElement with a .content property

      c$ = (template.content || template._content || template).childNodes;
    } else {
      c$ =
      /** @type {!ParentNode} */
      startNode.children || startNode.childNodes;
    }

    if (c$) {
      for (let i = 0; i < c$.length; i++) {
        this._transformDom(c$[i], transformer);
      }
    }
  }
  /**
   * @param {?} element
   * @param {?} scope
   * @param {?=} shouldRemoveScope
   */


  element(element, scope, shouldRemoveScope) {
    // note: if using classes, we add both the general 'style-scope' class
    // as well as the specific scope. This enables easy filtering of all
    // `style-scope` elements
    if (scope) {
      // note: svg on IE does not have classList so fallback to class
      if (element.classList) {
        if (shouldRemoveScope) {
          element.classList.remove(SCOPE_NAME);
          element.classList.remove(scope);
        } else {
          element.classList.add(SCOPE_NAME);
          element.classList.add(scope);
        }
      } else if (element.getAttribute) {
        let c = element.getAttribute(CLASS);

        if (shouldRemoveScope) {
          if (c) {
            let newValue = c.replace(SCOPE_NAME, '').replace(scope, '');
            setElementClassRaw(element, newValue);
          }
        } else {
          let newValue = (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope;
          setElementClassRaw(element, newValue);
        }
      }
    }
  }
  /**
   * Given a node, replace the scoping class to each subnode in the tree.
   * @param {!Node} node
   * @param {string} oldScope
   * @param {string} newScope
   */


  domReplaceScope(node, oldScope, newScope) {
    const fn = node => {
      this.element(node, oldScope, true);
      this.element(node, newScope);
    };

    this._transformDom(node, fn);
  }
  /**
   * Given a node, remove the scoping class to each subnode in the tree.
   * @param {!Node} node
   * @param {string} oldScope
   */


  domRemoveScope(node, oldScope) {
    const fn = node => {
      this.element(node, oldScope || '', true);
    };

    this._transformDom(node, fn);
  }
  /**
   * @param {?} element
   * @param {?} styleRules
   * @param {?=} callback
   * @param {string=} cssBuild
   * @param {string=} cssText
   * @return {string}
   */


  elementStyles(element, styleRules, callback, cssBuild = '', cssText = '') {
    // no need to shim selectors if settings.useNativeShadow, also
    // a shady css build will already have transformed selectors
    // NOTE: This method may be called as part of static or property shimming.
    // When there is a targeted build it will not be called for static shimming,
    // but when the property shim is used it is called and should opt out of
    // static shimming work when a proper build exists.
    if (cssText === '') {
      if (nativeShadow || cssBuild === 'shady') {
        cssText = toCssText(styleRules, callback);
      } else {
        let {
          is,
          typeExtension
        } = getIsExtends(element);
        cssText = this.css(styleRules, is, typeExtension, callback) + '\n\n';
      }
    }

    return cssText.trim();
  } // Given a string of cssText and a scoping string (scope), returns
  // a string of scoped css where each selector is transformed to include
  // a class created from the scope. ShadowDOM selectors are also transformed
  // (e.g. :host) to use the scoping selector.


  css(rules, scope, ext, callback) {
    let hostScope = this._calcHostScope(scope, ext);

    scope = this._calcElementScope(scope);
    let self = this;
    return toCssText(rules, function (
    /** StyleNode */
    rule) {
      if (!rule.isScoped) {
        self.rule(rule, scope, hostScope);
        rule.isScoped = true;
      }

      if (callback) {
        callback(rule, scope, hostScope);
      }
    });
  }

  _calcElementScope(scope) {
    if (scope) {
      return CSS_CLASS_PREFIX + scope;
    } else {
      return '';
    }
  }

  _calcHostScope(scope, ext) {
    return ext ? "[is=".concat(scope, "]") : scope;
  }

  rule(rule, scope, hostScope) {
    this._transformRule(rule, this._transformComplexSelector, scope, hostScope);
  }
  /**
   * transforms a css rule to a scoped rule.
   *
   * @param {StyleNode} rule
   * @param {Function} transformer
   * @param {string=} scope
   * @param {string=} hostScope
   */


  _transformRule(rule, transformer, scope, hostScope) {
    // NOTE: save transformedSelector for subsequent matching of elements
    // against selectors (e.g. when calculating style properties)
    rule['selector'] = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);
  }
  /**
   * @param {StyleNode} rule
   * @param {Function} transformer
   * @param {string=} scope
   * @param {string=} hostScope
   */


  _transformRuleCss(rule, transformer, scope, hostScope) {
    let p$ = splitSelectorList(rule['selector']); // we want to skip transformation of rules that appear in keyframes,
    // because they are keyframe selectors, not element selectors.

    if (!isKeyframesSelector(rule)) {
      for (let i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {
        p$[i] = transformer.call(this, p, scope, hostScope);
      }
    }

    return p$.filter(part => Boolean(part)).join(COMPLEX_SELECTOR_SEP);
  }
  /**
   * @param {string} selector
   * @return {string}
   */


  _twiddleNthPlus(selector) {
    return selector.replace(NTH, (m, type, inside) => {
      if (inside.indexOf('+') > -1) {
        inside = inside.replace(/\+/g, '___');
      } else if (inside.indexOf('___') > -1) {
        inside = inside.replace(/___/g, '+');
      }

      return ":".concat(type, "(").concat(inside, ")");
    });
  }
  /**
   * Preserve `:matches()` selectors by replacing them with MATCHES_REPLACMENT
   * and returning an array of `:matches()` selectors.
   * Use `_replacesMatchesPseudo` to replace the `:matches()` parts
   *
   * @param {string} selector
   * @return {{selector: string, matches: !Array<string>}}
   */


  _preserveMatchesPseudo(selector) {
    /** @type {!Array<string>} */
    const matches = [];
    let match;

    while (match = selector.match(MATCHES)) {
      const start = match.index;
      const end = findMatchingParen(selector, start);

      if (end === -1) {
        throw new Error("".concat(match.input, " selector missing ')'"));
      }

      const part = selector.slice(start, end + 1);
      selector = selector.replace(part, MATCHES_REPLACEMENT);
      matches.push(part);
    }

    return {
      selector,
      matches
    };
  }
  /**
   * Replace MATCHES_REPLACMENT character with the given set of `:matches()`
   * selectors.
   *
   * @param {string} selector
   * @param {!Array<string>} matches
   * @return {string}
   */


  _replaceMatchesPseudo(selector, matches) {
    const parts = selector.split(MATCHES_REPLACEMENT);
    return matches.reduce((acc, cur, idx) => acc + cur + parts[idx + 1], parts[0]);
  }
  /**
   * @param {string} selector
   * @param {string} scope
   * @param {string=} hostScope
   */


  _transformComplexSelector(selector, scope, hostScope) {
    let stop = false;
    selector = selector.trim(); // Remove spaces inside of selectors like `:nth-of-type` because it confuses SIMPLE_SELECTOR_SEP

    let isNth = NTH.test(selector);

    if (isNth) {
      selector = selector.replace(NTH, (m, type, inner) => ":".concat(type, "(").concat(inner.replace(/\s/g, ''), ")"));
      selector = this._twiddleNthPlus(selector);
    } // Preserve selectors like `:-webkit-any` so that SIMPLE_SELECTOR_SEP does
    // not get confused by spaces inside the pseudo selector


    const isMatches = MATCHES.test(selector);
    /** @type {!Array<string>} */

    let matches;

    if (isMatches) {
      ({
        selector,
        matches
      } = this._preserveMatchesPseudo(selector));
    }

    selector = selector.replace(SLOTTED_START, "".concat(HOST, " $1"));
    selector = selector.replace(SIMPLE_SELECTOR_SEP, (m, c, s) => {
      if (!stop) {
        let info = this._transformCompoundSelector(s, c, scope, hostScope);

        stop = stop || info.stop;
        c = info.combinator;
        s = info.value;
      }

      return c + s;
    }); // replace `:matches()` selectors

    if (isMatches) {
      selector = this._replaceMatchesPseudo(selector, matches);
    }

    if (isNth) {
      selector = this._twiddleNthPlus(selector);
    }

    selector = selector.replace(DIR_PAREN, (m, before, dir, after) => "[dir=\"".concat(dir, "\"] ").concat(before).concat(after, ", ").concat(before, "[dir=\"").concat(dir, "\"]").concat(after));
    return selector;
  }

  _transformCompoundSelector(selector, combinator, scope, hostScope) {
    // replace :host with host scoping class
    let slottedIndex = selector.indexOf(SLOTTED);

    if (selector.indexOf(HOST) >= 0) {
      selector = this._transformHostSelector(selector, hostScope); // replace other selectors with scoping class
    } else if (slottedIndex !== 0) {
      selector = scope ? this._transformSimpleSelector(selector, scope) : selector;
    } // mark ::slotted() scope jump to replace with descendant selector + arg
    // also ignore left-side combinator


    let slotted = false;

    if (slottedIndex >= 0) {
      combinator = '';
      slotted = true;
    } // process scope jumping selectors up to the scope jump and then stop


    let stop;

    if (slotted) {
      stop = true;

      if (slotted) {
        // .zonk ::slotted(.foo) -> .zonk.scope > .foo
        selector = selector.replace(SLOTTED_PAREN, (m, paren) => " > ".concat(paren));
      }
    }

    return {
      value: selector,
      combinator,
      stop
    };
  }

  _transformSimpleSelector(selector, scope) {
    const attributes = selector.split(/(\[.+?\])/);
    const output = [];

    for (let i = 0; i < attributes.length; i++) {
      // Do not attempt to transform any attribute selector content
      if (i % 2 === 1) {
        output.push(attributes[i]);
      } else {
        const part = attributes[i];

        if (!(part === '' && i === attributes.length - 1)) {
          let p$ = part.split(PSEUDO_PREFIX);
          p$[0] += scope;
          output.push(p$.join(PSEUDO_PREFIX));
        }
      }
    }

    return output.join('');
  } // :host(...) -> scopeName...


  _transformHostSelector(selector, hostScope) {
    let m = selector.match(HOST_PAREN);
    let paren = m && m[2].trim() || '';

    if (paren) {
      if (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {
        // paren starts with a type selector
        let typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0]; // if the type selector is our hostScope then avoid pre-pending it

        if (typeSelector === hostScope) {
          return paren; // otherwise, this selector should not match in this scope so
          // output a bogus selector.
        } else {
          return SELECTOR_NO_MATCH;
        }
      } else {
        // make sure to do a replace here to catch selectors like:
        // `:host(.foo)::before`
        return selector.replace(HOST_PAREN, function (m, host, paren) {
          return hostScope + paren;
        });
      } // if no paren, do a straight :host replacement.
      // TODO(sorvell): this should not strictly be necessary but
      // it's needed to maintain support for `:host[foo]` type selectors
      // which have been improperly used under Shady DOM. This should be
      // deprecated.

    } else {
      return selector.replace(HOST, hostScope);
    }
  }
  /**
   * @param {StyleNode} rule
   */


  documentRule(rule) {
    // reset selector in case this is redone.
    rule['selector'] = rule['parsedSelector'];
    this.normalizeRootSelector(rule);

    this._transformRule(rule, this._transformDocumentSelector);
  }
  /**
   * @param {StyleNode} rule
   */


  normalizeRootSelector(rule) {
    if (rule['selector'] === ROOT) {
      rule['selector'] = 'html';
    }
  }
  /**
   * @param {string} selector
   */


  _transformDocumentSelector(selector) {
    if (selector.match(HOST)) {
      // remove ':host' type selectors in document rules
      return '';
    } else if (selector.match(SLOTTED)) {
      return this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR);
    } else {
      return this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);
    }
  }

}

const NTH = /:(nth[-\w]+)\(([^)]+)\)/;
const SCOPE_DOC_SELECTOR = ":not(.".concat(SCOPE_NAME, ")");
const COMPLEX_SELECTOR_SEP = ',';
const SIMPLE_SELECTOR_SEP = /(^|[\s>+~]+)((?:\[.+?\]|[^\s>+~=[])+)/g;
const SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;
const HOST = ':host';
const ROOT = ':root';
const SLOTTED = '::slotted';
const SLOTTED_START = new RegExp("^(".concat(SLOTTED, ")")); // NOTE: this supports 1 nested () pair for things like
// :host(:not([selected]), more general support requires
// parsing which seems like overkill

const HOST_PAREN = /(:host)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/; // similar to HOST_PAREN

const SLOTTED_PAREN = /(?:::slotted)(?:\(((?:\([^)(]*\)|[^)(]*)+?)\))/;
const DIR_PAREN = /(.*):dir\((?:(ltr|rtl))\)(.*)/;
const CSS_CLASS_PREFIX = '.';
const PSEUDO_PREFIX = ':';
const CLASS = 'class';
const SELECTOR_NO_MATCH = 'should_not_match';
const MATCHES = /:(?:matches|any|-(?:webkit|moz)-any)/;
const MATCHES_REPLACEMENT = '\u{e000}';
/* harmony default export */ var style_transformer = (new style_transformer_StyleTransformer());
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-info.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


 // eslint-disable-line no-unused-vars

/** @const {string} */

const infoKey = '__styleInfo';
class StyleInfo {
  /**
   * @param {Element} node
   * @return {StyleInfo}
   */
  static get(node) {
    if (node) {
      return node[infoKey];
    } else {
      return null;
    }
  }
  /**
   * @param {!Element} node
   * @param {StyleInfo} styleInfo
   * @return {StyleInfo}
   */


  static set(node, styleInfo) {
    node[infoKey] = styleInfo;
    return styleInfo;
  }
  /**
   * @param {StyleNode} ast
   * @param {Node=} placeholder
   * @param {Array<string>=} ownStylePropertyNames
   * @param {string=} elementName
   * @param {string=} typeExtension
   * @param {string=} cssBuild
   */


  constructor(ast, placeholder, ownStylePropertyNames, elementName, typeExtension, cssBuild) {
    /** @type {StyleNode} */
    this.styleRules = ast || null;
    /** @type {Node} */

    this.placeholder = placeholder || null;
    /** @type {!Array<string>} */

    this.ownStylePropertyNames = ownStylePropertyNames || [];
    /** @type {Object} */

    this.overrideStyleProperties = null;
    /** @type {string} */

    this.elementName = elementName || '';
    /** @type {string} */

    this.cssBuild = cssBuild || '';
    /** @type {string} */

    this.typeExtension = typeExtension || '';
    /** @type {Object<string, string>} */

    this.styleProperties = null;
    /** @type {?string} */

    this.scopeSelector = null;
    /** @type {HTMLStyleElement} */

    this.customStyle = null;
  }

  _getStyleRules() {
    return this.styleRules;
  }

}
/* eslint-disable-next-line no-self-assign */

StyleInfo.prototype['_getStyleRules'] = StyleInfo.prototype._getStyleRules;
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-properties.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


 // eslint-disable-line no-unused-vars





 // TODO: dedupe with shady

/**
 * @param {string} selector
 * @return {boolean}
 * @this {Element}
 */

const matchesSelector = function (selector) {
  const method = this.matches || this.matchesSelector || this.mozMatchesSelector || this.msMatchesSelector || this.oMatchesSelector || this.webkitMatchesSelector;
  return method && method.call(this, selector);
};

const IS_IE = navigator.userAgent.match('Trident');
const XSCOPE_NAME = 'x-scope';

class style_properties_StyleProperties {
  get XSCOPE_NAME() {
    return XSCOPE_NAME;
  }
  /**
   * decorates styles with rule info and returns an array of used style property names
   *
   * @param {StyleNode} rules
   * @return {Array<string>}
   */


  decorateStyles(rules) {
    let self = this,
        props = {},
        keyframes = [],
        ruleIndex = 0;
    forEachRule(rules, function (rule) {
      self.decorateRule(rule); // mark in-order position of ast rule in styles block, used for cache key

      rule.index = ruleIndex++;
      self.collectPropertiesInCssText(rule.propertyInfo.cssText, props);
    }, function onKeyframesRule(rule) {
      keyframes.push(rule);
    }); // Cache all found keyframes rules for later reference:

    rules._keyframes = keyframes; // return this list of property names *consumes* in these styles.

    let names = [];

    for (let i in props) {
      names.push(i);
    }

    return names;
  } // decorate a single rule with property info


  decorateRule(rule) {
    if (rule.propertyInfo) {
      return rule.propertyInfo;
    }

    let info = {},
        properties = {};
    let hasProperties = this.collectProperties(rule, properties);

    if (hasProperties) {
      info.properties = properties; // TODO(sorvell): workaround parser seeing mixins as additional rules

      rule['rules'] = null;
    }

    info.cssText = this.collectCssText(rule);
    rule.propertyInfo = info;
    return info;
  } // collects the custom properties from a rule's cssText


  collectProperties(rule, properties) {
    let info = rule.propertyInfo;

    if (info) {
      if (info.properties) {
        Object.assign(properties, info.properties);
        return true;
      }
    } else {
      let m,
          rx = VAR_ASSIGN;
      let cssText = rule['parsedCssText'];
      let value;
      let any;

      while (m = rx.exec(cssText)) {
        // note: group 2 is var, 3 is mixin
        value = (m[2] || m[3]).trim(); // value of 'inherit' or 'unset' is equivalent to not setting the property here

        if (value !== 'inherit' || value !== 'unset') {
          properties[m[1].trim()] = value;
        }

        any = true;
      }

      return any;
    }
  } // returns cssText of properties that consume variables/mixins


  collectCssText(rule) {
    return this.collectConsumingCssText(rule['parsedCssText']);
  } // NOTE: we support consumption inside mixin assignment
  // but not production, so strip out {...}


  collectConsumingCssText(cssText) {
    return cssText.replace(BRACKETED, '').replace(VAR_ASSIGN, '');
  }

  collectPropertiesInCssText(cssText, props) {
    let m;

    while (m = VAR_CONSUMED.exec(cssText)) {
      let name = m[1]; // This regex catches all variable names, and following non-whitespace char
      // If next char is not ':', then variable is a consumer

      if (m[2] !== ':') {
        props[name] = true;
      }
    }
  } // turns custom properties into realized values.


  reify(props) {
    // big perf optimization here: reify only *own* properties
    // since this object has __proto__ of the element's scope properties
    let names = Object.getOwnPropertyNames(props);

    for (let i = 0, n; i < names.length; i++) {
      n = names[i];
      props[n] = this.valueForProperty(props[n], props);
    }
  } // given a property value, returns the reified value
  // a property value may be:
  // (1) a literal value like: red or 5px;
  // (2) a variable value like: var(--a), var(--a, red), or var(--a, --b) or
  // var(--a, var(--b));
  // (3) a literal mixin value like { properties }. Each of these properties
  // can have values that are: (a) literal, (b) variables, (c) @apply mixins.


  valueForProperty(property, props) {
    // case (1) default
    // case (3) defines a mixin and we have to reify the internals
    if (property) {
      if (property.indexOf(';') >= 0) {
        property = this.valueForProperties(property, props);
      } else {
        // case (2) variable
        let self = this;

        let fn = function (prefix, value, fallback, suffix) {
          if (!value) {
            return prefix + suffix;
          }

          let propertyValue = self.valueForProperty(props[value], props); // if value is "initial", then the variable should be treated as unset

          if (!propertyValue || propertyValue === 'initial') {
            // fallback may be --a or var(--a) or literal
            propertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;
          } else if (propertyValue === 'apply-shim-inherit') {
            // CSS build will replace `inherit` with `apply-shim-inherit`
            // for use with native css variables.
            // Since we have full control, we can use `inherit` directly.
            propertyValue = 'inherit';
          }

          return prefix + (propertyValue || '') + suffix;
        };

        property = processVariableAndFallback(property, fn);
      }
    }

    return property && property.trim() || '';
  } // note: we do not yet support mixin within mixin


  valueForProperties(property, props) {
    let parts = property.split(';');

    for (let i = 0, p, m; i < parts.length; i++) {
      if (p = parts[i]) {
        MIXIN_MATCH.lastIndex = 0;
        m = MIXIN_MATCH.exec(p);

        if (m) {
          p = this.valueForProperty(props[m[1]], props);
        } else {
          let colon = p.indexOf(':');

          if (colon !== -1) {
            let pp = p.substring(colon);
            pp = pp.trim();
            pp = this.valueForProperty(pp, props) || pp;
            p = p.substring(0, colon) + pp;
          }
        }

        parts[i] = p && p.lastIndexOf(';') === p.length - 1 ? // strip trailing ;
        p.slice(0, -1) : p || '';
      }
    }

    return parts.join(';');
  }

  applyProperties(rule, props) {
    let output = ''; // dynamically added sheets may not be decorated so ensure they are.

    if (!rule.propertyInfo) {
      this.decorateRule(rule);
    }

    if (rule.propertyInfo.cssText) {
      output = this.valueForProperties(rule.propertyInfo.cssText, props);
    }

    rule['cssText'] = output;
  } // Apply keyframe transformations to the cssText of a given rule. The
  // keyframeTransforms object is a map of keyframe names to transformer
  // functions which take in cssText and spit out transformed cssText.


  applyKeyframeTransforms(rule, keyframeTransforms) {
    let input = rule['cssText'];
    let output = rule['cssText'];

    if (rule.hasAnimations == null) {
      // Cache whether or not the rule has any animations to begin with:
      rule.hasAnimations = ANIMATION_MATCH.test(input);
    } // If there are no animations referenced, we can skip transforms:


    if (rule.hasAnimations) {
      let transform; // If we haven't transformed this rule before, we iterate over all
      // transforms:

      if (rule.keyframeNamesToTransform == null) {
        rule.keyframeNamesToTransform = [];

        for (let keyframe in keyframeTransforms) {
          transform = keyframeTransforms[keyframe];
          output = transform(input); // If the transform actually changed the CSS text, we cache the
          // transform name for future use:

          if (input !== output) {
            input = output;
            rule.keyframeNamesToTransform.push(keyframe);
          }
        }
      } else {
        // If we already have a list of keyframe names that apply to this
        // rule, we apply only those keyframe name transforms:
        for (let i = 0; i < rule.keyframeNamesToTransform.length; ++i) {
          transform = keyframeTransforms[rule.keyframeNamesToTransform[i]];
          input = transform(input);
        }

        output = input;
      }
    }

    rule['cssText'] = output;
  } // Test if the rules in these styles matches the given `element` and if so,
  // collect any custom properties into `props`.

  /**
   * @param {StyleNode} rules
   * @param {Element} element
   */


  propertyDataFromStyles(rules, element) {
    let props = {}; // generates a unique key for these matches

    let o = []; // note: active rules excludes non-matching @media rules

    forEachRule(rules, rule => {
      // TODO(sorvell): we could trim the set of rules at declaration
      // time to only include ones that have properties
      if (!rule.propertyInfo) {
        this.decorateRule(rule);
      } // match element against transformedSelector: selector may contain
      // unwanted uniquification and parsedSelector does not directly match
      // for :host selectors.


      let selectorToMatch = rule.transformedSelector || rule['parsedSelector'];

      if (element && rule.propertyInfo.properties && selectorToMatch) {
        if (matchesSelector.call(element, selectorToMatch)) {
          this.collectProperties(rule, props); // produce numeric key for these matches for lookup

          addToBitMask(rule.index, o);
        }
      }
    }, null, true);
    return {
      properties: props,
      key: o
    };
  }
  /**
   * @param {Element} scope
   * @param {StyleNode} rule
   * @param {string} cssBuild
   * @param {function(Object)} callback
   */


  whenHostOrRootRule(scope, rule, cssBuild, callback) {
    if (!rule.propertyInfo) {
      this.decorateRule(rule);
    }

    if (!rule.propertyInfo.properties) {
      return;
    }

    let {
      is,
      typeExtension
    } = getIsExtends(scope);
    let hostScope = is ? style_transformer._calcHostScope(is, typeExtension) : 'html';
    let parsedSelector = rule['parsedSelector'];
    let isRoot = parsedSelector === ':host > *' || parsedSelector === 'html';
    let isHost = parsedSelector.indexOf(':host') === 0 && !isRoot; // build info is either in scope (when scope is an element) or in the style
    // when scope is the default scope; note: this allows default scope to have
    // mixed mode built and unbuilt styles.

    if (cssBuild === 'shady') {
      // :root -> x-foo > *.x-foo for elements and html for custom-style
      isRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1; // :host -> x-foo for elements, but sub-rules have .x-foo in them

      isHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;
    }

    if (!isRoot && !isHost) {
      return;
    }

    let selectorToMatch = hostScope;

    if (isHost) {
      // need to transform :host because `:host` does not work with `matches`
      if (!rule.transformedSelector) {
        // transform :host into a matchable selector
        rule.transformedSelector = style_transformer._transformRuleCss(rule, style_transformer._transformComplexSelector, style_transformer._calcElementScope(is), hostScope);
      }

      selectorToMatch = rule.transformedSelector || hostScope;
    }

    callback({
      selector: selectorToMatch,
      isHost: isHost,
      isRoot: isRoot
    });
  }
  /**
   * @param {Element} scope
   * @param {StyleNode} rules
   * @param {string} cssBuild
   * @return {Object}
   */


  hostAndRootPropertiesForScope(scope, rules, cssBuild) {
    let hostProps = {},
        rootProps = {}; // note: active rules excludes non-matching @media rules

    forEachRule(rules, rule => {
      // if scope is StyleDefaults, use _element for matchesSelector
      this.whenHostOrRootRule(scope, rule, cssBuild, info => {
        let element = scope._element || scope;

        if (matchesSelector.call(element, info.selector)) {
          if (info.isHost) {
            this.collectProperties(rule, hostProps);
          } else {
            this.collectProperties(rule, rootProps);
          }
        }
      });
    }, null, true);
    return {
      rootProps: rootProps,
      hostProps: hostProps
    };
  }
  /**
   * @param {Element} element
   * @param {Object} properties
   * @param {string} scopeSelector
   */


  transformStyles(element, properties, scopeSelector) {
    let self = this;
    let {
      is,
      typeExtension
    } = getIsExtends(element);

    let hostSelector = style_transformer._calcHostScope(is, typeExtension);

    let rxHostSelector = element.extends ? '\\' + hostSelector.slice(0, -1) + '\\]' : hostSelector;
    let hostRx = new RegExp(HOST_PREFIX + rxHostSelector + HOST_SUFFIX);
    let {
      styleRules: rules,
      cssBuild
    } = StyleInfo.get(element);

    let keyframeTransforms = this._elementKeyframeTransforms(element, rules, scopeSelector);

    return style_transformer.elementStyles(element, rules, function (rule) {
      self.applyProperties(rule, properties);

      if (!nativeShadow && !isKeyframesSelector(rule) && rule['cssText']) {
        // NOTE: keyframe transforms only scope munge animation names, so it
        // is not necessary to apply them in ShadowDOM.
        self.applyKeyframeTransforms(rule, keyframeTransforms);

        self._scopeSelector(rule, hostRx, hostSelector, scopeSelector);
      }
    }, cssBuild);
  }
  /**
   * @param {Element} element
   * @param {StyleNode} rules
   * @param {string} scopeSelector
   * @return {Object}
   */


  _elementKeyframeTransforms(element, rules, scopeSelector) {
    let keyframesRules = rules._keyframes;
    let keyframeTransforms = {};

    if (!nativeShadow && keyframesRules) {
      // For non-ShadowDOM, we transform all known keyframes rules in
      // advance for the current scope. This allows us to catch keyframes
      // rules that appear anywhere in the stylesheet:
      for (let i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {
        this._scopeKeyframes(keyframesRule, scopeSelector);

        keyframeTransforms[keyframesRule['keyframesName']] = this._keyframesRuleTransformer(keyframesRule);
      }
    }

    return keyframeTransforms;
  } // Generate a factory for transforming a chunk of CSS text to handle a
  // particular scoped keyframes rule.

  /**
   * @param {StyleNode} keyframesRule
   * @return {function(string):string}
   */


  _keyframesRuleTransformer(keyframesRule) {
    return function (cssText) {
      return cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);
    };
  }
  /**
   * Transforms `@keyframes` names to be unique for the current host.
   * Example: @keyframes foo-anim -> @keyframes foo-anim-x-foo-0
   *
   * @param {StyleNode} rule
   * @param {string} scopeId
   */


  _scopeKeyframes(rule, scopeId) {
    // Animation names are of the form [\w-], so ensure that the name regex does not partially apply
    // to similarly named keyframe names by checking for a word boundary at the beginning and
    // a non-word boundary or `-` at the end.
    rule.keyframesNameRx = new RegExp("\\b".concat(rule['keyframesName'], "(?!\\B|-)"), 'g');
    rule.transformedKeyframesName = rule['keyframesName'] + '-' + scopeId;
    rule.transformedSelector = rule.transformedSelector || rule['selector'];
    rule['selector'] = rule.transformedSelector.replace(rule['keyframesName'], rule.transformedKeyframesName);
  } // Strategy: x scope shim a selector e.g. to scope `.x-foo-42` (via classes):
  // non-host selector: .a.x-foo -> .x-foo-42 .a.x-foo
  // host selector: x-foo.wide -> .x-foo-42.wide
  // note: we use only the scope class (.x-foo-42) and not the hostSelector
  // (x-foo) to scope :host rules; this helps make property host rules
  // have low specificity. They are overrideable by class selectors but,
  // unfortunately, not by type selectors (e.g. overriding via
  // `.special` is ok, but not by `x-foo`).

  /**
   * @param {StyleNode} rule
   * @param {RegExp} hostRx
   * @param {string} hostSelector
   * @param {string} scopeId
   */


  _scopeSelector(rule, hostRx, hostSelector, scopeId) {
    rule.transformedSelector = rule.transformedSelector || rule['selector'];
    let selector = rule.transformedSelector;
    let scope = '.' + scopeId;
    let parts = splitSelectorList(selector);

    for (let i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {
      parts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;
    }

    rule['selector'] = parts.join(',');
  }
  /**
   * @param {Element} element
   * @param {string} selector
   * @param {string} old
   */


  applyElementScopeSelector(element, selector, old) {
    let c = element.getAttribute('class') || '';
    let v = c;

    if (old) {
      v = c.replace(new RegExp('\\s*' + XSCOPE_NAME + '\\s*' + old + '\\s*', 'g'), ' ');
    }

    v += (v ? ' ' : '') + XSCOPE_NAME + ' ' + selector;

    if (c !== v) {
      setElementClassRaw(element, v);
    }
  }
  /**
   * @param {HTMLElement} element
   * @param {Object} properties
   * @param {string} selector
   * @param {HTMLStyleElement} style
   * @return {HTMLStyleElement}
   */


  applyElementStyle(element, properties, selector, style) {
    // calculate cssText to apply
    let cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector); // if shady and we have a cached style that is not style, decrement

    let styleInfo = StyleInfo.get(element);
    let s = styleInfo.customStyle;

    if (s && !nativeShadow && s !== style) {
      s['_useCount']--;

      if (s['_useCount'] <= 0 && s.parentNode) {
        s.parentNode.removeChild(s);
      }
    } // apply styling always under native or if we generated style
    // or the cached style is not in document(!)


    if (nativeShadow) {
      // update existing style only under native
      if (styleInfo.customStyle) {
        styleInfo.customStyle.textContent = cssText;
        style = styleInfo.customStyle; // otherwise, if we have css to apply, do so
      } else if (cssText) {
        // apply css after the scope style of the element to help with
        // style precedence rules.
        style = applyCss(cssText, selector, element.shadowRoot, styleInfo.placeholder);
      }
    } else {
      // shady and no cache hit
      if (!style) {
        // apply css after the scope style of the element to help with
        // style precedence rules.
        if (cssText) {
          style = applyCss(cssText, selector, null, styleInfo.placeholder);
        } // shady and cache hit but not in document

      } else if (!style.parentNode) {
        if (IS_IE && cssText.indexOf('@media') > -1) {
          // @media rules may be stale in IE 10 and 11
          // refresh the text content of the style to revalidate them.
          style.textContent = cssText;
        }

        applyStyle(style, null, styleInfo.placeholder);
      }
    } // ensure this style is our custom style and increment its use count.


    if (style) {
      style['_useCount'] = style['_useCount'] || 0; // increment use count if we changed styles

      if (styleInfo.customStyle != style) {
        style['_useCount']++;
      }

      styleInfo.customStyle = style;
    }

    return style;
  }
  /**
   * @param {Element} style
   * @param {Object} properties
   */


  applyCustomStyle(style, properties) {
    let rules = rulesForStyle(
    /** @type {HTMLStyleElement} */
    style);
    let self = this;
    style.textContent = toCssText(rules, function (
    /** StyleNode */
    rule) {
      let css = rule['cssText'] = rule['parsedCssText'];

      if (rule.propertyInfo && rule.propertyInfo.cssText) {
        // remove property assignments
        // so next function isn't confused
        // NOTE: we have 3 categories of css:
        // (1) normal properties,
        // (2) custom property assignments (--foo: red;),
        // (3) custom property usage: border: var(--foo); @apply(--foo);
        // In elements, 1 and 3 are separated for efficiency; here they
        // are not and this makes this case unique.
        css = removeCustomPropAssignment(
        /** @type {string} */
        css); // replace with reified properties, scenario is same as mixin

        rule['cssText'] = self.valueForProperties(css, properties);
      }
    });
  }

}
/**
 * @param {number} n
 * @param {Array<number>} bits
 */


function addToBitMask(n, bits) {
  let o = parseInt(n / 32, 10);
  let v = 1 << n % 32;
  bits[o] = (bits[o] || 0) | v;
}

/* harmony default export */ var style_properties = (new style_properties_StyleProperties());
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-placeholder.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




/** @type {!Object<string, !Node>} */

const placeholderMap = {};
/**
 * @param {string} elementName
 * @return {Node}
 */

function getStylePlaceholder(elementName) {
  return placeholderMap[elementName] || null;
}
/**
 * @param {string} elementName
 */

function ensureStylePlaceholder(elementName) {
  if (!placeholderMap[elementName]) {
    placeholderMap[elementName] = applyStylePlaceHolder(elementName);
  }
}
/**
 * @const {CustomElementRegistry}
 */

const ce = window['customElements'];

if (ce && !nativeShadow && !disableRuntime) {
  /**
   * @const {function(this:CustomElementRegistry, string,function(new:HTMLElement),{extends: string}=)}
   */
  const origDefine = ce['define'];
  /**
   * @param {string} name
   * @param {function(new:HTMLElement)} clazz
   * @param {{extends: string}=} options
   */

  const wrappedDefine = (name, clazz, options) => {
    ensureStylePlaceholder(name);
    origDefine.call(
    /** @type {!CustomElementRegistry} */
    ce, name, clazz, options);
  };

  ce['define'] = wrappedDefine;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/style-cache.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/


class StyleCache {
  constructor(typeMax = 100) {
    // map element name -> [{properties, styleElement, scopeSelector}]
    this.cache = {};
    /** @type {number} */

    this.typeMax = typeMax;
  }

  _validate(cacheEntry, properties, ownPropertyNames) {
    for (let idx = 0; idx < ownPropertyNames.length; idx++) {
      let pn = ownPropertyNames[idx];

      if (cacheEntry.properties[pn] !== properties[pn]) {
        return false;
      }
    }

    return true;
  }

  store(tagname, properties, styleElement, scopeSelector) {
    let list = this.cache[tagname] || [];
    list.push({
      properties,
      styleElement,
      scopeSelector
    });

    if (list.length > this.typeMax) {
      list.shift();
    }

    this.cache[tagname] = list;
  }

  fetch(tagname, properties, ownPropertyNames) {
    let list = this.cache[tagname];

    if (!list) {
      return;
    } // reverse list for most-recent lookups


    for (let idx = list.length - 1; idx >= 0; idx--) {
      let entry = list[idx];

      if (this._validate(entry, properties, ownPropertyNames)) {
        return entry;
      }
    }
  }

}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/document-watcher.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/





let flush = function () {};
/**
 * @param {!Element} element
 * @return {string}
 */

function getClasses(element) {
  if (element.classList && element.classList.value) {
    return element.classList.value;
  } else {
    // NOTE: className is patched to remove scoping classes in ShadyDOM
    // use getAttribute('class') instead, which is unpatched
    return element.getAttribute('class') || '';
  }
}

const scopeRegExp = new RegExp("".concat(style_transformer.SCOPE_NAME, "\\s*([^\\s]*)"));
/**
 * @param {!Element} element
 * @return {string}
 */

function getCurrentScope(element) {
  const match = getClasses(element).match(scopeRegExp);

  if (match) {
    return match[1];
  } else {
    return '';
  }
}
/**
 * @param {!Node} node
 */

function getOwnerScope(node) {
  const ownerRoot = wrap(node).getRootNode();

  if (ownerRoot === node || ownerRoot === node.ownerDocument) {
    return '';
  }

  const host =
  /** @type {!ShadowRoot} */
  ownerRoot.host;

  if (!host) {
    // this may actually be a document fragment
    return '';
  }

  return getIsExtends(host).is;
}
/**
 * @param {!Element} element
 */

function ensureCorrectScope(element) {
  const currentScope = getCurrentScope(element);
  const ownerRoot = wrap(element).getRootNode();

  if (ownerRoot === element) {
    return;
  }

  if (currentScope && ownerRoot === element.ownerDocument) {
    // node was scoped, but now is in document
    style_transformer.domRemoveScope(element, currentScope);
  } else if (ownerRoot instanceof ShadowRoot) {
    const ownerScope = getOwnerScope(element);

    if (ownerScope !== currentScope) {
      // node was scoped, but not by its current owner
      style_transformer.domReplaceScope(element, currentScope, ownerScope);
    }
  }
}
/**
 * @param {!HTMLElement|!HTMLDocument} element
 */

function ensureCorrectSubtreeScoping(element) {
  // find unscoped subtree nodes
  const unscopedNodes = window['ShadyDOM']['nativeMethods']['querySelectorAll'].call(element, ":not(.".concat(style_transformer.SCOPE_NAME, ")"));

  for (let j = 0; j < unscopedNodes.length; j++) {
    // it's possible, during large batch inserts, that nodes that aren't
    // scoped within the current scope were added.
    // To make sure that any unscoped nodes that were inserted in the current batch are correctly styled,
    // query all unscoped nodes and force their style-scope to be applied.
    // This could happen if a sub-element appended an unscoped node in its shadowroot and this function
    // runs on a parent element of the host of that unscoped node:
    // parent-element -> element -> unscoped node
    // Here unscoped node should have the style-scope element, not parent-element.
    const unscopedNode = unscopedNodes[j];
    const scopeForPreviouslyUnscopedNode = getOwnerScope(unscopedNode);

    if (scopeForPreviouslyUnscopedNode) {
      style_transformer.element(unscopedNode, scopeForPreviouslyUnscopedNode);
    }
  }
}
/**
 * @param {HTMLElement} el
 * @return {boolean}
 */

function isElementWithBuiltCss(el) {
  if (el.localName === 'style' || el.localName === 'template') {
    return elementHasBuiltCss(el);
  }

  return false;
}
/**
 * @param {Array<MutationRecord|null>|null} mxns
 */


function handler(mxns) {
  for (let x = 0; x < mxns.length; x++) {
    let mxn = mxns[x];

    if (mxn.target === document.documentElement || mxn.target === document.head) {
      continue;
    }

    for (let i = 0; i < mxn.addedNodes.length; i++) {
      let n = mxn.addedNodes[i];

      if (n.nodeType !== Node.ELEMENT_NODE) {
        continue;
      }

      n =
      /** @type {HTMLElement} */
      n; // eslint-disable-line no-self-assign

      let root = n.getRootNode();
      let currentScope = getCurrentScope(n); // node was scoped, but now is in document
      // If this element has built css, we must not remove scoping as this node
      // will be used as a template or style without re - applying scoping as an optimization

      if (currentScope && root === n.ownerDocument && !isElementWithBuiltCss(n)) {
        style_transformer.domRemoveScope(n, currentScope);
      } else if (root instanceof ShadowRoot) {
        const newScope = getOwnerScope(n); // rescope current node and subtree if necessary

        if (newScope !== currentScope) {
          style_transformer.domReplaceScope(n, currentScope, newScope);
        } // make sure all the subtree elements are scoped correctly


        ensureCorrectSubtreeScoping(n);
      }
    }
  }
} // if native Shadow DOM is being used, or ShadyDOM handles dynamic scoiping, do not activate the MutationObserver


if (!nativeShadow && !(window['ShadyDOM'] && window['ShadyDOM']['handlesDynamicScoping'])) {
  let observer = new MutationObserver(handler);

  let start = node => {
    observer.observe(node, {
      childList: true,
      subtree: true
    });
  };

  let nativeCustomElements = window['customElements'] && !window['customElements']['polyfillWrapFlushCallback']; // need to start immediately with native custom elements
  // TODO(dfreedm): with polyfilled HTMLImports and native custom elements
  // excessive mutations may be observed; this can be optimized via cooperation
  // with the HTMLImports polyfill.

  if (nativeCustomElements) {
    start(document);
  } else {
    let delayedStart = () => {
      start(document.body);
    }; // use polyfill timing if it's available


    if (window['HTMLImports']) {
      window['HTMLImports']['whenReady'](delayedStart); // otherwise push beyond native imports being ready
      // which requires RAF + readystate interactive.
    } else {
      requestAnimationFrame(function () {
        if (document.readyState === 'loading') {
          let listener = function () {
            delayedStart();
            document.removeEventListener('readystatechange', listener);
          };

          document.addEventListener('readystatechange', listener);
        } else {
          delayedStart();
        }
      });
    }
  }

  flush = function () {
    handler(observer.takeRecords());
  };
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/template-map.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/**
 * @const {!Object<string, !HTMLTemplateElement>}
 */

const templateMap = {};
/* harmony default export */ var template_map = (templateMap);
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/apply-shim-utils.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



 // eslint-disable-line no-unused-vars

/*
 * Utilities for handling invalidating apply-shim mixins for a given template.
 *
 * The invalidation strategy involves keeping track of the "current" version of a template's mixins, and updating that count when a mixin is invalidated.
 * The template
 */

/** @const {string} */

const CURRENT_VERSION = '_applyShimCurrentVersion';
/** @const {string} */

const NEXT_VERSION = '_applyShimNextVersion';
/** @const {string} */

const VALIDATING_VERSION = '_applyShimValidatingVersion';
/**
 * @const {Promise<void>}
 */

const promise = Promise.resolve();
/**
 * @param {string} elementName
 */

function invalidate(elementName) {
  let template = template_map[elementName];

  if (template) {
    invalidateTemplate(template);
  }
}
/**
 * This function can be called multiple times to mark a template invalid
 * and signal that the style inside must be regenerated.
 *
 * Use `startValidatingTemplate` to begin an asynchronous validation cycle.
 * During that cycle, call `templateIsValidating` to see if the template must
 * be revalidated
 * @param {HTMLTemplateElement} template
 */

function invalidateTemplate(template) {
  // default the current version to 0
  template[CURRENT_VERSION] = template[CURRENT_VERSION] || 0; // ensure the "validating for" flag exists

  template[VALIDATING_VERSION] = template[VALIDATING_VERSION] || 0; // increment the next version

  template[NEXT_VERSION] = (template[NEXT_VERSION] || 0) + 1;
}
/**
 * @param {string} elementName
 * @return {boolean}
 */

function isValid(elementName) {
  let template = template_map[elementName];

  if (template) {
    return templateIsValid(template);
  }

  return true;
}
/**
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */

function templateIsValid(template) {
  return template[CURRENT_VERSION] === template[NEXT_VERSION];
}
/**
 * @param {string} elementName
 * @return {boolean}
 */

function isValidating(elementName) {
  let template = template_map[elementName];

  if (template) {
    return templateIsValidating(template);
  }

  return false;
}
/**
 * Returns true if the template is currently invalid and `startValidating` has been called since the last invalidation.
 * If false, the template must be validated.
 * @param {HTMLTemplateElement} template
 * @return {boolean}
 */

function templateIsValidating(template) {
  return !templateIsValid(template) && template[VALIDATING_VERSION] === template[NEXT_VERSION];
}
/**
 * the template is marked as `validating` for one microtask so that all instances
 * found in the tree crawl of `applyStyle` will update themselves,
 * but the template will only be updated once.
 * @param {string} elementName
*/

function startValidating(elementName) {
  let template = template_map[elementName];
  startValidatingTemplate(template);
}
/**
 * Begin an asynchronous invalidation cycle.
 * This should be called after every validation of a template
 *
 * After one microtask, the template will be marked as valid until the next call to `invalidateTemplate`
 * @param {HTMLTemplateElement} template
 */

function startValidatingTemplate(template) {
  // remember that the current "next version" is the reason for this validation cycle
  template[VALIDATING_VERSION] = template[NEXT_VERSION]; // however, there only needs to be one async task to clear the counters

  if (!template._validating) {
    template._validating = true;
    promise.then(function () {
      // sync the current version to let future invalidations cause a refresh cycle
      template[CURRENT_VERSION] = template[NEXT_VERSION];
      template._validating = false;
    });
  }
}
/**
 * @return {boolean}
 */

function elementsAreInvalid() {
  for (let elementName in template_map) {
    let template = template_map[elementName];

    if (!templateIsValid(template)) {
      return true;
    }
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/common-utils.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @param {Element} element
 * @param {Object=} properties
 */

function updateNativeProperties(element, properties) {
  // remove previous properties
  for (let p in properties) {
    // NOTE: for bc with shim, don't apply null values.
    if (p === null) {
      element.style.removeProperty(p);
    } else {
      element.style.setProperty(p, properties[p]);
    }
  }
}
/**
 * @param {Element} element
 * @param {string} property
 * @return {string}
 */

function getComputedStyleValue(element, property) {
  /**
   * @const {string}
   */
  const value = window.getComputedStyle(element).getPropertyValue(property);

  if (!value) {
    return '';
  } else {
    return value.trim();
  }
}
/**
 * return true if `cssText` contains a mixin definition or consumption
 * @param {string} cssText
 * @return {boolean}
 */

function detectMixin(cssText) {
  const has = MIXIN_MATCH.test(cssText) || VAR_ASSIGN.test(cssText); // reset state of the regexes

  MIXIN_MATCH.lastIndex = 0;
  VAR_ASSIGN.lastIndex = 0;
  return has;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/document-wait.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/

/** @type {Promise<void>} */

let readyPromise = null;
/** @type {?function(?function())} */

let whenReady = window['HTMLImports'] && window['HTMLImports']['whenReady'] || null;
/** @type {function()} */

let resolveFn;
/**
 * @param {?function()} callback
 */

function documentWait(callback) {
  requestAnimationFrame(function () {
    if (whenReady) {
      whenReady(callback);
    } else {
      if (!readyPromise) {
        readyPromise = new Promise(resolve => {
          resolveFn = resolve;
        });

        if (document.readyState === 'complete') {
          resolveFn();
        } else {
          document.addEventListener('readystatechange', () => {
            if (document.readyState === 'complete') {
              resolveFn();
            }
          });
        }
      }

      readyPromise.then(function () {
        callback && callback();
      });
    }
  });
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/custom-style-interface.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/



/**
 * @typedef {HTMLStyleElement | {getStyle: function():HTMLStyleElement}}
 */

let CustomStyleProvider;
const SEEN_MARKER = '__seenByShadyCSS';
const CACHED_STYLE = '__shadyCSSCachedStyle';
/** @type {?function(!HTMLStyleElement)} */

let transformFn = null;
/** @type {?function()} */

let validateFn = null;
/**
This interface is provided to add document-level <style> elements to ShadyCSS for processing.
These styles must be processed by ShadyCSS to simulate ShadowRoot upper-bound encapsulation from outside styles
In addition, these styles may also need to be processed for @apply rules and CSS Custom Properties

To add document-level styles to ShadyCSS, one can call `ShadyCSS.addDocumentStyle(styleElement)` or `ShadyCSS.addDocumentStyle({getStyle: () => styleElement})`

In addition, if the process used to discover document-level styles can be synchronously flushed, one should set `ShadyCSS.documentStyleFlush`.
This function will be called when calculating styles.

An example usage of the document-level styling api can be found in `examples/document-style-lib.js`

@unrestricted
*/

class custom_style_interface_CustomStyleInterface {
  constructor() {
    /** @type {!Array<!CustomStyleProvider>} */
    this['customStyles'] = [];
    this['enqueued'] = false; // NOTE(dfreedm): use quotes here to prevent closure inlining to `function(){}`;

    documentWait(() => {
      if (window['ShadyCSS']['flushCustomStyles']) {
        window['ShadyCSS']['flushCustomStyles']();
      }
    });
  }
  /**
   * Queue a validation for new custom styles to batch style recalculations
   */


  enqueueDocumentValidation() {
    if (this['enqueued'] || !validateFn) {
      return;
    }

    this['enqueued'] = true;
    documentWait(validateFn);
  }
  /**
   * @param {!HTMLStyleElement} style
   */


  addCustomStyle(style) {
    if (!style[SEEN_MARKER]) {
      style[SEEN_MARKER] = true;
      this['customStyles'].push(style);
      this.enqueueDocumentValidation();
    }
  }
  /**
   * @param {!CustomStyleProvider} customStyle
   * @return {HTMLStyleElement}
   */


  getStyleForCustomStyle(customStyle) {
    if (customStyle[CACHED_STYLE]) {
      return customStyle[CACHED_STYLE];
    }

    let style;

    if (customStyle['getStyle']) {
      style = customStyle['getStyle']();
    } else {
      style = customStyle;
    }

    return style;
  }
  /**
   * @return {!Array<!CustomStyleProvider>}
   */


  processStyles() {
    const cs = this['customStyles'];

    for (let i = 0; i < cs.length; i++) {
      const customStyle = cs[i];

      if (customStyle[CACHED_STYLE]) {
        continue;
      }

      const style = this.getStyleForCustomStyle(customStyle);

      if (style) {
        // HTMLImports polyfill may have cloned the style into the main document,
        // which is referenced with __appliedElement.
        const styleToTransform =
        /** @type {!HTMLStyleElement} */
        style['__appliedElement'] || style;

        if (transformFn) {
          transformFn(styleToTransform);
        }

        customStyle[CACHED_STYLE] = styleToTransform;
      }
    }

    return cs;
  }

}
/* eslint-disable no-self-assign */

custom_style_interface_CustomStyleInterface.prototype['addCustomStyle'] = custom_style_interface_CustomStyleInterface.prototype.addCustomStyle;
custom_style_interface_CustomStyleInterface.prototype['getStyleForCustomStyle'] = custom_style_interface_CustomStyleInterface.prototype.getStyleForCustomStyle;
custom_style_interface_CustomStyleInterface.prototype['processStyles'] = custom_style_interface_CustomStyleInterface.prototype.processStyles;
/* eslint-enable no-self-assign */

Object.defineProperties(custom_style_interface_CustomStyleInterface.prototype, {
  'transformCallback': {
    /** @return {?function(!HTMLStyleElement)} */
    get() {
      return transformFn;
    },

    /** @param {?function(!HTMLStyleElement)} fn */
    set(fn) {
      transformFn = fn;
    }

  },
  'validateCallback': {
    /** @return {?function()} */
    get() {
      return validateFn;
    },

    /**
     * @param {?function()} fn
     * @this {CustomStyleInterface}
     */
    set(fn) {
      let needsEnqueue = false;

      if (!validateFn) {
        needsEnqueue = true;
      }

      validateFn = fn;

      if (needsEnqueue) {
        this.enqueueDocumentValidation();
      }
    }

  }
});
/** @typedef {{
 * customStyles: !Array<!CustomStyleProvider>,
 * addCustomStyle: function(!CustomStyleProvider),
 * getStyleForCustomStyle: function(!CustomStyleProvider): HTMLStyleElement,
 * findStyles: function(),
 * transformCallback: ?function(!HTMLStyleElement),
 * validateCallback: ?function()
 * }}
 */

const CustomStyleInterfaceInterface = {};
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/src/scoping-shim.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/














 // eslint-disable-line no-unused-vars

/** @type {!Object<string, string>} */

const adoptedCssTextMap = {};
/**
 * @const {StyleCache}
 */

const styleCache = new StyleCache();
class scoping_shim_ScopingShim {
  constructor() {
    this._scopeCounter = {};
    this._documentOwner =
    /** @type {!HTMLElement} */
    document.documentElement;
    let ast = new StyleNode();
    ast['rules'] = [];
    this._documentOwnerStyleInfo = StyleInfo.set(this._documentOwner, new StyleInfo(ast));
    this._elementsHaveApplied = false;
    /** @type {?Object} */

    this._applyShim = null;
    /** @type {?CustomStyleInterfaceInterface} */

    this._customStyleInterface = null;
  }

  flush() {
    flush();
  }

  _generateScopeSelector(name) {
    let id = this._scopeCounter[name] = (this._scopeCounter[name] || 0) + 1;
    return "".concat(name, "-").concat(id);
  }

  getStyleAst(style) {
    return rulesForStyle(style);
  }

  styleAstToString(ast) {
    return toCssText(ast);
  }

  _gatherStyles(template) {
    return gatherStyleText(template.content);
  }
  /**
   * Prepare the styling and template for the given element type
   *
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} typeExtension
   */


  prepareTemplate(template, elementName, typeExtension) {
    this.prepareTemplateDom(template, elementName);
    this.prepareTemplateStyles(template, elementName, typeExtension);
  }
  /**
   * Prepare styling for the given element type
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} typeExtension
   */


  prepareTemplateStyles(template, elementName, typeExtension) {
    if (template._prepared || disableRuntime) {
      return;
    } // style placeholders are only used when ShadyDOM is active


    if (!nativeShadow) {
      ensureStylePlaceholder(elementName);
    }

    template._prepared = true;
    template.name = elementName;
    template.extends = typeExtension;
    template_map[elementName] = template;
    let cssBuild = getCssBuild(template);
    const optimalBuild = isOptimalCssBuild(cssBuild);
    let info = {
      is: elementName,
      extends: typeExtension
    };
    let cssText = this._gatherStyles(template) + (adoptedCssTextMap[elementName] || ''); // check if the styling has mixin definitions or uses

    this._ensure();

    if (!optimalBuild) {
      let hasMixins = !cssBuild && detectMixin(cssText);
      let ast = parse(cssText); // only run the applyshim transforms if there is a mixin involved

      if (hasMixins && nativeCssVariables && this._applyShim) {
        this._applyShim['transformRules'](ast, elementName);
      }

      template['_styleAst'] = ast;
    }

    let ownPropertyNames = [];

    if (!nativeCssVariables) {
      ownPropertyNames = style_properties.decorateStyles(template['_styleAst']);
    }

    if (!ownPropertyNames.length || nativeCssVariables) {
      let root = nativeShadow ? template.content : null;
      let placeholder = getStylePlaceholder(elementName);

      let style = this._generateStaticStyle(info, template['_styleAst'], root, placeholder, cssBuild, optimalBuild ? cssText : '');

      template._style = style;
    }

    template._ownPropertyNames = ownPropertyNames;
  }
  /**
   * @param {!Array<string>} cssTextArray
   * @param {string} elementName
   */


  prepareAdoptedCssText(cssTextArray, elementName) {
    adoptedCssTextMap[elementName] = cssTextArray.join(' ');
  }
  /**
   * Prepare template for the given element type
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */


  prepareTemplateDom(template, elementName) {
    if (disableRuntime) {
      return;
    }

    const cssBuild = getCssBuild(template);

    if (!nativeShadow && cssBuild !== 'shady' && !template._domPrepared) {
      template._domPrepared = true;
      style_transformer.domAddScope(template.content, elementName);
    }
  }
  /**
   * @param {!{is: string, extends: (string|undefined)}} info
   * @param {!StyleNode} rules
   * @param {DocumentFragment} shadowroot
   * @param {Node} placeholder
   * @param {string} cssBuild
   * @param {string=} cssText
   * @return {?HTMLStyleElement}
   */


  _generateStaticStyle(info, rules, shadowroot, placeholder, cssBuild, cssText) {
    cssText = style_transformer.elementStyles(info, rules, null, cssBuild, cssText);

    if (cssText.length) {
      return applyCss(cssText, info.is, shadowroot, placeholder);
    }

    return null;
  }

  _prepareHost(host) {
    const {
      is,
      typeExtension
    } = getIsExtends(host);
    const placeholder = getStylePlaceholder(is);
    const template = template_map[is];

    if (!template) {
      return;
    }

    const ast = template['_styleAst'];
    const ownStylePropertyNames = template._ownPropertyNames;
    const cssBuild = getCssBuild(template);
    const styleInfo = new StyleInfo(ast, placeholder, ownStylePropertyNames, is, typeExtension, cssBuild);
    StyleInfo.set(host, styleInfo);
    return styleInfo;
  }

  _ensureApplyShim() {
    if (this._applyShim) {
      return;
    } else if (window.ShadyCSS && window.ShadyCSS.ApplyShim) {
      this._applyShim =
      /** @type {!Object} */
      window.ShadyCSS.ApplyShim;
      this._applyShim['invalidCallback'] = invalidate;
    }
  }

  _ensureCustomStyleInterface() {
    if (this._customStyleInterface) {
      return;
    } else if (window.ShadyCSS && window.ShadyCSS.CustomStyleInterface) {
      this._customStyleInterface =
      /** @type {!CustomStyleInterfaceInterface} */
      window.ShadyCSS.CustomStyleInterface;
      /** @type {function(!HTMLStyleElement)} */

      this._customStyleInterface['transformCallback'] = style => {
        this.transformCustomStyleForDocument(style);
      };

      this._customStyleInterface['validateCallback'] = () => {
        requestAnimationFrame(() => {
          if (this._customStyleInterface['enqueued'] || this._elementsHaveApplied) {
            this.flushCustomStyles();
          }
        });
      };
    }
  }

  _ensure() {
    this._ensureApplyShim();

    this._ensureCustomStyleInterface();
  }
  /**
   * Flush and apply custom styles to document
   */


  flushCustomStyles() {
    if (disableRuntime) {
      return;
    }

    this._ensure();

    if (!this._customStyleInterface) {
      return;
    }

    let customStyles = this._customStyleInterface['processStyles'](); // early return if custom-styles don't need validation


    if (!this._customStyleInterface['enqueued']) {
      return;
    } // bail if custom styles are built optimally


    if (isOptimalCssBuild(this._documentOwnerStyleInfo.cssBuild)) {
      return;
    }

    if (!nativeCssVariables) {
      this._updateProperties(this._documentOwner, this._documentOwnerStyleInfo);

      this._applyCustomStyles(customStyles);

      if (this._elementsHaveApplied) {
        // if custom elements have upgraded and there are no native css variables, we must recalculate the whole tree
        this.styleDocument();
      }
    } else if (!this._documentOwnerStyleInfo.cssBuild) {
      this._revalidateCustomStyleApplyShim(customStyles);
    }

    this._customStyleInterface['enqueued'] = false;
  }
  /**
   * Apply styles for the given element
   *
   * @param {!HTMLElement} host
   * @param {Object=} overrideProps
   */


  styleElement(host, overrideProps) {
    if (disableRuntime) {
      if (overrideProps) {
        if (!StyleInfo.get(host)) {
          StyleInfo.set(host, new StyleInfo(null));
        }

        const styleInfo =
        /** @type {!StyleInfo} */
        StyleInfo.get(host);

        this._mixOverrideStyleProps(styleInfo, overrideProps);

        this.styleElementNativeVariables(host, styleInfo);
      }

      return;
    }

    const styleInfo = StyleInfo.get(host) || this._prepareHost(host); // if there is no style info at this point, bail


    if (!styleInfo) {
      return;
    } // Only trip the `elementsHaveApplied` flag if a node other that the root document has `applyStyle` called


    if (!this._isRootOwner(host)) {
      this._elementsHaveApplied = true;
    }

    if (overrideProps) {
      this._mixOverrideStyleProps(styleInfo, overrideProps);
    }

    if (!nativeCssVariables) {
      this.styleElementShimVariables(host, styleInfo);
    } else {
      this.styleElementNativeVariables(host, styleInfo);
    }
  }
  /**
   * @param {!StyleInfo} styleInfo
   * @param {Object} overrideProps
   */


  _mixOverrideStyleProps(styleInfo, overrideProps) {
    styleInfo.overrideStyleProperties = styleInfo.overrideStyleProperties || {};
    Object.assign(styleInfo.overrideStyleProperties, overrideProps);
  }
  /**
   * @param {!HTMLElement} host
   * @param {!StyleInfo} styleInfo
   */


  styleElementShimVariables(host, styleInfo) {
    this.flush();

    this._updateProperties(host, styleInfo);

    if (styleInfo.ownStylePropertyNames && styleInfo.ownStylePropertyNames.length) {
      this._applyStyleProperties(host, styleInfo);
    }
  }
  /**
   * @param {!HTMLElement} host
   * @param {!StyleInfo} styleInfo
   */


  styleElementNativeVariables(host, styleInfo) {
    const {
      is
    } = getIsExtends(host);

    if (styleInfo.overrideStyleProperties) {
      updateNativeProperties(host, styleInfo.overrideStyleProperties);
    }

    const template = template_map[is]; // bail early if there is no shadowroot for this element

    if (!template && !this._isRootOwner(host)) {
      return;
    } // bail early if the template was built with polymer-css-build


    if (template && elementHasBuiltCss(template)) {
      return;
    }

    if (template && template._style && !templateIsValid(template)) {
      // update template
      if (!templateIsValidating(template)) {
        this._ensure();

        this._applyShim && this._applyShim['transformRules'](template['_styleAst'], is);
        template._style.textContent = style_transformer.elementStyles(host, styleInfo.styleRules);
        startValidatingTemplate(template);
      } // update instance if native shadowdom


      if (nativeShadow) {
        let root = host.shadowRoot;

        if (root) {
          let style = root.querySelector('style');

          if (style) {
            style.textContent = style_transformer.elementStyles(host, styleInfo.styleRules);
          }
        }
      }

      styleInfo.styleRules = template['_styleAst'];
    }
  }

  _styleOwnerForNode(node) {
    let root = wrap(node).getRootNode();
    let host = root.host;

    if (host) {
      if (StyleInfo.get(host) || this._prepareHost(host)) {
        return host;
      } else {
        return this._styleOwnerForNode(host);
      }
    }

    return this._documentOwner;
  }

  _isRootOwner(node) {
    return node === this._documentOwner;
  }

  _applyStyleProperties(host, styleInfo) {
    let is = getIsExtends(host).is;
    let cacheEntry = styleCache.fetch(is, styleInfo.styleProperties, styleInfo.ownStylePropertyNames);
    let cachedScopeSelector = cacheEntry && cacheEntry.scopeSelector;
    let cachedStyle = cacheEntry ? cacheEntry.styleElement : null;
    let oldScopeSelector = styleInfo.scopeSelector; // only generate new scope if cached style is not found

    styleInfo.scopeSelector = cachedScopeSelector || this._generateScopeSelector(is);
    let style = style_properties.applyElementStyle(host, styleInfo.styleProperties, styleInfo.scopeSelector, cachedStyle);

    if (!nativeShadow) {
      style_properties.applyElementScopeSelector(host, styleInfo.scopeSelector, oldScopeSelector);
    }

    if (!cacheEntry) {
      styleCache.store(is, styleInfo.styleProperties, style, styleInfo.scopeSelector);
    }

    return style;
  }

  _updateProperties(host, styleInfo) {
    let owner = this._styleOwnerForNode(host);

    let ownerStyleInfo = StyleInfo.get(owner);
    let ownerProperties = ownerStyleInfo.styleProperties; // style owner has not updated properties yet
    // go up the chain and force property update,
    // except if the owner is the document

    if (owner !== this._documentOwner && !ownerProperties) {
      this._updateProperties(owner, ownerStyleInfo);

      ownerProperties = ownerStyleInfo.styleProperties;
    }

    let props = Object.create(ownerProperties || null);
    let hostAndRootProps = style_properties.hostAndRootPropertiesForScope(host, styleInfo.styleRules, styleInfo.cssBuild);
    let propertyData = style_properties.propertyDataFromStyles(ownerStyleInfo.styleRules, host);
    let propertiesMatchingHost = propertyData.properties;
    Object.assign(props, hostAndRootProps.hostProps, propertiesMatchingHost, hostAndRootProps.rootProps);

    this._mixinOverrideStyles(props, styleInfo.overrideStyleProperties);

    style_properties.reify(props);
    styleInfo.styleProperties = props;
  }

  _mixinOverrideStyles(props, overrides) {
    for (let p in overrides) {
      let v = overrides[p]; // skip override props if they are not truthy or 0
      // in order to fall back to inherited values

      if (v || v === 0) {
        props[p] = v;
      }
    }
  }
  /**
   * Update styles of the whole document
   *
   * @param {Object=} properties
   */


  styleDocument(properties) {
    this.styleSubtree(this._documentOwner, properties);
  }
  /**
   * Update styles of a subtree
   *
   * @param {!HTMLElement} host
   * @param {Object=} properties
   */


  styleSubtree(host, properties) {
    const wrappedHost = wrap(host);
    let root = wrappedHost.shadowRoot;

    if (root || this._isRootOwner(host)) {
      this.styleElement(host, properties);
    } // process the shadowdom children of `host`


    let shadowChildren = root && (
    /** @type {!ParentNode} */
    root.children || root.childNodes);

    if (shadowChildren) {
      for (let i = 0; i < shadowChildren.length; i++) {
        let c =
        /** @type {!HTMLElement} */
        shadowChildren[i];
        this.styleSubtree(c);
      }
    } else {
      // process the lightdom children of `host`
      let children = wrappedHost.children || wrappedHost.childNodes;

      if (children) {
        for (let i = 0; i < children.length; i++) {
          let c =
          /** @type {!HTMLElement} */
          children[i];
          this.styleSubtree(c);
        }
      }
    }
  }
  /* Custom Style operations */


  _revalidateCustomStyleApplyShim(customStyles) {
    for (let i = 0; i < customStyles.length; i++) {
      let c = customStyles[i];

      let s = this._customStyleInterface['getStyleForCustomStyle'](c);

      if (s) {
        this._revalidateApplyShim(s);
      }
    }
  }

  _applyCustomStyles(customStyles) {
    for (let i = 0; i < customStyles.length; i++) {
      let c = customStyles[i];

      let s = this._customStyleInterface['getStyleForCustomStyle'](c);

      if (s) {
        style_properties.applyCustomStyle(s, this._documentOwnerStyleInfo.styleProperties);
      }
    }
  }

  transformCustomStyleForDocument(style) {
    const cssBuild = getCssBuild(style);

    if (cssBuild !== this._documentOwnerStyleInfo.cssBuild) {
      this._documentOwnerStyleInfo.cssBuild = cssBuild;
    }

    if (isOptimalCssBuild(cssBuild)) {
      return;
    }

    let ast = rulesForStyle(style);
    forEachRule(ast, rule => {
      if (nativeShadow) {
        style_transformer.normalizeRootSelector(rule);
      } else {
        style_transformer.documentRule(rule);
      }

      if (nativeCssVariables && cssBuild === '') {
        this._ensure();

        this._applyShim && this._applyShim['transformRule'](rule);
      }
    });

    if (nativeCssVariables) {
      style.textContent = toCssText(ast);
    } else {
      this._documentOwnerStyleInfo.styleRules['rules'].push(ast);
    }
  }

  _revalidateApplyShim(style) {
    if (nativeCssVariables && this._applyShim) {
      let ast = rulesForStyle(style);

      this._ensure();

      this._applyShim['transformRules'](ast);

      style.textContent = toCssText(ast);
    }
  }

  getComputedStyleValue(element, property) {
    let value;

    if (!nativeCssVariables) {
      // element is either a style host, or an ancestor of a style host
      let styleInfo = StyleInfo.get(element) || StyleInfo.get(this._styleOwnerForNode(element));
      value = styleInfo.styleProperties[property];
    } // fall back to the property value from the computed styling


    value = value || window.getComputedStyle(element).getPropertyValue(property); // trim whitespace that can come after the `:` in css
    // example: padding: 2px -> " 2px"

    return value ? value.trim() : '';
  } // given an element and a classString, replaces
  // the element's class with the provided classString and adds
  // any necessary ShadyCSS static and property based scoping selectors


  setElementClass(element, classString) {
    let root = wrap(element).getRootNode();
    let classes = classString ? classString.split(/\s/) : [];
    let scopeName = root.host && root.host.localName; // If no scope, try to discover scope name from existing class.
    // This can occur if, for example, a template stamped element that
    // has been scoped is manipulated when not in a root.

    if (!scopeName) {
      var classAttr = element.getAttribute('class');

      if (classAttr) {
        let k$ = classAttr.split(/\s/);

        for (let i = 0; i < k$.length; i++) {
          if (k$[i] === style_transformer.SCOPE_NAME) {
            scopeName = k$[i + 1];
            break;
          }
        }
      }
    }

    if (scopeName) {
      classes.push(style_transformer.SCOPE_NAME, scopeName);
    }

    if (!nativeCssVariables) {
      let styleInfo = StyleInfo.get(element);

      if (styleInfo && styleInfo.scopeSelector) {
        classes.push(style_properties.XSCOPE_NAME, styleInfo.scopeSelector);
      }
    }

    setElementClassRaw(element, classes.join(' '));
  }

  _styleInfoForNode(node) {
    return StyleInfo.get(node);
  }
  /**
   * @param {!Element} node
   * @param {string} scope
   */


  scopeNode(node, scope) {
    style_transformer.element(node, scope);
  }
  /**
   * @param {!Element} node
   * @param {string} scope
   */


  unscopeNode(node, scope) {
    style_transformer.element(node, scope, true);
  }
  /**
   * @param {!Node} node
   * @return {string}
   */


  scopeForNode(node) {
    return getOwnerScope(node);
  }
  /**
   * @param {!Element} node
   * @return {string}
   */


  currentScopeForNode(node) {
    return getCurrentScope(node);
  }

}
/* exports */

/* eslint-disable no-self-assign */

scoping_shim_ScopingShim.prototype['flush'] = scoping_shim_ScopingShim.prototype.flush;
scoping_shim_ScopingShim.prototype['prepareTemplate'] = scoping_shim_ScopingShim.prototype.prepareTemplate;
scoping_shim_ScopingShim.prototype['styleElement'] = scoping_shim_ScopingShim.prototype.styleElement;
scoping_shim_ScopingShim.prototype['styleDocument'] = scoping_shim_ScopingShim.prototype.styleDocument;
scoping_shim_ScopingShim.prototype['styleSubtree'] = scoping_shim_ScopingShim.prototype.styleSubtree;
scoping_shim_ScopingShim.prototype['getComputedStyleValue'] = scoping_shim_ScopingShim.prototype.getComputedStyleValue;
scoping_shim_ScopingShim.prototype['setElementClass'] = scoping_shim_ScopingShim.prototype.setElementClass;
scoping_shim_ScopingShim.prototype['_styleInfoForNode'] = scoping_shim_ScopingShim.prototype._styleInfoForNode;
scoping_shim_ScopingShim.prototype['transformCustomStyleForDocument'] = scoping_shim_ScopingShim.prototype.transformCustomStyleForDocument;
scoping_shim_ScopingShim.prototype['getStyleAst'] = scoping_shim_ScopingShim.prototype.getStyleAst;
scoping_shim_ScopingShim.prototype['styleAstToString'] = scoping_shim_ScopingShim.prototype.styleAstToString;
scoping_shim_ScopingShim.prototype['flushCustomStyles'] = scoping_shim_ScopingShim.prototype.flushCustomStyles;
scoping_shim_ScopingShim.prototype['scopeNode'] = scoping_shim_ScopingShim.prototype.scopeNode;
scoping_shim_ScopingShim.prototype['unscopeNode'] = scoping_shim_ScopingShim.prototype.unscopeNode;
scoping_shim_ScopingShim.prototype['scopeForNode'] = scoping_shim_ScopingShim.prototype.scopeForNode;
scoping_shim_ScopingShim.prototype['currentScopeForNode'] = scoping_shim_ScopingShim.prototype.currentScopeForNode;
scoping_shim_ScopingShim.prototype['prepareAdoptedCssText'] = scoping_shim_ScopingShim.prototype.prepareAdoptedCssText;
/* eslint-enable no-self-assign */

Object.defineProperties(scoping_shim_ScopingShim.prototype, {
  'nativeShadow': {
    get() {
      return nativeShadow;
    }

  },
  'nativeCss': {
    get() {
      return nativeCssVariables;
    }

  }
});
// CONCATENATED MODULE: ./node_modules/@webcomponents/shadycss/entrypoints/scoping-shim.js
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/




/** @const {ScopingShim} */

const scopingShim = new scoping_shim_ScopingShim();
let ApplyShim, scoping_shim_CustomStyleInterface;

if (window['ShadyCSS']) {
  ApplyShim = window['ShadyCSS']['ApplyShim'];
  scoping_shim_CustomStyleInterface = window['ShadyCSS']['CustomStyleInterface'];
}

window.ShadyCSS = {
  ScopingShim: scopingShim,

  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} elementExtends
   */
  prepareTemplate(template, elementName, elementExtends) {
    scopingShim.flushCustomStyles();
    scopingShim.prepareTemplate(template, elementName, elementExtends);
  },

  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   */
  prepareTemplateDom(template, elementName) {
    scopingShim.prepareTemplateDom(template, elementName);
  },

  /**
   * @param {!HTMLTemplateElement} template
   * @param {string} elementName
   * @param {string=} elementExtends
   */
  prepareTemplateStyles(template, elementName, elementExtends) {
    scopingShim.flushCustomStyles();
    scopingShim.prepareTemplateStyles(template, elementName, elementExtends);
  },

  /**
   * @param {!HTMLElement} element
   * @param {Object=} properties
   */
  styleSubtree(element, properties) {
    scopingShim.flushCustomStyles();
    scopingShim.styleSubtree(element, properties);
  },

  /**
   * @param {!HTMLElement} element
   */
  styleElement(element) {
    scopingShim.flushCustomStyles();
    scopingShim.styleElement(element);
  },

  /**
   * @param {Object=} properties
   */
  styleDocument(properties) {
    scopingShim.flushCustomStyles();
    scopingShim.styleDocument(properties);
  },

  flushCustomStyles() {
    scopingShim.flushCustomStyles();
  },

  /**
   * @param {Element} element
   * @param {string} property
   * @return {string}
   */
  getComputedStyleValue(element, property) {
    return scopingShim.getComputedStyleValue(element, property);
  },

  nativeCss: nativeCssVariables,
  nativeShadow: nativeShadow,
  cssBuild: style_settings_cssBuild,
  disableRuntime: disableRuntime
};

if (ApplyShim) {
  window.ShadyCSS.ApplyShim = ApplyShim;
}

if (scoping_shim_CustomStyleInterface) {
  window.ShadyCSS.CustomStyleInterface = scoping_shim_CustomStyleInterface;
}

/***/ }),

/***/ 47:
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Utilities.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const reservedTagList = new Set(['annotation-xml', 'color-profile', 'font-face', 'font-face-src', 'font-face-uri', 'font-face-format', 'font-face-name', 'missing-glyph']);
/**
 * @param {string} localName
 * @returns {boolean}
 */

function isValidCustomElementName(localName) {
  const reserved = reservedTagList.has(localName);
  const validForm = /^[a-z][.0-9_a-z]*-[\-.0-9_a-z]*$/.test(localName);
  return !reserved && validForm;
}
/**
 * @param {!Node} node
 * @return {boolean}
 */

function Utilities_isConnected(node) {
  // Use `Node#isConnected`, if defined.
  const nativeValue = node.isConnected;

  if (nativeValue !== undefined) {
    return nativeValue;
  }
  /** @type {?Node|undefined} */


  let current = node;

  while (current && !(current.__CE_isImportDocument || current instanceof Document)) {
    current = current.parentNode || (window.ShadowRoot && current instanceof ShadowRoot ? current.host : undefined);
  }

  return !!(current && (current.__CE_isImportDocument || current instanceof Document));
}
/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */

function nextSiblingOrAncestorSibling(root, start) {
  let node = start;

  while (node && node !== root && !node.nextSibling) {
    node = node.parentNode;
  }

  return !node || node === root ? null : node.nextSibling;
}
/**
 * @param {!Node} root
 * @param {!Node} start
 * @return {?Node}
 */


function nextNode(root, start) {
  return start.firstChild ? start.firstChild : nextSiblingOrAncestorSibling(root, start);
}
/**
 * @param {!Node} root
 * @param {!function(!Element)} callback
 * @param {!Set<Node>=} visitedImports
 */


function walkDeepDescendantElements(root, callback, visitedImports = new Set()) {
  let node = root;

  while (node) {
    if (node.nodeType === Node.ELEMENT_NODE) {
      const element =
      /** @type {!Element} */
      node;
      callback(element);
      const localName = element.localName;

      if (localName === 'link' && element.getAttribute('rel') === 'import') {
        // If this import (polyfilled or not) has it's root node available,
        // walk it.
        const importNode =
        /** @type {!Node} */
        element.import;

        if (importNode instanceof Node && !visitedImports.has(importNode)) {
          // Prevent multiple walks of the same import root.
          visitedImports.add(importNode);

          for (let child = importNode.firstChild; child; child = child.nextSibling) {
            walkDeepDescendantElements(child, callback, visitedImports);
          }
        } // Ignore descendants of import links to prevent attempting to walk the
        // elements created by the HTML Imports polyfill that we just walked
        // above.


        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      } else if (localName === 'template') {
        // Ignore descendants of templates. There shouldn't be any descendants
        // because they will be moved into `.content` during construction in
        // browsers that support template but, in case they exist and are still
        // waiting to be moved by a polyfill, they will be ignored.
        node = nextSiblingOrAncestorSibling(root, element);
        continue;
      } // Walk shadow roots.


      const shadowRoot = element.__CE_shadowRoot;

      if (shadowRoot) {
        for (let child = shadowRoot.firstChild; child; child = child.nextSibling) {
          walkDeepDescendantElements(child, callback, visitedImports);
        }
      }
    }

    node = nextNode(root, node);
  }
}
/**
 * Used to suppress Closure's "Modifying the prototype is only allowed if the
 * constructor is in the same scope" warning without using
 * `@suppress {newCheckTypes, duplicate}` because `newCheckTypes` is too broad.
 *
 * @param {!Object} destination
 * @param {string} name
 * @param {*} value
 */

function setPropertyUnchecked(destination, name, value) {
  destination[name] = value;
}
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/CustomElementState.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * @enum {number}
 */
const CustomElementState = {
  custom: 1,
  failed: 2
};
/* harmony default export */ var src_CustomElementState = (CustomElementState);
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/CustomElementInternals.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */


class CustomElementInternals_CustomElementInternals {
  constructor() {
    /** @type {!Map<string, !CustomElementDefinition>} */
    this._localNameToDefinition = new Map();
    /** @type {!Map<!Function, !CustomElementDefinition>} */

    this._constructorToDefinition = new Map();
    /** @type {!Array<!function(!Node)>} */

    this._patchesNode = [];
    /** @type {!Array<!function(!Element)>} */

    this._patchesElement = [];
    /** @type {boolean} */

    this._hasPatches = false;
  }
  /**
   * @param {string} localName
   * @param {!CustomElementDefinition} definition
   */


  setDefinition(localName, definition) {
    this._localNameToDefinition.set(localName, definition);

    this._constructorToDefinition.set(definition.constructorFunction, definition);
  }
  /**
   * @param {string} localName
   * @return {!CustomElementDefinition|undefined}
   */


  localNameToDefinition(localName) {
    return this._localNameToDefinition.get(localName);
  }
  /**
   * @param {!Function} constructor
   * @return {!CustomElementDefinition|undefined}
   */


  constructorToDefinition(constructor) {
    return this._constructorToDefinition.get(constructor);
  }
  /**
   * @param {!function(!Node)} patch
   */


  addNodePatch(patch) {
    this._hasPatches = true;

    this._patchesNode.push(patch);
  }
  /**
   * @param {!function(!Element)} patch
   */


  addElementPatch(patch) {
    this._hasPatches = true;

    this._patchesElement.push(patch);
  }
  /**
   * @param {!Node} node
   */


  patchTree(node) {
    if (!this._hasPatches) return;
    walkDeepDescendantElements(node, element => this.patchElement(element));
  }
  /**
   * @param {!Node} node
   */


  patchNode(node) {
    if (!this._hasPatches) return;
    if (node.__CE_patched) return;
    node.__CE_patched = true;

    for (let i = 0; i < this._patchesNode.length; i++) {
      this._patchesNode[i](node);
    }
  }
  /**
   * @param {!Element} element
   */


  patchElement(element) {
    if (!this._hasPatches) return;
    if (element.__CE_patched) return;
    element.__CE_patched = true;

    for (let i = 0; i < this._patchesNode.length; i++) {
      this._patchesNode[i](element);
    }

    for (let i = 0; i < this._patchesElement.length; i++) {
      this._patchesElement[i](element);
    }
  }
  /**
   * @param {!Node} root
   */


  connectTree(root) {
    const elements = [];
    walkDeepDescendantElements(root, element => elements.push(element));

    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];

      if (element.__CE_state === src_CustomElementState.custom) {
        this.connectedCallback(element);
      } else {
        this.upgradeElement(element);
      }
    }
  }
  /**
   * @param {!Node} root
   */


  disconnectTree(root) {
    const elements = [];
    walkDeepDescendantElements(root, element => elements.push(element));

    for (let i = 0; i < elements.length; i++) {
      const element = elements[i];

      if (element.__CE_state === src_CustomElementState.custom) {
        this.disconnectedCallback(element);
      }
    }
  }
  /**
   * Upgrades all uncustomized custom elements at and below a root node for
   * which there is a definition. When custom element reaction callbacks are
   * assumed to be called synchronously (which, by the current DOM / HTML spec
   * definitions, they are *not*), callbacks for both elements customized
   * synchronously by the parser and elements being upgraded occur in the same
   * relative order.
   *
   * NOTE: This function, when used to simulate the construction of a tree that
   * is already created but not customized (i.e. by the parser), does *not*
   * prevent the element from reading the 'final' (true) state of the tree. For
   * example, the element, during truly synchronous parsing / construction would
   * see that it contains no children as they have not yet been inserted.
   * However, this function does not modify the tree, the element will
   * (incorrectly) have children. Additionally, self-modification restrictions
   * for custom element constructors imposed by the DOM spec are *not* enforced.
   *
   *
   * The following nested list shows the steps extending down from the HTML
   * spec's parsing section that cause elements to be synchronously created and
   * upgraded:
   *
   * The "in body" insertion mode:
   * https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
   * - Switch on token:
   *   .. other cases ..
   *   -> Any other start tag
   *      - [Insert an HTML element](below) for the token.
   *
   * Insert an HTML element:
   * https://html.spec.whatwg.org/multipage/syntax.html#insert-an-html-element
   * - Insert a foreign element for the token in the HTML namespace:
   *   https://html.spec.whatwg.org/multipage/syntax.html#insert-a-foreign-element
   *   - Create an element for a token:
   *     https://html.spec.whatwg.org/multipage/syntax.html#create-an-element-for-the-token
   *     - Will execute script flag is true?
   *       - (Element queue pushed to the custom element reactions stack.)
   *     - Create an element:
   *       https://dom.spec.whatwg.org/#concept-create-element
   *       - Sync CE flag is true?
   *         - Constructor called.
   *         - Self-modification restrictions enforced.
   *       - Sync CE flag is false?
   *         - (Upgrade reaction enqueued.)
   *     - Attributes appended to element.
   *       (`attributeChangedCallback` reactions enqueued.)
   *     - Will execute script flag is true?
   *       - (Element queue popped from the custom element reactions stack.
   *         Reactions in the popped stack are invoked.)
   *   - (Element queue pushed to the custom element reactions stack.)
   *   - Insert the element:
   *     https://dom.spec.whatwg.org/#concept-node-insert
   *     - Shadow-including descendants are connected. During parsing
   *       construction, there are no shadow-*excluding* descendants.
   *       However, the constructor may have validly attached a shadow
   *       tree to itself and added descendants to that shadow tree.
   *       (`connectedCallback` reactions enqueued.)
   *   - (Element queue popped from the custom element reactions stack.
   *     Reactions in the popped stack are invoked.)
   *
   * @param {!Node} root
   * @param {{
   *   visitedImports: (!Set<!Node>|undefined),
   *   upgrade: (!function(!Element)|undefined),
   * }=} options
   */


  patchAndUpgradeTree(root, options = {}) {
    const visitedImports = options.visitedImports || new Set();

    const upgrade = options.upgrade || (element => this.upgradeElement(element));

    const elements = [];

    const gatherElements = element => {
      if (element.localName === 'link' && element.getAttribute('rel') === 'import') {
        // The HTML Imports polyfill sets a descendant element of the link to
        // the `import` property, specifically this is *not* a Document.
        const importNode =
        /** @type {?Node} */
        element.import;

        if (importNode instanceof Node) {
          importNode.__CE_isImportDocument = true; // Connected links are associated with the registry.

          importNode.__CE_hasRegistry = true;
        }

        if (importNode && importNode.readyState === 'complete') {
          importNode.__CE_documentLoadHandled = true;
        } else {
          // If this link's import root is not available, its contents can't be
          // walked. Wait for 'load' and walk it when it's ready.
          element.addEventListener('load', () => {
            const importNode =
            /** @type {!Node} */
            element.import;
            if (importNode.__CE_documentLoadHandled) return;
            importNode.__CE_documentLoadHandled = true; // Clone the `visitedImports` set that was populated sync during
            // the `patchAndUpgradeTree` call that caused this 'load' handler to
            // be added. Then, remove *this* link's import node so that we can
            // walk that import again, even if it was partially walked later
            // during the same `patchAndUpgradeTree` call.

            const clonedVisitedImports = new Set(visitedImports);
            clonedVisitedImports.delete(importNode);
            this.patchAndUpgradeTree(importNode, {
              visitedImports: clonedVisitedImports,
              upgrade
            });
          });
        }
      } else {
        elements.push(element);
      }
    }; // `walkDeepDescendantElements` populates (and internally checks against)
    // `visitedImports` when traversing a loaded import.


    walkDeepDescendantElements(root, gatherElements, visitedImports);

    if (this._hasPatches) {
      for (let i = 0; i < elements.length; i++) {
        this.patchElement(elements[i]);
      }
    }

    for (let i = 0; i < elements.length; i++) {
      upgrade(elements[i]);
    }
  }
  /**
   * @param {!HTMLElement} element
   */


  upgradeElement(element) {
    const currentState = element.__CE_state;
    if (currentState !== undefined) return; // Prevent elements created in documents without a browsing context from
    // upgrading.
    //
    // https://html.spec.whatwg.org/multipage/custom-elements.html#look-up-a-custom-element-definition
    //   "If document does not have a browsing context, return null."
    //
    // https://html.spec.whatwg.org/multipage/window-object.html#dom-document-defaultview
    //   "The defaultView IDL attribute of the Document interface, on getting,
    //   must return this Document's browsing context's WindowProxy object, if
    //   this Document has an associated browsing context, or null otherwise."

    const ownerDocument = element.ownerDocument;
    if (!ownerDocument.defaultView && !(ownerDocument.__CE_isImportDocument && ownerDocument.__CE_hasRegistry)) return;
    const definition = this.localNameToDefinition(element.localName);
    if (!definition) return;
    definition.constructionStack.push(element);
    const constructor = definition.constructorFunction;

    try {
      try {
        let result = new constructor();

        if (result !== element) {
          throw new Error('The custom element constructor did not produce the element being upgraded.');
        }
      } finally {
        definition.constructionStack.pop();
      }
    } catch (e) {
      element.__CE_state = src_CustomElementState.failed;
      throw e;
    }

    element.__CE_state = src_CustomElementState.custom;
    element.__CE_definition = definition;

    if (definition.attributeChangedCallback) {
      const observedAttributes = definition.observedAttributes;

      for (let i = 0; i < observedAttributes.length; i++) {
        const name = observedAttributes[i];
        const value = element.getAttribute(name);

        if (value !== null) {
          this.attributeChangedCallback(element, name, null, value, null);
        }
      }
    }

    if (Utilities_isConnected(element)) {
      this.connectedCallback(element);
    }
  }
  /**
   * @param {!Element} element
   */


  connectedCallback(element) {
    const definition = element.__CE_definition;

    if (definition.connectedCallback) {
      definition.connectedCallback.call(element);
    }
  }
  /**
   * @param {!Element} element
   */


  disconnectedCallback(element) {
    const definition = element.__CE_definition;

    if (definition.disconnectedCallback) {
      definition.disconnectedCallback.call(element);
    }
  }
  /**
   * @param {!Element} element
   * @param {string} name
   * @param {?string} oldValue
   * @param {?string} newValue
   * @param {?string} namespace
   */


  attributeChangedCallback(element, name, oldValue, newValue, namespace) {
    const definition = element.__CE_definition;

    if (definition.attributeChangedCallback && definition.observedAttributes.indexOf(name) > -1) {
      definition.attributeChangedCallback.call(element, name, oldValue, newValue, namespace);
    }
  }

}
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/DocumentConstructionObserver.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

class DocumentConstructionObserver {
  constructor(internals, doc) {
    /**
     * @type {!CustomElementInternals}
     */
    this._internals = internals;
    /**
     * @type {!Document}
     */

    this._document = doc;
    /**
     * @type {MutationObserver|undefined}
     */

    this._observer = undefined; // Simulate tree construction for all currently accessible nodes in the
    // document.

    this._internals.patchAndUpgradeTree(this._document);

    if (this._document.readyState === 'loading') {
      this._observer = new MutationObserver(this._handleMutations.bind(this)); // Nodes created by the parser are given to the observer *before* the next
      // task runs. Inline scripts are run in a new task. This means that the
      // observer will be able to handle the newly parsed nodes before the inline
      // script is run.

      this._observer.observe(this._document, {
        childList: true,
        subtree: true
      });
    }
  }

  disconnect() {
    if (this._observer) {
      this._observer.disconnect();
    }
  }
  /**
   * @param {!Array<!MutationRecord>} mutations
   */


  _handleMutations(mutations) {
    // Once the document's `readyState` is 'interactive' or 'complete', all new
    // nodes created within that document will be the result of script and
    // should be handled by patching.
    const readyState = this._document.readyState;

    if (readyState === 'interactive' || readyState === 'complete') {
      this.disconnect();
    }

    for (let i = 0; i < mutations.length; i++) {
      const addedNodes = mutations[i].addedNodes;

      for (let j = 0; j < addedNodes.length; j++) {
        const node = addedNodes[j];

        this._internals.patchAndUpgradeTree(node);
      }
    }
  }

}
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Deferred.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * @template T
 */
class Deferred {
  constructor() {
    /**
     * @private
     * @type {T|undefined}
     */
    this._value = undefined;
    /**
     * @private
     * @type {Function|undefined}
     */

    this._resolve = undefined;
    /**
     * @private
     * @type {!Promise<T>}
     */

    this._promise = new Promise(resolve => {
      this._resolve = resolve;

      if (this._value) {
        resolve(this._value);
      }
    });
  }
  /**
   * @param {T} value
   */


  resolve(value) {
    if (this._value) {
      throw new Error('Already resolved.');
    }

    this._value = value;

    if (this._resolve) {
      this._resolve(value);
    }
  }
  /**
   * @return {!Promise<T>}
   */


  toPromise() {
    return this._promise;
  }

}
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/CustomElementRegistry.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */




/**
 * @unrestricted
 */

class CustomElementRegistry_CustomElementRegistry {
  /**
   * @param {!CustomElementInternals} internals
   */
  constructor(internals) {
    /**
     * @private
     * @type {boolean}
     */
    this._elementDefinitionIsRunning = false;
    /**
     * @private
     * @type {!CustomElementInternals}
     */

    this._internals = internals;
    /**
     * @private
     * @type {!Map<string, !Deferred<undefined>>}
     */

    this._whenDefinedDeferred = new Map();
    /**
     * The default flush callback triggers the document walk synchronously.
     * @private
     * @type {!Function}
     */

    this._flushCallback = fn => fn();
    /**
     * @private
     * @type {boolean}
     */


    this._flushPending = false;
    /**
     * @private
     * @type {!Array<!CustomElementDefinition>}
     */

    this._pendingDefinitions = [];
    /**
     * @private
     * @type {!DocumentConstructionObserver}
     */

    this._documentConstructionObserver = new DocumentConstructionObserver(internals, document);
  }
  /**
   * @param {string} localName
   * @param {!Function} constructor
   */


  define(localName, constructor) {
    if (!(constructor instanceof Function)) {
      throw new TypeError('Custom element constructors must be functions.');
    }

    if (!isValidCustomElementName(localName)) {
      throw new SyntaxError("The element name '".concat(localName, "' is not valid."));
    }

    if (this._internals.localNameToDefinition(localName)) {
      throw new Error("A custom element with name '".concat(localName, "' has already been defined."));
    }

    if (this._elementDefinitionIsRunning) {
      throw new Error('A custom element is already being defined.');
    }

    this._elementDefinitionIsRunning = true;
    let connectedCallback;
    let disconnectedCallback;
    let adoptedCallback;
    let attributeChangedCallback;
    let observedAttributes;

    try {
      /** @type {!Object} */
      const prototype = constructor.prototype;

      if (!(prototype instanceof Object)) {
        throw new TypeError('The custom element constructor\'s prototype is not an object.');
      }

      function getCallback(name) {
        const callbackValue = prototype[name];

        if (callbackValue !== undefined && !(callbackValue instanceof Function)) {
          throw new Error("The '".concat(name, "' callback must be a function."));
        }

        return callbackValue;
      }

      connectedCallback = getCallback('connectedCallback');
      disconnectedCallback = getCallback('disconnectedCallback');
      adoptedCallback = getCallback('adoptedCallback');
      attributeChangedCallback = getCallback('attributeChangedCallback');
      observedAttributes = constructor['observedAttributes'] || [];
    } catch (e) {
      return;
    } finally {
      this._elementDefinitionIsRunning = false;
    }

    const definition = {
      localName,
      constructorFunction: constructor,
      connectedCallback,
      disconnectedCallback,
      adoptedCallback,
      attributeChangedCallback,
      observedAttributes,
      constructionStack: []
    };

    this._internals.setDefinition(localName, definition);

    this._pendingDefinitions.push(definition); // If we've already called the flush callback and it hasn't called back yet,
    // don't call it again.


    if (!this._flushPending) {
      this._flushPending = true;

      this._flushCallback(() => this._flush());
    }
  }

  upgrade(element) {
    this._internals.patchAndUpgradeTree(element);
  }

  _flush() {
    // If no new definitions were defined, don't attempt to flush. This could
    // happen if a flush callback keeps the function it is given and calls it
    // multiple times.
    if (this._flushPending === false) return;
    this._flushPending = false;
    const pendingDefinitions = this._pendingDefinitions;
    /**
     * Unupgraded elements with definitions that were defined *before* the last
     * flush, in document order.
     * @type {!Array<!HTMLElement>}
     */

    const elementsWithStableDefinitions = [];
    /**
     * A map from `localName`s of definitions that were defined *after* the last
     * flush to unupgraded elements matching that definition, in document order.
     * @type {!Map<string, !Array<!HTMLElement>>}
     */

    const elementsWithPendingDefinitions = new Map();

    for (let i = 0; i < pendingDefinitions.length; i++) {
      elementsWithPendingDefinitions.set(pendingDefinitions[i].localName, []);
    }

    this._internals.patchAndUpgradeTree(document, {
      upgrade: element => {
        // Ignore the element if it has already upgraded or failed to upgrade.
        if (element.__CE_state !== undefined) return;
        const localName = element.localName; // If there is an applicable pending definition for the element, add the
        // element to the list of elements to be upgraded with that definition.

        const pendingElements = elementsWithPendingDefinitions.get(localName);

        if (pendingElements) {
          pendingElements.push(element); // If there is *any other* applicable definition for the element, add it
          // to the list of elements with stable definitions that need to be upgraded.
        } else if (this._internals.localNameToDefinition(localName)) {
          elementsWithStableDefinitions.push(element);
        }
      }
    }); // Upgrade elements with 'stable' definitions first.


    for (let i = 0; i < elementsWithStableDefinitions.length; i++) {
      this._internals.upgradeElement(elementsWithStableDefinitions[i]);
    } // Upgrade elements with 'pending' definitions in the order they were defined.


    while (pendingDefinitions.length > 0) {
      const definition = pendingDefinitions.shift();
      const localName = definition.localName; // Attempt to upgrade all applicable elements.

      const pendingUpgradableElements = elementsWithPendingDefinitions.get(definition.localName);

      for (let i = 0; i < pendingUpgradableElements.length; i++) {
        this._internals.upgradeElement(pendingUpgradableElements[i]);
      } // Resolve any promises created by `whenDefined` for the definition.


      const deferred = this._whenDefinedDeferred.get(localName);

      if (deferred) {
        deferred.resolve(undefined);
      }
    }
  }
  /**
   * @param {string} localName
   * @return {Function|undefined}
   */


  get(localName) {
    const definition = this._internals.localNameToDefinition(localName);

    if (definition) {
      return definition.constructorFunction;
    }

    return undefined;
  }
  /**
   * @param {string} localName
   * @return {!Promise<undefined>}
   */


  whenDefined(localName) {
    if (!isValidCustomElementName(localName)) {
      return Promise.reject(new SyntaxError("'".concat(localName, "' is not a valid custom element name.")));
    }

    const prior = this._whenDefinedDeferred.get(localName);

    if (prior) {
      return prior.toPromise();
    }

    const deferred = new Deferred();

    this._whenDefinedDeferred.set(localName, deferred);

    const definition = this._internals.localNameToDefinition(localName); // Resolve immediately only if the given local name has a definition *and*
    // the full document walk to upgrade elements with that local name has
    // already happened.


    if (definition && !this._pendingDefinitions.some(d => d.localName === localName)) {
      deferred.resolve(undefined);
    }

    return deferred.toPromise();
  }

  polyfillWrapFlushCallback(outer) {
    this._documentConstructionObserver.disconnect();

    const inner = this._flushCallback;

    this._flushCallback = flush => outer(() => inner(flush));
  }

} // Closure compiler exports.

window['CustomElementRegistry'] = CustomElementRegistry_CustomElementRegistry;
CustomElementRegistry_CustomElementRegistry.prototype['define'] = CustomElementRegistry_CustomElementRegistry.prototype.define;
CustomElementRegistry_CustomElementRegistry.prototype['upgrade'] = CustomElementRegistry_CustomElementRegistry.prototype.upgrade;
CustomElementRegistry_CustomElementRegistry.prototype['get'] = CustomElementRegistry_CustomElementRegistry.prototype.get;
CustomElementRegistry_CustomElementRegistry.prototype['whenDefined'] = CustomElementRegistry_CustomElementRegistry.prototype.whenDefined;
CustomElementRegistry_CustomElementRegistry.prototype['polyfillWrapFlushCallback'] = CustomElementRegistry_CustomElementRegistry.prototype.polyfillWrapFlushCallback;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Native.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
/* harmony default export */ var Native = ({
  Document_createElement: window.Document.prototype.createElement,
  Document_createElementNS: window.Document.prototype.createElementNS,
  Document_importNode: window.Document.prototype.importNode,
  Document_prepend: window.Document.prototype['prepend'],
  Document_append: window.Document.prototype['append'],
  DocumentFragment_prepend: window.DocumentFragment.prototype['prepend'],
  DocumentFragment_append: window.DocumentFragment.prototype['append'],
  Node_cloneNode: window.Node.prototype.cloneNode,
  Node_appendChild: window.Node.prototype.appendChild,
  Node_insertBefore: window.Node.prototype.insertBefore,
  Node_removeChild: window.Node.prototype.removeChild,
  Node_replaceChild: window.Node.prototype.replaceChild,
  Node_textContent: Object.getOwnPropertyDescriptor(window.Node.prototype, 'textContent'),
  Element_attachShadow: window.Element.prototype['attachShadow'],
  Element_innerHTML: Object.getOwnPropertyDescriptor(window.Element.prototype, 'innerHTML'),
  Element_getAttribute: window.Element.prototype.getAttribute,
  Element_setAttribute: window.Element.prototype.setAttribute,
  Element_removeAttribute: window.Element.prototype.removeAttribute,
  Element_getAttributeNS: window.Element.prototype.getAttributeNS,
  Element_setAttributeNS: window.Element.prototype.setAttributeNS,
  Element_removeAttributeNS: window.Element.prototype.removeAttributeNS,
  Element_insertAdjacentElement: window.Element.prototype['insertAdjacentElement'],
  Element_insertAdjacentHTML: window.Element.prototype['insertAdjacentHTML'],
  Element_prepend: window.Element.prototype['prepend'],
  Element_append: window.Element.prototype['append'],
  Element_before: window.Element.prototype['before'],
  Element_after: window.Element.prototype['after'],
  Element_replaceWith: window.Element.prototype['replaceWith'],
  Element_remove: window.Element.prototype['remove'],
  HTMLElement: window.HTMLElement,
  HTMLElement_innerHTML: Object.getOwnPropertyDescriptor(window.HTMLElement.prototype, 'innerHTML'),
  HTMLElement_insertAdjacentElement: window.HTMLElement.prototype['insertAdjacentElement'],
  HTMLElement_insertAdjacentHTML: window.HTMLElement.prototype['insertAdjacentHTML']
});
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/AlreadyConstructedMarker.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */

/**
 * This class exists only to work around Closure's lack of a way to describe
 * singletons. It represents the 'already constructed marker' used in custom
 * element construction stacks.
 *
 * https://html.spec.whatwg.org/#concept-already-constructed-marker
 * @extends AlreadyConstructedMarkerType
 */
class AlreadyConstructedMarker {}

/* harmony default export */ var src_AlreadyConstructedMarker = (new AlreadyConstructedMarker());
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/HTMLElement.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */




/**
 * @param {!CustomElementInternals} internals
 */

/* harmony default export */ var Patch_HTMLElement = (function (internals) {
  window['HTMLElement'] = function () {
    /**
     * @type {function(new: HTMLElement): !HTMLElement}
     */
    function HTMLElement() {
      // This should really be `new.target` but `new.target` can't be emulated
      // in ES5. Assuming the user keeps the default value of the constructor's
      // prototype's `constructor` property, this is equivalent.
      const constructor =
      /** @type {!Function} */
      this.constructor;
      const definition = internals.constructorToDefinition(constructor);

      if (!definition) {
        throw new Error('The custom element being constructed was not registered with `customElements`.');
      }

      const constructionStack = definition.constructionStack;

      if (constructionStack.length === 0) {
        const element =
        /** @type {!HTMLElement} */
        Native.Document_createElement.call(document, definition.localName);
        Object.setPrototypeOf(element, constructor.prototype);
        element.__CE_state = src_CustomElementState.custom;
        element.__CE_definition = definition;
        internals.patchElement(element);
        return element;
      }

      const lastIndex = constructionStack.length - 1;
      const element = constructionStack[lastIndex];

      if (element === src_AlreadyConstructedMarker) {
        throw new Error('The HTMLElement constructor was either called reentrantly for this constructor or called multiple times.');
      }

      const toConstructElement =
      /** @type {!HTMLElement} */
      element;
      constructionStack[lastIndex] = src_AlreadyConstructedMarker;
      Object.setPrototypeOf(toConstructElement, constructor.prototype);
      internals.patchElement(toConstructElement);
      return toConstructElement;
    }

    HTMLElement.prototype = Native.HTMLElement.prototype; // Safari 9 has `writable: false` on the propertyDescriptor
    // Make it writable so that TypeScript can patch up the
    // constructor in the ES5 compiled code.

    Object.defineProperty(HTMLElement.prototype, 'constructor', {
      writable: true,
      configurable: true,
      enumerable: false,
      value: HTMLElement
    });
    return HTMLElement;
  }();
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Interface/ParentNode.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */


/**
 * @typedef {{
 *   prepend: !function(...(!Node|string)),
  *  append: !function(...(!Node|string)),
 * }}
 */

let ParentNodeNativeMethods;
/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ParentNodeNativeMethods} builtIn
 */

/* harmony default export */ var ParentNode = (function (internals, destination, builtIn) {
  /**
   * @param {!function(...(!Node|string))} builtInMethod
   * @return {!function(...(!Node|string))}
   */
  function appendPrependPatch(builtInMethod) {
    return (
      /** @this {!Node} */
      function (...nodes) {
        /**
         * A copy of `nodes`, with any DocumentFragment replaced by its children.
         * @type {!Array<!Node>}
         */
        const flattenedNodes = [];
        /**
         * Elements in `nodes` that were connected before this call.
         * @type {!Array<!Node>}
         */

        const connectedElements = [];

        for (var i = 0; i < nodes.length; i++) {
          const node = nodes[i];

          if (node instanceof Element && Utilities_isConnected(node)) {
            connectedElements.push(node);
          }

          if (node instanceof DocumentFragment) {
            for (let child = node.firstChild; child; child = child.nextSibling) {
              flattenedNodes.push(child);
            }
          } else {
            flattenedNodes.push(node);
          }
        }

        builtInMethod.apply(this, nodes);

        for (let i = 0; i < connectedElements.length; i++) {
          internals.disconnectTree(connectedElements[i]);
        }

        if (Utilities_isConnected(this)) {
          for (let i = 0; i < flattenedNodes.length; i++) {
            const node = flattenedNodes[i];

            if (node instanceof Element) {
              internals.connectTree(node);
            }
          }
        }
      }
    );
  }

  if (builtIn.prepend !== undefined) {
    setPropertyUnchecked(destination, 'prepend', appendPrependPatch(builtIn.prepend));
  }

  if (builtIn.append !== undefined) {
    setPropertyUnchecked(destination, 'append', appendPrependPatch(builtIn.append));
  }
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Document.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */




/**
 * @param {!CustomElementInternals} internals
 */

/* harmony default export */ var Patch_Document = (function (internals) {
  setPropertyUnchecked(Document.prototype, 'createElement',
  /**
   * @this {Document}
   * @param {string} localName
   * @return {!Element}
   */
  function (localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry) {
      const definition = internals.localNameToDefinition(localName);

      if (definition) {
        return new definition.constructorFunction();
      }
    }

    const result =
    /** @type {!Element} */
    Native.Document_createElement.call(this, localName);
    internals.patchElement(result);
    return result;
  });
  setPropertyUnchecked(Document.prototype, 'importNode',
  /**
   * @this {Document}
   * @param {!Node} node
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (node, deep) {
    const clone =
    /** @type {!Node} */
    Native.Document_importNode.call(this, node, !!deep); // Only create custom elements if this document is associated with the registry.

    if (!this.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }

    return clone;
  });
  const NS_HTML = "http://www.w3.org/1999/xhtml";
  setPropertyUnchecked(Document.prototype, 'createElementNS',
  /**
   * @this {Document}
   * @param {?string} namespace
   * @param {string} localName
   * @return {!Element}
   */
  function (namespace, localName) {
    // Only create custom elements if this document is associated with the registry.
    if (this.__CE_hasRegistry && (namespace === null || namespace === NS_HTML)) {
      const definition = internals.localNameToDefinition(localName);

      if (definition) {
        return new definition.constructorFunction();
      }
    }

    const result =
    /** @type {!Element} */
    Native.Document_createElementNS.call(this, namespace, localName);
    internals.patchElement(result);
    return result;
  });
  ParentNode(internals, Document.prototype, {
    prepend: Native.Document_prepend,
    append: Native.Document_append
  });
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/DocumentFragment.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */



/**
 * @param {!CustomElementInternals} internals
 */

/* harmony default export */ var Patch_DocumentFragment = (function (internals) {
  ParentNode(internals, DocumentFragment.prototype, {
    prepend: Native.DocumentFragment_prepend,
    append: Native.DocumentFragment_append
  });
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Node.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */



/**
 * @param {!CustomElementInternals} internals
 */

/* harmony default export */ var Patch_Node = (function (internals) {
  // `Node#nodeValue` is implemented on `Attr`.
  // `Node#textContent` is implemented on `Attr`, `Element`.
  setPropertyUnchecked(Node.prototype, 'insertBefore',
  /**
   * @this {Node}
   * @param {!Node} node
   * @param {?Node} refNode
   * @return {!Node}
   */
  function (node, refNode) {
    if (node instanceof DocumentFragment) {
      const insertedNodes = Array.prototype.slice.apply(node.childNodes);
      const nativeResult = Native.Node_insertBefore.call(this, node, refNode); // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (Utilities_isConnected(this)) {
        for (let i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return nativeResult;
    }

    const nodeWasConnected = Utilities_isConnected(node);
    const nativeResult = Native.Node_insertBefore.call(this, node, refNode);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (Utilities_isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });
  setPropertyUnchecked(Node.prototype, 'appendChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    if (node instanceof DocumentFragment) {
      const insertedNodes = Array.prototype.slice.apply(node.childNodes);
      const nativeResult = Native.Node_appendChild.call(this, node); // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (Utilities_isConnected(this)) {
        for (let i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return nativeResult;
    }

    const nodeWasConnected = Utilities_isConnected(node);
    const nativeResult = Native.Node_appendChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    if (Utilities_isConnected(this)) {
      internals.connectTree(node);
    }

    return nativeResult;
  });
  setPropertyUnchecked(Node.prototype, 'cloneNode',
  /**
   * @this {Node}
   * @param {boolean=} deep
   * @return {!Node}
   */
  function (deep) {
    const clone = Native.Node_cloneNode.call(this, !!deep); // Only create custom elements if this element's owner document is
    // associated with the registry.

    if (!this.ownerDocument.__CE_hasRegistry) {
      internals.patchTree(clone);
    } else {
      internals.patchAndUpgradeTree(clone);
    }

    return clone;
  });
  setPropertyUnchecked(Node.prototype, 'removeChild',
  /**
   * @this {Node}
   * @param {!Node} node
   * @return {!Node}
   */
  function (node) {
    const nodeWasConnected = Utilities_isConnected(node);
    const nativeResult = Native.Node_removeChild.call(this, node);

    if (nodeWasConnected) {
      internals.disconnectTree(node);
    }

    return nativeResult;
  });
  setPropertyUnchecked(Node.prototype, 'replaceChild',
  /**
   * @this {Node}
   * @param {!Node} nodeToInsert
   * @param {!Node} nodeToRemove
   * @return {!Node}
   */
  function (nodeToInsert, nodeToRemove) {
    if (nodeToInsert instanceof DocumentFragment) {
      const insertedNodes = Array.prototype.slice.apply(nodeToInsert.childNodes);
      const nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove); // DocumentFragments can't be connected, so `disconnectTree` will never
      // need to be called on a DocumentFragment's children after inserting it.

      if (Utilities_isConnected(this)) {
        internals.disconnectTree(nodeToRemove);

        for (let i = 0; i < insertedNodes.length; i++) {
          internals.connectTree(insertedNodes[i]);
        }
      }

      return nativeResult;
    }

    const nodeToInsertWasConnected = Utilities_isConnected(nodeToInsert);
    const nativeResult = Native.Node_replaceChild.call(this, nodeToInsert, nodeToRemove);
    const thisIsConnected = Utilities_isConnected(this);

    if (thisIsConnected) {
      internals.disconnectTree(nodeToRemove);
    }

    if (nodeToInsertWasConnected) {
      internals.disconnectTree(nodeToInsert);
    }

    if (thisIsConnected) {
      internals.connectTree(nodeToInsert);
    }

    return nativeResult;
  });

  function patch_textContent(destination, baseDescriptor) {
    Object.defineProperty(destination, 'textContent', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set:
      /** @this {Node} */
      function (assignedValue) {
        // If this is a text node then there are no nodes to disconnect.
        if (this.nodeType === Node.TEXT_NODE) {
          baseDescriptor.set.call(this, assignedValue);
          return;
        }

        let removedNodes = undefined; // Checking for `firstChild` is faster than reading `childNodes.length`
        // to compare with 0.

        if (this.firstChild) {
          // Using `childNodes` is faster than `children`, even though we only
          // care about elements.
          const childNodes = this.childNodes;
          const childNodesLength = childNodes.length;

          if (childNodesLength > 0 && Utilities_isConnected(this)) {
            // Copying an array by iterating is faster than using slice.
            removedNodes = new Array(childNodesLength);

            for (let i = 0; i < childNodesLength; i++) {
              removedNodes[i] = childNodes[i];
            }
          }
        }

        baseDescriptor.set.call(this, assignedValue);

        if (removedNodes) {
          for (let i = 0; i < removedNodes.length; i++) {
            internals.disconnectTree(removedNodes[i]);
          }
        }
      }
    });
  }

  if (Native.Node_textContent && Native.Node_textContent.get) {
    patch_textContent(Node.prototype, Native.Node_textContent);
  } else {
    internals.addNodePatch(function (element) {
      patch_textContent(element, {
        enumerable: true,
        configurable: true,
        // NOTE: This implementation of the `textContent` getter assumes that
        // text nodes' `textContent` getter will not be patched.
        get:
        /** @this {Node} */
        function () {
          /** @type {!Array<string>} */
          const parts = [];

          for (let i = 0; i < this.childNodes.length; i++) {
            const childNode = this.childNodes[i];

            if (childNode.nodeType === Node.COMMENT_NODE) {
              continue;
            }

            parts.push(childNode.textContent);
          }

          return parts.join('');
        },
        set:
        /** @this {Node} */
        function (assignedValue) {
          while (this.firstChild) {
            Native.Node_removeChild.call(this, this.firstChild);
          } // `textContent = null | undefined | ''` does not result in
          // a TextNode childNode


          if (assignedValue != null && assignedValue !== '') {
            Native.Node_appendChild.call(this, document.createTextNode(assignedValue));
          }
        }
      });
    });
  }
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Interface/ChildNode.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */


/**
 * @typedef {{
 *   before: !function(...(!Node|string)),
 *   after: !function(...(!Node|string)),
 *   replaceWith: !function(...(!Node|string)),
 *   remove: !function(),
 * }}
 */

let ChildNodeNativeMethods;
/**
 * @param {!CustomElementInternals} internals
 * @param {!Object} destination
 * @param {!ChildNodeNativeMethods} builtIn
 */

/* harmony default export */ var ChildNode = (function (internals, destination, builtIn) {
  /**
   * @param {!function(...(!Node|string))} builtInMethod
   * @return {!function(...(!Node|string))}
   */
  function beforeAfterPatch(builtInMethod) {
    return (
      /** @this {!Node} */
      function (...nodes) {
        /**
         * A copy of `nodes`, with any DocumentFragment replaced by its children.
         * @type {!Array<!Node>}
         */
        const flattenedNodes = [];
        /**
         * Elements in `nodes` that were connected before this call.
         * @type {!Array<!Node>}
         */

        const connectedElements = [];

        for (var i = 0; i < nodes.length; i++) {
          const node = nodes[i];

          if (node instanceof Element && Utilities_isConnected(node)) {
            connectedElements.push(node);
          }

          if (node instanceof DocumentFragment) {
            for (let child = node.firstChild; child; child = child.nextSibling) {
              flattenedNodes.push(child);
            }
          } else {
            flattenedNodes.push(node);
          }
        }

        builtInMethod.apply(this, nodes);

        for (let i = 0; i < connectedElements.length; i++) {
          internals.disconnectTree(connectedElements[i]);
        }

        if (Utilities_isConnected(this)) {
          for (let i = 0; i < flattenedNodes.length; i++) {
            const node = flattenedNodes[i];

            if (node instanceof Element) {
              internals.connectTree(node);
            }
          }
        }
      }
    );
  }

  if (builtIn.before !== undefined) {
    setPropertyUnchecked(destination, 'before', beforeAfterPatch(builtIn.before));
  }

  if (builtIn.before !== undefined) {
    setPropertyUnchecked(destination, 'after', beforeAfterPatch(builtIn.after));
  }

  if (builtIn.replaceWith !== undefined) {
    setPropertyUnchecked(destination, 'replaceWith',
    /**
     * @param {...(!Node|string)} nodes
     * @this {!Node}
     */
    function (...nodes) {
      /**
       * A copy of `nodes`, with any DocumentFragment replaced by its children.
       * @type {!Array<!Node|string>}
       */
      const flattenedNodes = [];
      /**
       * Elements in `nodes` that were connected before this call.
       * @type {!Array<!Node>}
       */

      const connectedElements = [];

      for (var i = 0; i < nodes.length; i++) {
        const node = nodes[i];

        if (node instanceof Element && Utilities_isConnected(node)) {
          connectedElements.push(node);
        }

        if (node instanceof DocumentFragment) {
          for (let child = node.firstChild; child; child = child.nextSibling) {
            flattenedNodes.push(child);
          }
        } else {
          flattenedNodes.push(node);
        }
      }

      const wasConnected = Utilities_isConnected(this);
      builtIn.replaceWith.apply(this, nodes);

      for (let i = 0; i < connectedElements.length; i++) {
        internals.disconnectTree(connectedElements[i]);
      }

      if (wasConnected) {
        internals.disconnectTree(this);

        for (let i = 0; i < flattenedNodes.length; i++) {
          const node = flattenedNodes[i];

          if (node instanceof Element) {
            internals.connectTree(node);
          }
        }
      }
    });
  }

  if (builtIn.remove !== undefined) {
    setPropertyUnchecked(destination, 'remove',
    /** @this {!Node} */
    function () {
      const wasConnected = Utilities_isConnected(this);
      builtIn.remove.call(this);

      if (wasConnected) {
        internals.disconnectTree(this);
      }
    });
  }
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/Patch/Element.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */






/**
 * @param {!CustomElementInternals} internals
 */

/* harmony default export */ var Patch_Element = (function (internals) {
  if (Native.Element_attachShadow) {
    setPropertyUnchecked(Element.prototype, 'attachShadow',
    /**
     * @this {Element}
     * @param {!{mode: string}} init
     * @return {ShadowRoot}
     */
    function (init) {
      const shadowRoot = Native.Element_attachShadow.call(this, init);
      internals.patchNode(shadowRoot);
      this.__CE_shadowRoot = shadowRoot;
      return shadowRoot;
    });
  }

  function patch_innerHTML(destination, baseDescriptor) {
    Object.defineProperty(destination, 'innerHTML', {
      enumerable: baseDescriptor.enumerable,
      configurable: true,
      get: baseDescriptor.get,
      set:
      /** @this {Element} */
      function (htmlString) {
        const isConnected = Utilities_isConnected(this); // NOTE: In IE11, when using the native `innerHTML` setter, all nodes
        // that were previously descendants of the context element have all of
        // their children removed as part of the set - the entire subtree is
        // 'disassembled'. This work around walks the subtree *before* using the
        // native setter.

        /** @type {!Array<!Element>|undefined} */

        let removedElements = undefined;

        if (isConnected) {
          removedElements = [];
          walkDeepDescendantElements(this, element => {
            if (element !== this) {
              removedElements.push(element);
            }
          });
        }

        baseDescriptor.set.call(this, htmlString);

        if (removedElements) {
          for (let i = 0; i < removedElements.length; i++) {
            const element = removedElements[i];

            if (element.__CE_state === src_CustomElementState.custom) {
              internals.disconnectedCallback(element);
            }
          }
        } // Only create custom elements if this element's owner document is
        // associated with the registry.


        if (!this.ownerDocument.__CE_hasRegistry) {
          internals.patchTree(this);
        } else {
          internals.patchAndUpgradeTree(this);
        }

        return htmlString;
      }
    });
  }

  if (Native.Element_innerHTML && Native.Element_innerHTML.get) {
    patch_innerHTML(Element.prototype, Native.Element_innerHTML);
  } else if (Native.HTMLElement_innerHTML && Native.HTMLElement_innerHTML.get) {
    patch_innerHTML(HTMLElement.prototype, Native.HTMLElement_innerHTML);
  } else {
    internals.addElementPatch(function (element) {
      patch_innerHTML(element, {
        enumerable: true,
        configurable: true,
        // Implements getting `innerHTML` by performing an unpatched `cloneNode`
        // of the element and returning the resulting element's `innerHTML`.
        // TODO: Is this too expensive?
        get:
        /** @this {Element} */
        function () {
          return (
            /** @type {!Element} */
            Native.Node_cloneNode.call(this, true).innerHTML
          );
        },
        // Implements setting `innerHTML` by creating an unpatched element,
        // setting `innerHTML` of that element and replacing the target
        // element's children with those of the unpatched element.
        set:
        /** @this {Element} */
        function (assignedValue) {
          // NOTE: re-route to `content` for `template` elements.
          // We need to do this because `template.appendChild` does not
          // route into `template.content`.
          const isTemplate = this.localName === 'template';
          /** @type {!Node} */

          const content = isTemplate ?
          /** @type {!HTMLTemplateElement} */
          this.content : this;
          /** @type {!Element} */

          const rawElement = Native.Document_createElementNS.call(document, this.namespaceURI, this.localName);
          rawElement.innerHTML = assignedValue;

          while (content.childNodes.length > 0) {
            Native.Node_removeChild.call(content, content.childNodes[0]);
          }

          const container = isTemplate ?
          /** @type {!HTMLTemplateElement} */
          rawElement.content : rawElement;

          while (container.childNodes.length > 0) {
            Native.Node_appendChild.call(content, container.childNodes[0]);
          }
        }
      });
    });
  }

  setPropertyUnchecked(Element.prototype, 'setAttribute',
  /**
   * @this {Element}
   * @param {string} name
   * @param {string} newValue
   */
  function (name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== src_CustomElementState.custom) {
      return Native.Element_setAttribute.call(this, name, newValue);
    }

    const oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_setAttribute.call(this, name, newValue);
    newValue = Native.Element_getAttribute.call(this, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, null);
  });
  setPropertyUnchecked(Element.prototype, 'setAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   * @param {string} newValue
   */
  function (namespace, name, newValue) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== src_CustomElementState.custom) {
      return Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    }

    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_setAttributeNS.call(this, namespace, name, newValue);
    newValue = Native.Element_getAttributeNS.call(this, namespace, name);
    internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
  });
  setPropertyUnchecked(Element.prototype, 'removeAttribute',
  /**
   * @this {Element}
   * @param {string} name
   */
  function (name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== src_CustomElementState.custom) {
      return Native.Element_removeAttribute.call(this, name);
    }

    const oldValue = Native.Element_getAttribute.call(this, name);
    Native.Element_removeAttribute.call(this, name);

    if (oldValue !== null) {
      internals.attributeChangedCallback(this, name, oldValue, null, null);
    }
  });
  setPropertyUnchecked(Element.prototype, 'removeAttributeNS',
  /**
   * @this {Element}
   * @param {?string} namespace
   * @param {string} name
   */
  function (namespace, name) {
    // Fast path for non-custom elements.
    if (this.__CE_state !== src_CustomElementState.custom) {
      return Native.Element_removeAttributeNS.call(this, namespace, name);
    }

    const oldValue = Native.Element_getAttributeNS.call(this, namespace, name);
    Native.Element_removeAttributeNS.call(this, namespace, name); // In older browsers, `Element#getAttributeNS` may return the empty string
    // instead of null if the attribute does not exist. For details, see;
    // https://developer.mozilla.org/en-US/docs/Web/API/Element/getAttributeNS#Notes

    const newValue = Native.Element_getAttributeNS.call(this, namespace, name);

    if (oldValue !== newValue) {
      internals.attributeChangedCallback(this, name, oldValue, newValue, namespace);
    }
  });

  function patch_insertAdjacentElement(destination, baseMethod) {
    setPropertyUnchecked(destination, 'insertAdjacentElement',
    /**
     * @this {Element}
     * @param {string} position
     * @param {!Element} element
     * @return {?Element}
     */
    function (position, element) {
      const wasConnected = Utilities_isConnected(element);
      const insertedElement =
      /** @type {!Element} */
      baseMethod.call(this, position, element);

      if (wasConnected) {
        internals.disconnectTree(element);
      }

      if (Utilities_isConnected(insertedElement)) {
        internals.connectTree(element);
      }

      return insertedElement;
    });
  }

  if (Native.HTMLElement_insertAdjacentElement) {
    patch_insertAdjacentElement(HTMLElement.prototype, Native.HTMLElement_insertAdjacentElement);
  } else if (Native.Element_insertAdjacentElement) {
    patch_insertAdjacentElement(Element.prototype, Native.Element_insertAdjacentElement);
  } else {
    console.warn('Custom Elements: `Element#insertAdjacentElement` was not patched.');
  }

  function patch_insertAdjacentHTML(destination, baseMethod) {
    /**
     * Patches and upgrades all nodes which are siblings between `start`
     * (inclusive) and `end` (exclusive). If `end` is `null`, then all siblings
     * following `start` will be patched and upgraded.
     * @param {!Node} start
     * @param {?Node} end
     */
    function upgradeNodesInRange(start, end) {
      const nodes = [];

      for (let node = start; node !== end; node = node.nextSibling) {
        nodes.push(node);
      }

      for (let i = 0; i < nodes.length; i++) {
        internals.patchAndUpgradeTree(nodes[i]);
      }
    }

    setPropertyUnchecked(destination, 'insertAdjacentHTML',
    /**
     * @this {Element}
     * @param {string} position
     * @param {string} text
     */
    function (position, text) {
      position = position.toLowerCase();

      if (position === "beforebegin") {
        const marker = this.previousSibling;
        baseMethod.call(this, position, text);
        upgradeNodesInRange(marker ||
        /** @type {!Node} */
        this.parentNode.firstChild, this);
      } else if (position === "afterbegin") {
        const marker = this.firstChild;
        baseMethod.call(this, position, text);
        upgradeNodesInRange(
        /** @type {!Node} */
        this.firstChild, marker);
      } else if (position === "beforeend") {
        const marker = this.lastChild;
        baseMethod.call(this, position, text);
        upgradeNodesInRange(marker ||
        /** @type {!Node} */
        this.firstChild, null);
      } else if (position === "afterend") {
        const marker = this.nextSibling;
        baseMethod.call(this, position, text);
        upgradeNodesInRange(
        /** @type {!Node} */
        this.nextSibling, marker);
      } else {
        throw new SyntaxError("The value provided (".concat(String(position), ") is ") + "not one of 'beforebegin', 'afterbegin', 'beforeend', or 'afterend'.");
      }
    });
  }

  if (Native.HTMLElement_insertAdjacentHTML) {
    patch_insertAdjacentHTML(HTMLElement.prototype, Native.HTMLElement_insertAdjacentHTML);
  } else if (Native.Element_insertAdjacentHTML) {
    patch_insertAdjacentHTML(Element.prototype, Native.Element_insertAdjacentHTML);
  } else {
    console.warn('Custom Elements: `Element#insertAdjacentHTML` was not patched.');
  }

  ParentNode(internals, Element.prototype, {
    prepend: Native.Element_prepend,
    append: Native.Element_append
  });
  ChildNode(internals, Element.prototype, {
    before: Native.Element_before,
    after: Native.Element_after,
    replaceWith: Native.Element_replaceWith,
    remove: Native.Element_remove
  });
});
;
// CONCATENATED MODULE: ./node_modules/@webcomponents/custom-elements/src/custom-elements.js
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */







const priorCustomElements = window['customElements'];

if (!priorCustomElements || priorCustomElements['forcePolyfill'] || typeof priorCustomElements['define'] != 'function' || typeof priorCustomElements['get'] != 'function') {
  /** @type {!CustomElementInternals} */
  const internals = new CustomElementInternals_CustomElementInternals();
  Patch_HTMLElement(internals);
  Patch_Document(internals);
  Patch_DocumentFragment(internals);
  Patch_Node(internals);
  Patch_Element(internals); // The main document is always associated with the registry.

  document.__CE_hasRegistry = true;
  /** @type {!CustomElementRegistry} */

  const customElements = new CustomElementRegistry_CustomElementRegistry(internals);
  Object.defineProperty(window, 'customElements', {
    configurable: true,
    enumerable: true,
    value: customElements
  });
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3NoYWR5LWRhdGEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL2ZsdXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvb2JzZXJ2ZS1jaGFuZ2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvaW5uZXJIVE1MLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2gtbmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2gtaW5zdGFuY2VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2gtZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvYXJyYXktc3BsaWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvbGluay1ub2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3N0eWxlLXNjb3BpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1BhcmVudE5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0RvY3VtZW50T3JGcmFnbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvRG9jdW1lbnRPclNoYWRvd1Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL0VsZW1lbnRPclNoYWRvd1Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1NoYWRvd1Jvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaC1zaGFkeVJvb3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9hdHRhY2gtc2hhZG93LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvd3JhcHBlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvRXZlbnRUYXJnZXQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1Nsb3RhYmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2hlcy9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWRvbS9zcmMvcGF0Y2hlcy9IVE1MRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvU2xvdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoZXMvRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9wYXRjaGVzL1dpbmRvdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHlkb20vc3JjL3BhdGNoLXByb3RvdHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5ZG9tL3NyYy9zaGFkeWRvbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2Nzcy1wYXJzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXNldHRpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXJlZ2V4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvdW5zY29wZWQtc3R5bGUtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLXV0aWwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS10cmFuc2Zvcm1lci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL3N0eWxlLWluZm8uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS1wcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvc3R5bGUtcGxhY2Vob2xkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zdHlsZS1jYWNoZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2RvY3VtZW50LXdhdGNoZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy90ZW1wbGF0ZS1tYXAuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9hcHBseS1zaGltLXV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvY29tbW9uLXV0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9zaGFkeWNzcy9zcmMvZG9jdW1lbnQtd2FpdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvc2hhZHljc3Mvc3JjL2N1c3RvbS1zdHlsZS1pbnRlcmZhY2UuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL3NyYy9zY29waW5nLXNoaW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL3NoYWR5Y3NzL2VudHJ5cG9pbnRzL3Njb3Bpbmctc2hpbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9VdGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cy9zcmMvQ3VzdG9tRWxlbWVudFN0YXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvc3JjL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cy9zcmMvRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9EZWZlcnJlZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9DdXN0b21FbGVtZW50UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvTmF0aXZlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvc3JjL0FscmVhZHlDb25zdHJ1Y3RlZE1hcmtlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9IVE1MRWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9Eb2N1bWVudEZyYWdtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvc3JjL1BhdGNoL05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B3ZWJjb21wb25lbnRzL2N1c3RvbS1lbGVtZW50cy9zcmMvUGF0Y2gvSW50ZXJmYWNlL0NoaWxkTm9kZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHdlYmNvbXBvbmVudHMvY3VzdG9tLWVsZW1lbnRzL3NyYy9QYXRjaC9FbGVtZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Ad2ViY29tcG9uZW50cy9jdXN0b20tZWxlbWVudHMvc3JjL2N1c3RvbS1lbGVtZW50cy5qcyJdLCJuYW1lcyI6WyJTaGFkeURhdGEiLCJ0b0pTT04iLCJlbnN1cmVTaGFkeURhdGFGb3JOb2RlIiwibm9kZSIsIl9fc2hhZHkiLCJzaGFkeURhdGFGb3JOb2RlIiwic2V0dGluZ3MiLCJ3aW5kb3ciLCJoYXNOYXRpdmVTaGFkb3dET00iLCJCb29sZWFuIiwiRWxlbWVudCIsInByb3RvdHlwZSIsImF0dGFjaFNoYWRvdyIsIk5vZGUiLCJnZXRSb290Tm9kZSIsImRlc2MiLCJPYmplY3QiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJoYXNEZXNjcmlwdG9ycyIsImNvbmZpZ3VyYWJsZSIsImdldCIsImluVXNlIiwibm9QYXRjaCIsInByZWZlclBlcmZvcm1hbmNlIiwiSVNfSUUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJtYXRjaCIsImNhblVwZ3JhZGUiLCJpc1RyYWNraW5nTG9naWNhbENoaWxkTm9kZXMiLCJub2RlRGF0YSIsImZpcnN0Q2hpbGQiLCJ1bmRlZmluZWQiLCJpc1NoYWR5Um9vdCIsIm9iaiIsIl9sb2NhbE5hbWUiLCJoYXNTaGFkb3dSb290V2l0aFNsb3QiLCJyb290IiwiX2hhc0luc2VydGlvblBvaW50IiwicCIsIm1hdGNoZXMiLCJtYXRjaGVzU2VsZWN0b3IiLCJtb3pNYXRjaGVzU2VsZWN0b3IiLCJtc01hdGNoZXNTZWxlY3RvciIsIm9NYXRjaGVzU2VsZWN0b3IiLCJ3ZWJraXRNYXRjaGVzU2VsZWN0b3IiLCJlbGVtZW50Iiwic2VsZWN0b3IiLCJjYWxsIiwibWl4aW4iLCJ0YXJnZXQiLCJzb3VyY2UiLCJpIiwidHdpZGRsZSIsImRvY3VtZW50IiwiY3JlYXRlVGV4dE5vZGUiLCJjb250ZW50IiwicXVldWUiLCJNdXRhdGlvbk9ic2VydmVyIiwibGVuZ3RoIiwic2hpZnQiLCJlIiwidGV4dENvbnRlbnQiLCJvYnNlcnZlIiwiY2hhcmFjdGVyRGF0YSIsIm1pY3JvdGFzayIsImNhbGxiYWNrIiwicHVzaCIsImhhc0RvY3VtZW50Q29udGFpbnMiLCJjb250YWlucyIsImNvbnRhaW5lciIsIlNIQURZX1BSRUZJWCIsImdldE5vZGVIVE1MQ29sbGVjdGlvbk5hbWUiLCJnZXRBdHRyaWJ1dGUiLCJpc1ZhbGlkSFRNTENvbGxlY3Rpb25OYW1lIiwibmFtZSIsImlzTmFOIiwiY3JlYXRlUG9seWZpbGxlZEhUTUxDb2xsZWN0aW9uIiwibm9kZXMiLCJsIiwiaXRlbSIsImluZGV4IiwibmFtZWRJdGVtIiwibm9kZU5hbWUiLCJOQVRJVkVfUFJFRklYIiwibmF0aXZlQ2hpbGROb2Rlc0FycmF5IiwicGFyZW50IiwicmVzdWx0IiwibiIsImNoaWxkTm9kZXNBcnJheSIsInBhdGNoUHJvcGVydGllcyIsInByb3RvIiwiZGVzY3JpcHRvcnMiLCJwcmVmaXgiLCJkaXNhbGxvd2VkUGF0Y2hlcyIsIm5ld0Rlc2NyaXB0b3IiLCJpbmRleE9mIiwidmFsdWUiLCJkZWZpbmVQcm9wZXJ0eSIsIk5hdGl2ZUhUTUxFbGVtZW50IiwiSFRNTEVsZW1lbnQiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJmbHVzaExpc3QiLCJzY2hlZHVsZWQiLCJlbnF1ZXVlIiwidXRpbHMiLCJmbHVzaCIsImRpZEZsdXNoIiwiQXN5bmNPYnNlcnZlciIsImNvbnN0cnVjdG9yIiwiX3NjaGVkdWxlZCIsImFkZGVkTm9kZXMiLCJyZW1vdmVkTm9kZXMiLCJjYWxsYmFja3MiLCJTZXQiLCJzY2hlZHVsZSIsIm11dGF0aW9ucyIsInRha2VSZWNvcmRzIiwiY2IiLCJvYnNlcnZlQ2hpbGRyZW4iLCJzZCIsIm9ic2VydmVyIiwiYWRkIiwiX2NhbGxiYWNrIiwiX29ic2VydmVyIiwiX25vZGUiLCJ1bm9ic2VydmVDaGlsZHJlbiIsImhhbmRsZSIsImRlbGV0ZSIsInNpemUiLCJmaWx0ZXJNdXRhdGlvbnMiLCJ0YXJnZXRSb290Tm9kZSIsIm1hcCIsIm11dGF0aW9uIiwibXV0YXRpb25JblNjb3BlIiwiQXJyYXkiLCJmcm9tIiwiZmlsdGVyIiwiY3JlYXRlIiwibSIsImVzY2FwZUF0dHJSZWdFeHAiLCJlc2NhcGVEYXRhUmVnRXhwIiwiZXNjYXBlUmVwbGFjZSIsImMiLCJlc2NhcGVBdHRyIiwicyIsInJlcGxhY2UiLCJlc2NhcGVEYXRhIiwibWFrZVNldCIsImFyciIsInNldCIsInZvaWRFbGVtZW50cyIsInBsYWludGV4dFBhcmVudHMiLCJnZXRPdXRlckhUTUwiLCJwYXJlbnROb2RlIiwibm9kZVR5cGUiLCJFTEVNRU5UX05PREUiLCJ0YWdOYW1lIiwibG9jYWxOYW1lIiwiYXR0cnMiLCJhdHRyaWJ1dGVzIiwiYXR0ciIsImdldElubmVySFRNTCIsIlRFWFRfTk9ERSIsImRhdGEiLCJDT01NRU5UX05PREUiLCJjb25zb2xlIiwiZXJyb3IiLCJFcnJvciIsImMkIiwiY2hpbGROb2RlcyIsImNoaWxkIiwibmF0aXZlTWV0aG9kcyIsInF1ZXJ5U2VsZWN0b3IiLCJxdWVyeVNlbGVjdG9yQWxsIiwibmF0aXZlVHJlZSIsImluc3RhbGxOYXRpdmVBY2Nlc3NvciIsImluc3RhbGxOYXRpdmVNZXRob2QiLCJmbiIsImRlZmluZU5hdGl2ZUFjY2Vzc29ycyIsInByb3AiLCJjb3B5UHJvcGVydGllcyIsImxpc3QiLCJkZXNjcmlwdG9yIiwibm9kZVdhbGtlciIsImNyZWF0ZVRyZWVXYWxrZXIiLCJOb2RlRmlsdGVyIiwiU0hPV19BTEwiLCJlbGVtZW50V2Fsa2VyIiwiU0hPV19FTEVNRU5UIiwiaW5lcnREb2MiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUhUTUxEb2N1bWVudCIsImNsZWFyTm9kZSIsIlBhcmVudE5vZGVBY2Nlc3NvcnMiLCJQYXJlbnROb2RlTWV0aG9kcyIsImFkZE5hdGl2ZVByZWZpeGVkUHJvcGVydGllcyIsImV2ZW50UHJvcHMiLCJFdmVudFRhcmdldCIsIldpbmRvdyIsImN1cnJlbnROb2RlIiwibGFzdENoaWxkIiwicHJldmlvdXNTaWJsaW5nIiwibmV4dFNpYmxpbmciLCJwYXJlbnRFbGVtZW50IiwiRE9DVU1FTlRfRlJBR01FTlRfTk9ERSIsInRleHRXYWxrZXIiLCJTSE9XX1RFWFQiLCJuZXh0Tm9kZSIsIm5vZGVWYWx1ZSIsIlBhcmVudE5vZGVXYWxrZXJEZXNjcmlwdG9ycyIsImZpcnN0RWxlbWVudENoaWxkIiwibGFzdEVsZW1lbnRDaGlsZCIsImNoaWxkcmVuIiwiY2hpbGRFbGVtZW50Q291bnQiLCJwcmV2aW91c0VsZW1lbnRTaWJsaW5nIiwibmV4dEVsZW1lbnRTaWJsaW5nIiwiaW5uZXJIVE1MIiwiY29udGFpbmVyTmFtZSIsImh0bWxDb250YWluZXIiLCJuYW1lc3BhY2VVUkkiLCJjcmVhdGVFbGVtZW50IiwiY3JlYXRlRWxlbWVudE5TIiwibmV3Q29udGVudCIsImNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsIkhUTUxUZW1wbGF0ZUVsZW1lbnQiLCJEb2N1bWVudEZyYWdtZW50IiwiRG9jdW1lbnQiLCJJbnNpZGVEZXNjcmlwdG9ycyIsInNoYWRvd1Jvb3QiLCJUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzIiwiT3V0c2lkZURlc2NyaXB0b3JzIiwiZW51bWVyYWJsZSIsIm5vSW5zdGFuY2VQYXRjaGluZyIsInBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnMiLCJfX291dHNpZGVBY2Nlc3NvcnMiLCJwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMiLCJfX2luc2lkZUFjY2Vzc29ycyIsImV2ZW50V3JhcHBlcnNOYW1lIiwiRGF0ZSIsIm5vdyIsImNvbXBvc2VkR2V0dGVyIiwiY29tcG9zZWRQcm9wIiwiRXZlbnQiLCJldiIsInN1cHBvcnRzRXZlbnRPcHRpb25zIiwic3VwcG9ydGVkIiwiZXZlbnRPcHRpb25zIiwiY2FwdHVyZSIsImxpc3RlbmVyIiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJwYXJzZUV2ZW50T3B0aW9ucyIsIm9wdGlvbnNPckNhcHR1cmUiLCJvbmNlIiwicGFzc2l2ZSIsInNoYWR5VGFyZ2V0IiwiX19zaGFkeVRhcmdldCIsIm5hdGl2ZUV2ZW50T3B0aW9ucyIsImFsd2F5c0NvbXBvc2VkIiwidW5wYXRjaGVkRXZlbnRzIiwiZ2V0Um9vdE5vZGVXaXRoRmFsbGJhY2siLCJldmVudFRhcmdldCIsInBhdGhDb21wb3NlciIsInN0YXJ0Tm9kZSIsImNvbXBvc2VkIiwiY29tcG9zZWRQYXRoIiwiY3VycmVudCIsInN0YXJ0Um9vdCIsImhvc3QiLCJldmVudCIsIl9fY29tcG9zZWRQYXRoIiwicmV0YXJnZXQiLCJyZWZOb2RlIiwicGF0aCIsInJlZk5vZGVQYXRoIiwicCQiLCJhbmNlc3RvciIsImxhc3RSb290Iiwicm9vdElkeCIsIkV2ZW50UGF0Y2hlcyIsIl9fY29tcG9zZWQiLCJ0eXBlIiwiaXNUcnVzdGVkIiwiY3VycmVudFRhcmdldCIsInJlbGF0ZWRUYXJnZXQiLCJfX3JlbGF0ZWRUYXJnZXQiLCJfX3JlbGF0ZWRUYXJnZXRDb21wb3NlZFBhdGgiLCJzdG9wUHJvcGFnYXRpb24iLCJfX3Byb3BhZ2F0aW9uU3RvcHBlZCIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsIl9faW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkIiwibWl4aW5Db21wb3NlZEZsYWciLCJCYXNlIiwia2xhenoiLCJvcHRpb25zIiwiX19wcm90b19fIiwibm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0IiwiaGFzUmV0YXJnZXRlZCIsImZpcmVIYW5kbGVycyIsInBoYXNlIiwiaHMiLCJfX2hhbmRsZXJzIiwicmV0YXJnZXROb25CdWJibGluZ0V2ZW50IiwiQVRfVEFSR0VUIiwibGFzdEZpcmVkUm9vdCIsImxpc3RlbmVyU2V0dGluZ3NFcXVhbCIsInNhdmVkTGlzdGVuZXIiLCJzYXZlZE5vZGUiLCJzYXZlZFR5cGUiLCJzYXZlZENhcHR1cmUiLCJzYXZlZE9uY2UiLCJzYXZlZFBhc3NpdmUiLCJmaW5kTGlzdGVuZXIiLCJ3cmFwcGVycyIsImdldEV2ZW50V3JhcHBlcnMiLCJldmVudExpa2UiLCJ0YXJnZXROZWVkc1BhdGhDaGVjayIsImZuT3JPYmoiLCJoYW5kbGVyVHlwZSIsImhhbmRsZUV2ZW50Iiwid3JhcHBlckZuIiwicGF0Y2hFdmVudCIsImxhc3RDdXJyZW50VGFyZ2V0RGVzYyIsImV2ZW50UGhhc2UiLCJCVUJCTElOR19QSEFTRSIsIkNBUFRVUklOR19QSEFTRSIsImJ1YmJsZXMiLCJyZXQiLCJpZHgiLCJzcGxpY2UiLCJhY3RpdmF0ZUZvY3VzRXZlbnRPdmVycmlkZXMiLCJFdmVudFBhdGNoZXNEZXNjcmlwdG9ycyIsIlNIQURZX1BST1RPIiwiU0hBRFlfU09VUkNFX1BST1RPIiwiZ2V0UHJvdG90eXBlT2YiLCJoYXNPd25Qcm9wZXJ0eSIsInBhdGNoZWRQcm90byIsIlBhdGNoZWRFdmVudCIsIlBhdGNoZWRDdXN0b21FdmVudCIsIkN1c3RvbUV2ZW50IiwiUGF0Y2hlZE1vdXNlRXZlbnQiLCJNb3VzZUV2ZW50IiwicGF0Y2hFdmVudHMiLCJwYXRjaENsaWNrIiwiY29tcG9zZWRDbGlja0ZuIiwiY2FuY2VsYWJsZSIsImNsaWNrIiwiZXZlbnRQcm9wZXJ0eU5hbWVzIiwic3Vic3RyaW5nIiwibmV3U3BsaWNlIiwicmVtb3ZlZCIsImFkZGVkQ291bnQiLCJFRElUX0xFQVZFIiwiRURJVF9VUERBVEUiLCJFRElUX0FERCIsIkVESVRfREVMRVRFIiwiY2FsY0VkaXREaXN0YW5jZXMiLCJjdXJyZW50U3RhcnQiLCJjdXJyZW50RW5kIiwib2xkIiwib2xkU3RhcnQiLCJvbGRFbmQiLCJyb3dDb3VudCIsImNvbHVtbkNvdW50IiwiZGlzdGFuY2VzIiwiaiIsImVxdWFscyIsIm5vcnRoIiwid2VzdCIsInNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyIsImVkaXRzIiwibm9ydGhXZXN0IiwibWluIiwicmV2ZXJzZSIsImNhbGNTcGxpY2VzIiwicHJlZml4Q291bnQiLCJzdWZmaXhDb3VudCIsIm1pbkxlbmd0aCIsIk1hdGgiLCJzaGFyZWRQcmVmaXgiLCJzaGFyZWRTdWZmaXgiLCJvcHMiLCJzcGxpY2VzIiwib2xkSW5kZXgiLCJzZWFyY2hMZW5ndGgiLCJpbmRleDEiLCJpbmRleDIiLCJjb3VudCIsImN1cnJlbnRWYWx1ZSIsInByZXZpb3VzVmFsdWUiLCJjYWxjdWxhdGVTcGxpY2VzIiwicHJldmlvdXMiLCJsaW5rTm9kZSIsImNvbnRhaW5lckRhdGEiLCJyZWZfbm9kZSIsInJlZl9ub2RlRGF0YSIsInBzZCIsIm5zZCIsInJlY29yZEluc2VydEJlZm9yZSIsImZpcnN0IiwicmVjb3JkUmVtb3ZlQ2hpbGQiLCJyZWNvcmRDaGlsZE5vZGVzIiwiYWRvcHRlZFBhcmVudCIsInNjb3BpbmdTaGltIiwiZ2V0U2NvcGluZ1NoaW0iLCJzY29wZUNsYXNzQXR0cmlidXRlIiwiYWRkU2hhZHlTY29waW5nIiwibmV3U2NvcGVOYW1lIiwicmVtb3ZlU2hhZHlTY29waW5nIiwiY3VycmVudFNjb3BlTmFtZSIsInJlcGxhY2VTaGFkeVNjb3BpbmciLCJvbGRTY29wZU5hbWUiLCJjdXJyZW50U2NvcGVJc0NvcnJlY3QiLCJjb3JyZWN0U2NvcGUiLCJjdXJyZW50U2NvcGUiLCJjdXJyZW50U2NvcGVGb3JOb2RlIiwidHJlZVZpc2l0b3IiLCJ2aXNpdG9yRm4iLCJkb2MiLCJuYXRpdmVJc0Nvbm5lY3RlZEFjY2Vzc29ycyIsIm5hdGl2ZUlzQ29ubmVjdGVkIiwicmVtb3ZlT3duZXJTaGFkeVJvb3QiLCJoYXNDYWNoZWRPd25lclJvb3QiLCJvd25lclNoYWR5Um9vdCIsImZpcnN0Q29tcG9zZWROb2RlIiwiZmxhdHRlbmVkIiwiZmxhdHRlbmVkTm9kZXMiLCJzY2hlZHVsZU9ic2VydmVyIiwiYWRkZWROb2RlIiwicmVtb3ZlZE5vZGUiLCJOb2RlUGF0Y2hlcyIsImlzQ29ubmVjdGVkIiwib3duZXJEb2N1bWVudCIsImRvY3VtZW50RWxlbWVudCIsInRjIiwiam9pbiIsImluc2VydEJlZm9yZSIsInJlZkRhdGEiLCJzbG90c0FkZGVkIiwib3duZXJSb290Iiwib3duZXJTaGFkeVJvb3RGb3JOb2RlIiwic2tpcFVuc2NvcGluZyIsImFsbG93TmF0aXZlSW5zZXJ0IiwibmVlZHNTY29waW5nIiwibmVlZHNTbG90RmluZGluZyIsIl9hZGRTbG90cyIsIl9hc3luY1JlbmRlciIsInBhcmVudERhdGEiLCJhZG9wdE5vZGUiLCJhcHBlbmRDaGlsZCIsInJlbW92ZUNoaWxkIiwicHJldmVudE5hdGl2ZVJlbW92ZSIsInJlbW92aW5nSW5zZXJ0aW9uUG9pbnQiLCJfcmVtb3ZlQ29udGFpbmVkU2xvdHMiLCJjaGFuZ2VTbG90Q29udGVudCIsInJlcGxhY2VDaGlsZCIsImNsb25lTm9kZSIsImRlZXAiLCJBVFRSSUJVVEVfTk9ERSIsIm5jIiwicXVlcnkiLCJtYXRjaGVyIiwiaGFsdGVyIiwicXVlcnlDaGlsZE5vZGVzIiwicXVlcnlFbGVtZW50IiwiUGFyZW50Tm9kZVBhdGNoZXMiLCJRdWVyeVBhdGNoZXMiLCJ1c2VOYXRpdmUiLCJvIiwic2xpY2UiLCJQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcyIsImFzc2lnbiIsIkRvY3VtZW50T3JGcmFnbWVudFBhdGNoZXMiLCJnZXRFbGVtZW50QnlJZCIsImlkIiwiZ2V0RG9jdW1lbnRBY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudCIsIkRvY3VtZW50T3JTaGFkb3dSb290UGF0Y2hlcyIsImFjdGl2ZSIsImFjdGl2ZVJvb3QiLCJFbGVtZW50T3JTaGFkb3dSb290UGF0Y2hlcyIsIlNoYWRvd1Jvb3RQYXRjaGVzIiwicGF0Y2hTaGFkeUFjY2Vzc29ycyIsInBhdGNoU2hhZHlSb290IiwiZGVmaW5lUHJvcGVydGllcyIsIlNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuIiwiQ0FUQ0hBTExfTkFNRSIsIlNIQURZUk9PVF9OQU1FIiwiTU9ERV9DTE9TRUQiLCJpc1JlbmRlcmluZyIsInJlYWR5U3RhdGUiLCJyb290UmVuZGVyZWQiLCJhbmNlc3Rvckxpc3QiLCJhbmNlc3RvcnMiLCJ1bnNoaWZ0IiwiU2hhZHlSb290IiwidG9rZW4iLCJUeXBlRXJyb3IiLCJfcmVuZGVyUGVuZGluZyIsIl9oYXNSZW5kZXJlZCIsIl9zbG90TGlzdCIsIl9zbG90TWFwIiwiX3BlbmRpbmdTbG90cyIsIl9pbml0IiwibW9kZSIsImhvc3REYXRhIiwicHVibGljUm9vdCIsInJvb3REYXRhIiwiX3JlbmRlciIsIl9nZXRQZW5kaW5nRGlzdHJpYnV0aW9uUm9vdCIsInJlbmRlclJvb3QiLCJfZ2V0RGlzdHJpYnV0aW9uUGFyZW50IiwiX19jaGlsZFNsb3RDb3VudCIsIl9yZW5kZXJTZWxmIiwiX2ZsdXNoSW5pdGlhbCIsIndhc1JlbmRlcmluZyIsIl9kaXN0cmlidXRlIiwiX2NvbXBvc2UiLCJhc3NpZ25lZFNsb3QiLCJfdmFsaWRhdGVTbG90cyIsInNsb3QiLCJfY2xlYXJTbG90QXNzaWduZWROb2RlcyIsIl9kaXN0cmlidXRlTm9kZVRvU2xvdCIsInNsb3REYXRhIiwiYXNzaWduZWROb2RlcyIsInNsb3RQYXJlbnREYXRhIiwic2xvdFBhcmVudFJvb3QiLCJfYWRkQXNzaWduZWRUb0ZsYXR0ZW5lZE5vZGVzIiwicHJldkFzc2lnbmVkTm9kZXMiLCJfcHJldmlvdXNseUFzc2lnbmVkTm9kZXMiLCJfcHJldkFzc2lnbmVkU2xvdCIsImRpcnR5IiwiX2ZpcmVTbG90Q2hhbmdlIiwiZm9yY2VkU2xvdCIsIm9sZFNsb3QiLCJuJCIsImFzc2lnbmVkIiwibmVzdGVkQXNzaWduZWQiLCJzbG90cyIsImNvbXBvc2VMaXN0IiwidGFyZ2V0Tm9kZSIsIl91cGRhdGVDaGlsZE5vZGVzIiwiX2NvbXBvc2VOb2RlIiwiX2lzSW5zZXJ0aW9uUG9pbnQiLCJkaXN0cmlidXRlZE5vZGUiLCJkIiwibmV4dCIsIl9lbnN1cmVTbG90RGF0YSIsIl9tYXBTbG90cyIsInNsb3ROYW1lc1RvU29ydCIsInNsb3RQYXJlbnQiLCJfbmFtZUZvclNsb3QiLCJfc29ydFNsb3RzIiwiX19zbG90TmFtZSIsInNvcnQiLCJhIiwiYiIsImxpc3RBIiwibGlzdEIiLCJuQSIsIm5CIiwiZGlkUmVtb3ZlIiwieCIsIl9yZW1vdmVGbGF0dGVuZWROb2RlcyIsIl91cGRhdGVTbG90TmFtZSIsIm9sZE5hbWUiLCJTaGFkb3dSb290IiwiY29ubmVjdE1hcCIsIk1hcCIsInIiLCJ2IiwiayIsImNsZWFyIiwiTWFuYWdlQ29ubmVjdCIsImJhc2UiLCJjb25uZWN0ZWQiLCJkaXNjb25uZWN0ZWQiLCJjb3VudGVyIiwiY29ubmVjdEZsYWciLCJjb25uZWN0ZWRDYWxsYmFjayIsImRpc2Nvbm5lY3RlZENhbGxiYWNrIiwib3JpZ2luYWxEZWZpbmUiLCJkZWZpbmUiLCJjdXN0b21FbGVtZW50cyIsIldyYXBwZXIiLCJkaXNwYXRjaEV2ZW50IiwiaGFzQXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiRE9DVU1FTlRfTk9ERSIsIl9hY3RpdmVFbGVtZW50IiwiZm9jdXMiLCJibHVyIiwiaW1wb3J0Tm9kZSIsIndyYXBwZXJNYXAiLCJXZWFrTWFwIiwid3JhcCIsIndyYXBwZXIiLCJFdmVudFRhcmdldFBhdGNoZXMiLCJTbG90YWJsZVBhdGNoZXMiLCJkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlIiwiRWxlbWVudFBhdGNoZXMiLCJIVE1MRWxlbWVudFBhdGNoZXMiLCJzaGFkb3dBY3RpdmUiLCJwcm9wZXJ0eSIsInNoYWR5RGF0YSIsImV2ZW50TmFtZSIsIl9fb25DYWxsYmFja0xpc3RlbmVycyIsIlNsb3RQYXRjaGVzIiwiZmxhdHRlbiIsIkRvY3VtZW50UGF0Y2hlcyIsIldpbmRvd1BhdGNoZXMiLCJiaW5kIiwiTm9uU3RhbmRhcmRIVE1MRWxlbWVudCIsIkVsZW1lbnRTaG91bGRIYXZlSW5uZXJIVE1MIiwicGF0Y2hNYXAiLCJUZXh0IiwiSFRNTFNsb3RFbGVtZW50IiwiZ2V0UGF0Y2hQcm90b3R5cGUiLCJkaXNhbGxvd2VkTmF0aXZlUGF0Y2hlcyIsImFwcGx5UGF0Y2hlcyIsImRpc2FsbG93ZWQiLCJwYXRjaCIsImFkZFNoYWR5UHJlZml4ZWRQcm9wZXJ0aWVzIiwiU2hhZHlET00iLCJTdHlsZU5vZGUiLCJwYXJzZSIsInRleHQiLCJjbGVhbiIsInBhcnNlQ3NzIiwibGV4IiwiY3NzVGV4dCIsIlJYIiwiY29tbWVudHMiLCJwb3J0IiwiT1BFTl9CUkFDRSIsIkNMT1NFX0JSQUNFIiwidCIsInRyaW0iLCJzcyIsIl9leHBhbmRVbmljb2RlRXNjYXBlcyIsIm11bHRpcGxlU3BhY2VzIiwibGFzdEluZGV4T2YiLCJBVF9TVEFSVCIsIk1FRElBX1NUQVJUIiwidHlwZXMiLCJNRURJQV9SVUxFIiwia2V5ZnJhbWVzUnVsZSIsIktFWUZSQU1FU19SVUxFIiwic3BsaXQiLCJwb3AiLCJWQVJfU1RBUlQiLCJNSVhJTl9SVUxFIiwiU1RZTEVfUlVMRSIsInIkIiwiY29kZSIsImFyZ3VtZW50cyIsInJlcGVhdCIsInN0cmluZ2lmeSIsInByZXNlcnZlUHJvcGVydGllcyIsIl9oYXNNaXhpblJ1bGVzIiwicmVtb3ZlQ3VzdG9tUHJvcHMiLCJydWxlcyIsInJlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50IiwicmVtb3ZlQ3VzdG9tUHJvcEFwcGx5IiwiY3VzdG9tUHJvcCIsIm1peGluUHJvcCIsIm1peGluQXBwbHkiLCJ2YXJBcHBseSIsIm5hdGl2ZVNoYWRvdyIsIm5hdGl2ZUNzc1ZhcmlhYmxlc18iLCJjYWxjQ3NzVmFyaWFibGVzIiwiQ1NTIiwic3VwcG9ydHMiLCJjc3NCdWlsZCIsIlNoYWR5Q1NTIiwiZGlzYWJsZVJ1bnRpbWUiLCJuYXRpdmVDc3MiLCJuYXRpdmVDc3NWYXJpYWJsZXMiLCJWQVJfQVNTSUdOIiwiTUlYSU5fTUFUQ0giLCJWQVJfQ09OU1VNRUQiLCJBTklNQVRJT05fTUFUQ0giLCJNRURJQV9NQVRDSCIsIklTX1ZBUiIsIkJSQUNLRVRFRCIsIkhPU1RfUFJFRklYIiwiSE9TVF9TVUZGSVgiLCJzdHlsZVRleHRTZXQiLCJzY29waW5nQXR0cmlidXRlIiwicHJvY2Vzc1Vuc2NvcGVkU3R5bGUiLCJzdHlsZSIsImhhcyIsIm5ld1N0eWxlIiwiaGVhZCIsImlzVW5zY29wZWRTdHlsZSIsInRvQ3NzVGV4dCIsImZvckVhY2hSdWxlIiwicnVsZXNGb3JTdHlsZSIsImlzS2V5ZnJhbWVzU2VsZWN0b3IiLCJydWxlIiwic3R5bGVSdWxlQ2FsbGJhY2siLCJrZXlmcmFtZXNSdWxlQ2FsbGJhY2siLCJvbmx5QWN0aXZlUnVsZXMiLCJza2lwUnVsZXMiLCJtYXRjaE1lZGlhIiwiYXBwbHlDc3MiLCJtb25pa2VyIiwiY29udGV4dE5vZGUiLCJjcmVhdGVTY29wZVN0eWxlIiwiYXBwbHlTdHlsZSIsImxhc3RIZWFkQXBwbHlOb2RlIiwiYXBwbHlTdHlsZVBsYWNlSG9sZGVyIiwicGxhY2VIb2xkZXIiLCJjcmVhdGVDb21tZW50IiwiYWZ0ZXIiLCJzY29wZSIsInBvc2l0aW9uIiwiY29tcGFyZURvY3VtZW50UG9zaXRpb24iLCJET0NVTUVOVF9QT1NJVElPTl9QUkVDRURJTkciLCJpc1RhcmdldGVkQnVpbGQiLCJidWlsZFR5cGUiLCJmaW5kTWF0Y2hpbmdQYXJlbiIsInN0YXJ0IiwibGV2ZWwiLCJwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayIsInN0ciIsImVuZCIsImlubmVyIiwic3VmZml4IiwiY29tbWEiLCJmYWxsYmFjayIsInNldEVsZW1lbnRDbGFzc1JhdyIsImdldElzRXh0ZW5kcyIsImlzIiwidHlwZUV4dGVuc2lvbiIsImV4dGVuZHMiLCJnYXRoZXJTdHlsZVRleHQiLCJzdHlsZVRleHRQYXJ0cyIsInN0eWxlcyIsInNwbGl0U2VsZWN0b3JMaXN0IiwicGFydHMiLCJwYXJ0IiwiQ1NTX0JVSUxEX0FUVFIiLCJnZXRDc3NCdWlsZCIsIl9fY3NzQnVpbGQiLCJhdHRyVmFsdWUiLCJidWlsZENvbW1lbnQiLCJnZXRCdWlsZENvbW1lbnQiLCJyZW1vdmVCdWlsZENvbW1lbnQiLCJlbGVtZW50SGFzQnVpbHRDc3MiLCJDb21tZW50IiwiY29tbWVudFBhcnRzIiwiaXNPcHRpbWFsQ3NzQnVpbGQiLCJTQ09QRV9OQU1FIiwiU3R5bGVUcmFuc2Zvcm1lciIsImRvbSIsInNob3VsZFJlbW92ZVNjb3BlIiwiX3RyYW5zZm9ybURvbSIsImRvbUFkZFNjb3BlIiwidHJhbnNmb3JtZXIiLCJ0ZW1wbGF0ZSIsIl9jb250ZW50IiwiY2xhc3NMaXN0IiwicmVtb3ZlIiwiQ0xBU1MiLCJuZXdWYWx1ZSIsIlN0eWxlVXRpbCIsImRvbVJlcGxhY2VTY29wZSIsIm9sZFNjb3BlIiwibmV3U2NvcGUiLCJkb21SZW1vdmVTY29wZSIsImVsZW1lbnRTdHlsZXMiLCJzdHlsZVJ1bGVzIiwiY3NzIiwiZXh0IiwiaG9zdFNjb3BlIiwiX2NhbGNIb3N0U2NvcGUiLCJfY2FsY0VsZW1lbnRTY29wZSIsInNlbGYiLCJpc1Njb3BlZCIsIkNTU19DTEFTU19QUkVGSVgiLCJfdHJhbnNmb3JtUnVsZSIsIl90cmFuc2Zvcm1Db21wbGV4U2VsZWN0b3IiLCJ0cmFuc2Zvcm1lZFNlbGVjdG9yIiwiX3RyYW5zZm9ybVJ1bGVDc3MiLCJDT01QTEVYX1NFTEVDVE9SX1NFUCIsIl90d2lkZGxlTnRoUGx1cyIsIk5USCIsImluc2lkZSIsIl9wcmVzZXJ2ZU1hdGNoZXNQc2V1ZG8iLCJNQVRDSEVTIiwiaW5wdXQiLCJNQVRDSEVTX1JFUExBQ0VNRU5UIiwiX3JlcGxhY2VNYXRjaGVzUHNldWRvIiwicmVkdWNlIiwiYWNjIiwiY3VyIiwic3RvcCIsImlzTnRoIiwidGVzdCIsImlzTWF0Y2hlcyIsIlNMT1RURURfU1RBUlQiLCJIT1NUIiwiU0lNUExFX1NFTEVDVE9SX1NFUCIsImluZm8iLCJfdHJhbnNmb3JtQ29tcG91bmRTZWxlY3RvciIsImNvbWJpbmF0b3IiLCJESVJfUEFSRU4iLCJiZWZvcmUiLCJkaXIiLCJzbG90dGVkSW5kZXgiLCJTTE9UVEVEIiwiX3RyYW5zZm9ybUhvc3RTZWxlY3RvciIsIl90cmFuc2Zvcm1TaW1wbGVTZWxlY3RvciIsInNsb3R0ZWQiLCJTTE9UVEVEX1BBUkVOIiwicGFyZW4iLCJvdXRwdXQiLCJQU0VVRE9fUFJFRklYIiwiSE9TVF9QQVJFTiIsIlNJTVBMRV9TRUxFQ1RPUl9QUkVGSVgiLCJ0eXBlU2VsZWN0b3IiLCJTRUxFQ1RPUl9OT19NQVRDSCIsImRvY3VtZW50UnVsZSIsIm5vcm1hbGl6ZVJvb3RTZWxlY3RvciIsIl90cmFuc2Zvcm1Eb2N1bWVudFNlbGVjdG9yIiwiUk9PVCIsIlNDT1BFX0RPQ19TRUxFQ1RPUiIsIlJlZ0V4cCIsImluZm9LZXkiLCJTdHlsZUluZm8iLCJzdHlsZUluZm8iLCJhc3QiLCJwbGFjZWhvbGRlciIsIm93blN0eWxlUHJvcGVydHlOYW1lcyIsImVsZW1lbnROYW1lIiwib3ZlcnJpZGVTdHlsZVByb3BlcnRpZXMiLCJzdHlsZVByb3BlcnRpZXMiLCJzY29wZVNlbGVjdG9yIiwiY3VzdG9tU3R5bGUiLCJfZ2V0U3R5bGVSdWxlcyIsIm1ldGhvZCIsIlhTQ09QRV9OQU1FIiwiU3R5bGVQcm9wZXJ0aWVzIiwiZGVjb3JhdGVTdHlsZXMiLCJwcm9wcyIsImtleWZyYW1lcyIsInJ1bGVJbmRleCIsImRlY29yYXRlUnVsZSIsImNvbGxlY3RQcm9wZXJ0aWVzSW5Dc3NUZXh0IiwicHJvcGVydHlJbmZvIiwib25LZXlmcmFtZXNSdWxlIiwiX2tleWZyYW1lcyIsIm5hbWVzIiwicHJvcGVydGllcyIsImhhc1Byb3BlcnRpZXMiLCJjb2xsZWN0UHJvcGVydGllcyIsImNvbGxlY3RDc3NUZXh0IiwicngiLCJhbnkiLCJleGVjIiwiY29sbGVjdENvbnN1bWluZ0Nzc1RleHQiLCJyZWlmeSIsInZhbHVlRm9yUHJvcGVydHkiLCJ2YWx1ZUZvclByb3BlcnRpZXMiLCJwcm9wZXJ0eVZhbHVlIiwibGFzdEluZGV4IiwiY29sb24iLCJwcCIsImFwcGx5UHJvcGVydGllcyIsImFwcGx5S2V5ZnJhbWVUcmFuc2Zvcm1zIiwia2V5ZnJhbWVUcmFuc2Zvcm1zIiwiaGFzQW5pbWF0aW9ucyIsInRyYW5zZm9ybSIsImtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybSIsImtleWZyYW1lIiwicHJvcGVydHlEYXRhRnJvbVN0eWxlcyIsInNlbGVjdG9yVG9NYXRjaCIsImFkZFRvQml0TWFzayIsImtleSIsIndoZW5Ib3N0T3JSb290UnVsZSIsInBhcnNlZFNlbGVjdG9yIiwiaXNSb290IiwiaXNIb3N0IiwiaG9zdEFuZFJvb3RQcm9wZXJ0aWVzRm9yU2NvcGUiLCJob3N0UHJvcHMiLCJyb290UHJvcHMiLCJfZWxlbWVudCIsInRyYW5zZm9ybVN0eWxlcyIsImhvc3RTZWxlY3RvciIsInJ4SG9zdFNlbGVjdG9yIiwiaG9zdFJ4IiwiX2VsZW1lbnRLZXlmcmFtZVRyYW5zZm9ybXMiLCJfc2NvcGVTZWxlY3RvciIsImtleWZyYW1lc1J1bGVzIiwiX3Njb3BlS2V5ZnJhbWVzIiwiX2tleWZyYW1lc1J1bGVUcmFuc2Zvcm1lciIsImtleWZyYW1lc05hbWVSeCIsInRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSIsInNjb3BlSWQiLCJhcHBseUVsZW1lbnRTY29wZVNlbGVjdG9yIiwiYXBwbHlFbGVtZW50U3R5bGUiLCJhcHBseUN1c3RvbVN0eWxlIiwiYml0cyIsInBhcnNlSW50IiwicGxhY2Vob2xkZXJNYXAiLCJnZXRTdHlsZVBsYWNlaG9sZGVyIiwiZW5zdXJlU3R5bGVQbGFjZWhvbGRlciIsImNlIiwib3JpZ0RlZmluZSIsIndyYXBwZWREZWZpbmUiLCJjbGF6eiIsIlN0eWxlQ2FjaGUiLCJ0eXBlTWF4IiwiY2FjaGUiLCJfdmFsaWRhdGUiLCJjYWNoZUVudHJ5Iiwib3duUHJvcGVydHlOYW1lcyIsInBuIiwic3RvcmUiLCJ0YWduYW1lIiwic3R5bGVFbGVtZW50IiwiZmV0Y2giLCJlbnRyeSIsImdldENsYXNzZXMiLCJzY29wZVJlZ0V4cCIsImdldEN1cnJlbnRTY29wZSIsImdldE93bmVyU2NvcGUiLCJlbnN1cmVDb3JyZWN0U2NvcGUiLCJvd25lclNjb3BlIiwiZW5zdXJlQ29ycmVjdFN1YnRyZWVTY29waW5nIiwidW5zY29wZWROb2RlcyIsInVuc2NvcGVkTm9kZSIsInNjb3BlRm9yUHJldmlvdXNseVVuc2NvcGVkTm9kZSIsImlzRWxlbWVudFdpdGhCdWlsdENzcyIsImVsIiwiaGFuZGxlciIsIm14bnMiLCJteG4iLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwibmF0aXZlQ3VzdG9tRWxlbWVudHMiLCJkZWxheWVkU3RhcnQiLCJib2R5IiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwidGVtcGxhdGVNYXAiLCJDVVJSRU5UX1ZFUlNJT04iLCJORVhUX1ZFUlNJT04iLCJWQUxJREFUSU5HX1ZFUlNJT04iLCJwcm9taXNlIiwiUHJvbWlzZSIsInJlc29sdmUiLCJpbnZhbGlkYXRlIiwiaW52YWxpZGF0ZVRlbXBsYXRlIiwiaXNWYWxpZCIsInRlbXBsYXRlSXNWYWxpZCIsImlzVmFsaWRhdGluZyIsInRlbXBsYXRlSXNWYWxpZGF0aW5nIiwic3RhcnRWYWxpZGF0aW5nIiwic3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUiLCJfdmFsaWRhdGluZyIsInRoZW4iLCJlbGVtZW50c0FyZUludmFsaWQiLCJ1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzIiwicmVtb3ZlUHJvcGVydHkiLCJzZXRQcm9wZXJ0eSIsImdldENvbXB1dGVkU3R5bGVWYWx1ZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZGV0ZWN0TWl4aW4iLCJyZWFkeVByb21pc2UiLCJ3aGVuUmVhZHkiLCJyZXNvbHZlRm4iLCJkb2N1bWVudFdhaXQiLCJDdXN0b21TdHlsZVByb3ZpZGVyIiwiU0VFTl9NQVJLRVIiLCJDQUNIRURfU1RZTEUiLCJ0cmFuc2Zvcm1GbiIsInZhbGlkYXRlRm4iLCJDdXN0b21TdHlsZUludGVyZmFjZSIsImVucXVldWVEb2N1bWVudFZhbGlkYXRpb24iLCJhZGRDdXN0b21TdHlsZSIsImdldFN0eWxlRm9yQ3VzdG9tU3R5bGUiLCJwcm9jZXNzU3R5bGVzIiwiY3MiLCJzdHlsZVRvVHJhbnNmb3JtIiwibmVlZHNFbnF1ZXVlIiwiQ3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2UiLCJhZG9wdGVkQ3NzVGV4dE1hcCIsInN0eWxlQ2FjaGUiLCJTY29waW5nU2hpbSIsIl9zY29wZUNvdW50ZXIiLCJfZG9jdW1lbnRPd25lciIsIl9kb2N1bWVudE93bmVyU3R5bGVJbmZvIiwiX2VsZW1lbnRzSGF2ZUFwcGxpZWQiLCJfYXBwbHlTaGltIiwiX2N1c3RvbVN0eWxlSW50ZXJmYWNlIiwid2F0Y2hlckZsdXNoIiwiX2dlbmVyYXRlU2NvcGVTZWxlY3RvciIsImdldFN0eWxlQXN0Iiwic3R5bGVBc3RUb1N0cmluZyIsIl9nYXRoZXJTdHlsZXMiLCJwcmVwYXJlVGVtcGxhdGUiLCJwcmVwYXJlVGVtcGxhdGVEb20iLCJwcmVwYXJlVGVtcGxhdGVTdHlsZXMiLCJfcHJlcGFyZWQiLCJvcHRpbWFsQnVpbGQiLCJfZW5zdXJlIiwiaGFzTWl4aW5zIiwiX2dlbmVyYXRlU3RhdGljU3R5bGUiLCJfc3R5bGUiLCJfb3duUHJvcGVydHlOYW1lcyIsInByZXBhcmVBZG9wdGVkQ3NzVGV4dCIsImNzc1RleHRBcnJheSIsIl9kb21QcmVwYXJlZCIsInNoYWRvd3Jvb3QiLCJfcHJlcGFyZUhvc3QiLCJfZW5zdXJlQXBwbHlTaGltIiwiQXBwbHlTaGltIiwiQXBwbHlTaGltVXRpbHMiLCJfZW5zdXJlQ3VzdG9tU3R5bGVJbnRlcmZhY2UiLCJ0cmFuc2Zvcm1DdXN0b21TdHlsZUZvckRvY3VtZW50IiwiZmx1c2hDdXN0b21TdHlsZXMiLCJjdXN0b21TdHlsZXMiLCJfdXBkYXRlUHJvcGVydGllcyIsIl9hcHBseUN1c3RvbVN0eWxlcyIsInN0eWxlRG9jdW1lbnQiLCJfcmV2YWxpZGF0ZUN1c3RvbVN0eWxlQXBwbHlTaGltIiwib3ZlcnJpZGVQcm9wcyIsIl9taXhPdmVycmlkZVN0eWxlUHJvcHMiLCJzdHlsZUVsZW1lbnROYXRpdmVWYXJpYWJsZXMiLCJfaXNSb290T3duZXIiLCJzdHlsZUVsZW1lbnRTaGltVmFyaWFibGVzIiwiX2FwcGx5U3R5bGVQcm9wZXJ0aWVzIiwiX3N0eWxlT3duZXJGb3JOb2RlIiwiY2FjaGVkU2NvcGVTZWxlY3RvciIsImNhY2hlZFN0eWxlIiwib2xkU2NvcGVTZWxlY3RvciIsIm93bmVyIiwib3duZXJTdHlsZUluZm8iLCJvd25lclByb3BlcnRpZXMiLCJob3N0QW5kUm9vdFByb3BzIiwicHJvcGVydHlEYXRhIiwicHJvcGVydGllc01hdGNoaW5nSG9zdCIsIl9taXhpbk92ZXJyaWRlU3R5bGVzIiwib3ZlcnJpZGVzIiwic3R5bGVTdWJ0cmVlIiwid3JhcHBlZEhvc3QiLCJzaGFkb3dDaGlsZHJlbiIsIl9yZXZhbGlkYXRlQXBwbHlTaGltIiwic2V0RWxlbWVudENsYXNzIiwiY2xhc3NTdHJpbmciLCJjbGFzc2VzIiwic2NvcGVOYW1lIiwiY2xhc3NBdHRyIiwiayQiLCJfc3R5bGVJbmZvRm9yTm9kZSIsInNjb3BlTm9kZSIsInVuc2NvcGVOb2RlIiwic2NvcGVGb3JOb2RlIiwiZWxlbWVudEV4dGVuZHMiLCJyZXNlcnZlZFRhZ0xpc3QiLCJpc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUiLCJyZXNlcnZlZCIsInZhbGlkRm9ybSIsIm5hdGl2ZVZhbHVlIiwiX19DRV9pc0ltcG9ydERvY3VtZW50IiwibmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyIsIndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzIiwidmlzaXRlZEltcG9ydHMiLCJpbXBvcnQiLCJfX0NFX3NoYWRvd1Jvb3QiLCJzZXRQcm9wZXJ0eVVuY2hlY2tlZCIsImRlc3RpbmF0aW9uIiwiQ3VzdG9tRWxlbWVudFN0YXRlIiwiY3VzdG9tIiwiZmFpbGVkIiwiQ3VzdG9tRWxlbWVudEludGVybmFscyIsIl9sb2NhbE5hbWVUb0RlZmluaXRpb24iLCJfY29uc3RydWN0b3JUb0RlZmluaXRpb24iLCJfcGF0Y2hlc05vZGUiLCJfcGF0Y2hlc0VsZW1lbnQiLCJfaGFzUGF0Y2hlcyIsInNldERlZmluaXRpb24iLCJkZWZpbml0aW9uIiwiY29uc3RydWN0b3JGdW5jdGlvbiIsImxvY2FsTmFtZVRvRGVmaW5pdGlvbiIsImNvbnN0cnVjdG9yVG9EZWZpbml0aW9uIiwiYWRkTm9kZVBhdGNoIiwiYWRkRWxlbWVudFBhdGNoIiwicGF0Y2hUcmVlIiwiVXRpbGl0aWVzIiwicGF0Y2hFbGVtZW50IiwicGF0Y2hOb2RlIiwiX19DRV9wYXRjaGVkIiwiY29ubmVjdFRyZWUiLCJlbGVtZW50cyIsIl9fQ0Vfc3RhdGUiLCJDRVN0YXRlIiwidXBncmFkZUVsZW1lbnQiLCJkaXNjb25uZWN0VHJlZSIsInBhdGNoQW5kVXBncmFkZVRyZWUiLCJ1cGdyYWRlIiwiZ2F0aGVyRWxlbWVudHMiLCJfX0NFX2hhc1JlZ2lzdHJ5IiwiX19DRV9kb2N1bWVudExvYWRIYW5kbGVkIiwiY2xvbmVkVmlzaXRlZEltcG9ydHMiLCJjdXJyZW50U3RhdGUiLCJkZWZhdWx0VmlldyIsImNvbnN0cnVjdGlvblN0YWNrIiwiX19DRV9kZWZpbml0aW9uIiwiYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrIiwib2JzZXJ2ZWRBdHRyaWJ1dGVzIiwib2xkVmFsdWUiLCJuYW1lc3BhY2UiLCJEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyIiwiaW50ZXJuYWxzIiwiX2ludGVybmFscyIsIl9kb2N1bWVudCIsIl9oYW5kbGVNdXRhdGlvbnMiLCJkaXNjb25uZWN0IiwiRGVmZXJyZWQiLCJfdmFsdWUiLCJfcmVzb2x2ZSIsIl9wcm9taXNlIiwidG9Qcm9taXNlIiwiQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5IiwiX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nIiwiX3doZW5EZWZpbmVkRGVmZXJyZWQiLCJfZmx1c2hDYWxsYmFjayIsIl9mbHVzaFBlbmRpbmciLCJfcGVuZGluZ0RlZmluaXRpb25zIiwiX2RvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIiLCJGdW5jdGlvbiIsIlN5bnRheEVycm9yIiwiYWRvcHRlZENhbGxiYWNrIiwiZ2V0Q2FsbGJhY2siLCJjYWxsYmFja1ZhbHVlIiwiX2ZsdXNoIiwicGVuZGluZ0RlZmluaXRpb25zIiwiZWxlbWVudHNXaXRoU3RhYmxlRGVmaW5pdGlvbnMiLCJlbGVtZW50c1dpdGhQZW5kaW5nRGVmaW5pdGlvbnMiLCJwZW5kaW5nRWxlbWVudHMiLCJwZW5kaW5nVXBncmFkYWJsZUVsZW1lbnRzIiwiZGVmZXJyZWQiLCJ3aGVuRGVmaW5lZCIsInJlamVjdCIsInByaW9yIiwic29tZSIsInBvbHlmaWxsV3JhcEZsdXNoQ2FsbGJhY2siLCJvdXRlciIsIkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQiLCJEb2N1bWVudF9jcmVhdGVFbGVtZW50TlMiLCJEb2N1bWVudF9pbXBvcnROb2RlIiwiRG9jdW1lbnRfcHJlcGVuZCIsIkRvY3VtZW50X2FwcGVuZCIsIkRvY3VtZW50RnJhZ21lbnRfcHJlcGVuZCIsIkRvY3VtZW50RnJhZ21lbnRfYXBwZW5kIiwiTm9kZV9jbG9uZU5vZGUiLCJOb2RlX2FwcGVuZENoaWxkIiwiTm9kZV9pbnNlcnRCZWZvcmUiLCJOb2RlX3JlbW92ZUNoaWxkIiwiTm9kZV9yZXBsYWNlQ2hpbGQiLCJOb2RlX3RleHRDb250ZW50IiwiRWxlbWVudF9hdHRhY2hTaGFkb3ciLCJFbGVtZW50X2lubmVySFRNTCIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlIiwiRWxlbWVudF9zZXRBdHRyaWJ1dGUiLCJFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZSIsIkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMiLCJnZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfc2V0QXR0cmlidXRlTlMiLCJzZXRBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsIkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUwiLCJFbGVtZW50X3ByZXBlbmQiLCJFbGVtZW50X2FwcGVuZCIsIkVsZW1lbnRfYmVmb3JlIiwiRWxlbWVudF9hZnRlciIsIkVsZW1lbnRfcmVwbGFjZVdpdGgiLCJFbGVtZW50X3JlbW92ZSIsIkhUTUxFbGVtZW50X2lubmVySFRNTCIsIkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCIsIkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50SFRNTCIsIkFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciIsIk5hdGl2ZSIsInNldFByb3RvdHlwZU9mIiwidG9Db25zdHJ1Y3RFbGVtZW50Iiwid3JpdGFibGUiLCJQYXJlbnROb2RlTmF0aXZlTWV0aG9kcyIsImJ1aWx0SW4iLCJhcHBlbmRQcmVwZW5kUGF0Y2giLCJidWlsdEluTWV0aG9kIiwiY29ubmVjdGVkRWxlbWVudHMiLCJhcHBseSIsInByZXBlbmQiLCJhcHBlbmQiLCJjbG9uZSIsIk5TX0hUTUwiLCJQYXRjaFBhcmVudE5vZGUiLCJpbnNlcnRlZE5vZGVzIiwibmF0aXZlUmVzdWx0Iiwibm9kZVdhc0Nvbm5lY3RlZCIsIm5vZGVUb0luc2VydCIsIm5vZGVUb1JlbW92ZSIsIm5vZGVUb0luc2VydFdhc0Nvbm5lY3RlZCIsInRoaXNJc0Nvbm5lY3RlZCIsInBhdGNoX3RleHRDb250ZW50IiwiYmFzZURlc2NyaXB0b3IiLCJhc3NpZ25lZFZhbHVlIiwiY2hpbGROb2Rlc0xlbmd0aCIsImNoaWxkTm9kZSIsIkNoaWxkTm9kZU5hdGl2ZU1ldGhvZHMiLCJiZWZvcmVBZnRlclBhdGNoIiwicmVwbGFjZVdpdGgiLCJ3YXNDb25uZWN0ZWQiLCJpbml0IiwicGF0Y2hfaW5uZXJIVE1MIiwiaHRtbFN0cmluZyIsInJlbW92ZWRFbGVtZW50cyIsImlzVGVtcGxhdGUiLCJyYXdFbGVtZW50IiwicGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50IiwiYmFzZU1ldGhvZCIsImluc2VydGVkRWxlbWVudCIsIndhcm4iLCJwYXRjaF9pbnNlcnRBZGphY2VudEhUTUwiLCJ1cGdyYWRlTm9kZXNJblJhbmdlIiwidG9Mb3dlckNhc2UiLCJtYXJrZXIiLCJTdHJpbmciLCJQYXRjaENoaWxkTm9kZSIsInByaW9yQ3VzdG9tRWxlbWVudHMiLCJQYXRjaEhUTUxFbGVtZW50IiwiUGF0Y2hEb2N1bWVudCIsIlBhdGNoRG9jdW1lbnRGcmFnbWVudCIsIlBhdGNoTm9kZSIsIlBhdGNoRWxlbWVudCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7Ozs7Ozs7O0FBV08sTUFBTUEsU0FBTixDQUFnQjtBQUVyQjtBQUNBQyxRQUFNLEdBQUc7QUFDUCxXQUFPLEVBQVA7QUFDRDs7QUFMb0I7QUFRaEIsU0FBU0Msc0JBQVQsQ0FBZ0NDLElBQWhDLEVBQXNDO0FBQzNDLE1BQUksQ0FBQ0EsSUFBSSxDQUFDQyxPQUFWLEVBQW1CO0FBQ2pCRCxRQUFJLENBQUNDLE9BQUwsR0FBZSxJQUFJSixTQUFKLEVBQWY7QUFDRDs7QUFDRCxTQUFPRyxJQUFJLENBQUNDLE9BQVo7QUFDRDtBQUVNLFNBQVNDLGdCQUFULENBQTBCRixJQUExQixFQUFnQztBQUNyQyxTQUFPQSxJQUFJLElBQUlBLElBQUksQ0FBQ0MsT0FBcEI7QUFDRCxDOztBQzVCRDs7Ozs7Ozs7O0FBU0E7QUFFQTs7QUFDTyxNQUFNRSxRQUFRLEdBQUdDLE1BQU0sQ0FBQyxVQUFELENBQU4sSUFBc0IsRUFBdkM7QUFFUEQsUUFBUSxDQUFDRSxrQkFBVCxHQUE4QkMsT0FBTyxDQUFDQyxPQUFPLENBQUNDLFNBQVIsQ0FBa0JDLFlBQWxCLElBQWtDQyxJQUFJLENBQUNGLFNBQUwsQ0FBZUcsV0FBbEQsQ0FBckM7QUFFQSxNQUFNQyxJQUFJLEdBQUdDLE1BQU0sQ0FBQ0Msd0JBQVAsQ0FBZ0NKLElBQUksQ0FBQ0YsU0FBckMsRUFBZ0QsWUFBaEQsQ0FBYjtBQUVBTCxRQUFRLENBQUNZ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aUMsVUFBUSxDQUFDOGhDLGdCQUFULEdBQTRCLElBQTVCO0FBRUE7O0FBQ0EsUUFBTXpnQixjQUFjLEdBQUcsSUFBSStoQiwyQ0FBSixDQUEwQlYsU0FBMUIsQ0FBdkI7QUFFQWhsQyxRQUFNLENBQUNrRixjQUFQLENBQXNCM0YsTUFBdEIsRUFBOEIsZ0JBQTlCLEVBQWdEO0FBQzlDWSxnQkFBWSxFQUFFLElBRGdDO0FBRTlDd04sY0FBVSxFQUFFLElBRmtDO0FBRzlDMUksU0FBSyxFQUFFMGU7QUFIdUMsR0FBaEQ7QUFLRCxDIiwiZmlsZSI6IjAuNGI3Mjg1NTY5MzUwODg4ZjI2NWMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5cbmV4cG9ydCBjbGFzcyBTaGFkeURhdGEge1xuXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShub2RlKSB7XG4gIGlmICghbm9kZS5fX3NoYWR5KSB7XG4gICAgbm9kZS5fX3NoYWR5ID0gbmV3IFNoYWR5RGF0YSgpO1xuICB9XG4gIHJldHVybiBub2RlLl9fc2hhZHk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaGFkeURhdGFGb3JOb2RlKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5fX3NoYWR5O1xufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCB7c2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi9zaGFkeS1kYXRhLmpzJztcblxuLyoqIEB0eXBlIHshT2JqZWN0fSAqL1xuZXhwb3J0IGNvbnN0IHNldHRpbmdzID0gd2luZG93WydTaGFkeURPTSddIHx8IHt9O1xuXG5zZXR0aW5ncy5oYXNOYXRpdmVTaGFkb3dET00gPSBCb29sZWFuKEVsZW1lbnQucHJvdG90eXBlLmF0dGFjaFNoYWRvdyAmJiBOb2RlLnByb3RvdHlwZS5nZXRSb290Tm9kZSk7XG5cbmNvbnN0IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE5vZGUucHJvdG90eXBlLCAnZmlyc3RDaGlsZCcpO1xuXG5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycyA9IEJvb2xlYW4oZGVzYyAmJiBkZXNjLmNvbmZpZ3VyYWJsZSAmJiBkZXNjLmdldCk7XG5zZXR0aW5ncy5pblVzZSA9IHNldHRpbmdzWydmb3JjZSddIHx8ICFzZXR0aW5ncy5oYXNOYXRpdmVTaGFkb3dET007XG5zZXR0aW5ncy5ub1BhdGNoID0gc2V0dGluZ3NbJ25vUGF0Y2gnXSB8fCBmYWxzZTtcbnNldHRpbmdzLnByZWZlclBlcmZvcm1hbmNlID0gc2V0dGluZ3NbJ3ByZWZlclBlcmZvcm1hbmNlJ107XG5cbmNvbnN0IElTX0lFID0gbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgnVHJpZGVudCcpO1xuc2V0dGluZ3MuSVNfSUUgPSBJU19JRTtcblxuZXhwb3J0IGNvbnN0IGNhblVwZ3JhZGUgPSAoKSA9PiAhc2V0dGluZ3MuSVNfSUU7XG5cbmV4cG9ydCBjb25zdCBpc1RyYWNraW5nTG9naWNhbENoaWxkTm9kZXMgPSAobm9kZSkgPT4ge1xuICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIHJldHVybiAobm9kZURhdGEgJiYgbm9kZURhdGEuZmlyc3RDaGlsZCAhPT0gdW5kZWZpbmVkKTtcbn1cblxuZXhwb3J0IGNvbnN0IGlzU2hhZHlSb290ID0gKG9iaikgPT4ge1xuICByZXR1cm4gQm9vbGVhbihvYmouX2xvY2FsTmFtZSA9PT0gJ1NoYWR5Um9vdCcpO1xufVxuXG5leHBvcnQgY29uc3QgaGFzU2hhZG93Um9vdFdpdGhTbG90ID0gKG5vZGUpID0+IHtcbiAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBsZXQgcm9vdCA9IG5vZGVEYXRhICYmIG5vZGVEYXRhLnJvb3Q7XG4gIHJldHVybiAocm9vdCAmJiByb290Ll9oYXNJbnNlcnRpb25Qb2ludCgpKTtcbn1cblxubGV0IHAgPSBFbGVtZW50LnByb3RvdHlwZTtcbmxldCBtYXRjaGVzID0gcC5tYXRjaGVzIHx8IHAubWF0Y2hlc1NlbGVjdG9yIHx8XG4gIHAubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHAubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgcC5vTWF0Y2hlc1NlbGVjdG9yIHx8IHAud2Via2l0TWF0Y2hlc1NlbGVjdG9yO1xuXG5leHBvcnQgY29uc3QgbWF0Y2hlc1NlbGVjdG9yID0gKGVsZW1lbnQsIHNlbGVjdG9yKSA9PiB7XG4gIHJldHVybiBtYXRjaGVzLmNhbGwoZWxlbWVudCwgc2VsZWN0b3IpO1xufVxuXG5leHBvcnQgY29uc3QgbWl4aW4gPSAodGFyZ2V0LCBzb3VyY2UpID0+IHtcbiAgZm9yICh2YXIgaSBpbiBzb3VyY2UpIHtcbiAgICB0YXJnZXRbaV0gPSBzb3VyY2VbaV07XG4gIH1cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLy8gTk9URSwgcHJlZmVyIE11dGF0aW9uT2JzZXJ2ZXIgb3ZlciBQcm9taXNlIGZvciBtaWNyb3Rhc2sgdGltaW5nXG4vLyBmb3IgY29uc2lzdGVuY3kgeC1wbGF0Zm9ybS5cbmxldCB0d2lkZGxlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xubGV0IGNvbnRlbnQgPSAwO1xubGV0IHF1ZXVlID0gW107XG5uZXcgTXV0YXRpb25PYnNlcnZlcigoKSA9PiB7XG4gIHdoaWxlIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAvLyBjYXRjaCBlcnJvcnMgaW4gdXNlciBjb2RlLi4uXG4gICAgdHJ5IHtcbiAgICAgIHF1ZXVlLnNoaWZ0KCkoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIC8vIGVucXVldWUgYW5vdGhlciByZWNvcmQgYW5kIHRocm93XG4gICAgICB0d2lkZGxlLnRleHRDb250ZW50ID0gY29udGVudCsrO1xuICAgICAgdGhyb3coZSk7XG4gICAgfVxuICB9XG59KS5vYnNlcnZlKHR3aWRkbGUsIHtjaGFyYWN0ZXJEYXRhOiB0cnVlfSk7XG5cbi8vIHVzZSBNdXRhdGlvbk9ic2VydmVyIHRvIGdldCBtaWNyb3Rhc2sgYXN5bmMgdGltaW5nLlxuZXhwb3J0IGNvbnN0IG1pY3JvdGFzayA9IChjYWxsYmFjaykgPT4ge1xuICBxdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgdHdpZGRsZS50ZXh0Q29udGVudCA9IGNvbnRlbnQrKztcbn1cblxuZXhwb3J0IGNvbnN0IGhhc0RvY3VtZW50Q29udGFpbnMgPSBCb29sZWFuKGRvY3VtZW50LmNvbnRhaW5zKTtcblxuZXhwb3J0IGNvbnN0IGNvbnRhaW5zID0gKGNvbnRhaW5lciwgbm9kZSkgPT4ge1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlID09IGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIG5vZGUgPSBub2RlW1NIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5jb25zdCBnZXROb2RlSFRNTENvbGxlY3Rpb25OYW1lID0gKG5vZGUpID0+XG4gICAgbm9kZS5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgbm9kZS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcblxuY29uc3QgaXNWYWxpZEhUTUxDb2xsZWN0aW9uTmFtZSA9IChuYW1lKSA9PiBuYW1lICE9PSAnbGVuZ3RoJyAmJiBpc05hTihuYW1lKTtcblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVBvbHlmaWxsZWRIVE1MQ29sbGVjdGlvbiA9IChub2RlcykgPT4ge1xuICAvLyBOb3RlOiBsb29wIGluIHJldmVyc2Ugc28gdGhhdCB0aGUgZmlyc3QgbmFtZWQgaXRlbSBtYXRjaGVzIHRoZSBuYW1lZCBwcm9wZXJ0eVxuICBmb3IgKGxldCBsID0gbm9kZXMubGVuZ3RoIC0gMTsgbCA+PSAwOyBsLS0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZXNbbF07XG4gICAgY29uc3QgbmFtZSA9IGdldE5vZGVIVE1MQ29sbGVjdGlvbk5hbWUobm9kZSk7XG5cbiAgICBpZiAobmFtZSAmJiBpc1ZhbGlkSFRNTENvbGxlY3Rpb25OYW1lKG5hbWUpKSB7XG4gICAgICBub2Rlc1tuYW1lXSA9IG5vZGU7XG4gICAgfVxuICB9XG4gIG5vZGVzLml0ZW0gPSBmdW5jdGlvbihpbmRleCkge1xuICAgIHJldHVybiBub2Rlc1tpbmRleF07XG4gIH1cbiAgbm9kZXMubmFtZWRJdGVtID0gZnVuY3Rpb24obmFtZSkge1xuICAgIGlmIChpc1ZhbGlkSFRNTENvbGxlY3Rpb25OYW1lKG5hbWUpICYmIG5vZGVzW25hbWVdKSB7XG4gICAgICByZXR1cm4gbm9kZXNbbmFtZV07XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICBjb25zdCBub2RlTmFtZSA9IGdldE5vZGVIVE1MQ29sbGVjdGlvbk5hbWUobm9kZSk7XG5cbiAgICAgIGlmIChub2RlTmFtZSA9PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICByZXR1cm4gbm9kZXM7XG59XG5cbmV4cG9ydCBjb25zdCBOQVRJVkVfUFJFRklYID0gJ19fc2hhZHlfbmF0aXZlXyc7XG5leHBvcnQgY29uc3QgU0hBRFlfUFJFRklYID0gJ19fc2hhZHlfJztcblxuZXhwb3J0IGNvbnN0IG5hdGl2ZUNoaWxkTm9kZXNBcnJheSA9IChwYXJlbnQpID0+IHtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IG49cGFyZW50W05BVElWRV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuID0gbltOQVRJVkVfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICByZXN1bHQucHVzaChuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgY29uc3QgY2hpbGROb2Rlc0FycmF5ID0gKHBhcmVudCkgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgbj1wYXJlbnRbU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICByZXN1bHQucHVzaChuKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIFBhdGNoIGEgZ3JvdXAgb2YgYWNjZXNzb3JzIG9uIGFuIG9iamVjdCBvbmx5IGlmIGl0IGV4aXN0cyBvciBpZiB0aGUgYGZvcmNlYFxuICogYXJndW1lbnQgaXMgdHJ1ZS5cbiAqIEBwYXJhbSB7IU9iamVjdH0gcHJvdG9cbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzY3JpcHRvcnNcbiAqIEBwYXJhbSB7c3RyaW5nPX0gcHJlZml4XG4gKiBAcGFyYW0ge0FycmF5PX0gZGlzYWxsb3dlZFBhdGNoZXNcbiAqL1xuZXhwb3J0IGNvbnN0IHBhdGNoUHJvcGVydGllcyA9IChwcm90bywgZGVzY3JpcHRvcnMsIHByZWZpeCA9ICcnLCBkaXNhbGxvd2VkUGF0Y2hlcykgPT4ge1xuICBmb3IgKGxldCBwIGluIGRlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgbmV3RGVzY3JpcHRvciA9IGRlc2NyaXB0b3JzW3BdO1xuICAgIGlmIChkaXNhbGxvd2VkUGF0Y2hlcyAmJiBkaXNhbGxvd2VkUGF0Y2hlcy5pbmRleE9mKHApID49IDApIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBuZXdEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgY29uc3QgbmFtZSA9IHByZWZpeCArIHA7XG4gICAgLy8gTk9URTogd2UgcHJlZmVyIHdyaXRpbmcgZGlyZWN0bHkgYmVjYXVzZSBzb21lIGJyb3dzZXJzXG4gICAgLy8gaGF2ZSBkZXNjcmlwdG9ycyB0aGF0IGFyZSB3cml0YWJsZSBidXQgbm90IGNvbmZpZ3VyYWJsZSAoZS5nLlxuICAgIC8vIGBhcHBlbmRDaGlsZGAgb24gb2xkZXIgYnJvd3NlcnMpXG4gICAgaWYgKG5ld0Rlc2NyaXB0b3IudmFsdWUpIHtcbiAgICAgIHByb3RvW25hbWVdID0gbmV3RGVzY3JpcHRvci52YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTk9URTogdGhpcyBjYW4gdGhyb3cgaWYgJ2ZvcmNlJyBpcyB1c2VkIHNvIGNhdGNoIHRoZSBlcnJvci5cbiAgICAgIHRyeSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgbmFtZSwgbmV3RGVzY3JpcHRvcik7XG4gICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gdGhpcyBlcnJvciBpcyBoYXJtbGVzcyBzbyB3ZSBqdXN0IHRyYXAgaXQuXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKiBAdHlwZSB7IWZ1bmN0aW9uKG5ldzpIVE1MRWxlbWVudCl9ICovXG5leHBvcnQgY29uc3QgTmF0aXZlSFRNTEVsZW1lbnQgPVxuICAgICh3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ10gJiYgd2luZG93WydjdXN0b21FbGVtZW50cyddWyduYXRpdmVIVE1MRWxlbWVudCddKSB8fFxuICAgIEhUTUxFbGVtZW50O1xuXG4vLyBub3RlLCB0aGlzIGlzIG5vdCBhIHBlcmZlY3QgcG9seWZpbGwgc2luY2UgaXQgZG9lc24ndCBpbmNsdWRlIHN5bWJvbHNcbi8qKiBAcmV0dXJuIHshT2JqZWN0PCFPYmplY3RQcm9wZXJ0eURlc2NyaXB0b3I+fSAqL1xuZXhwb3J0IGNvbnN0IGdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPSAob2JqKSA9PiB7XG4gIGNvbnN0IGRlc2NyaXB0b3JzID0ge307XG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGRlc2NyaXB0b3JzW25hbWVdID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIG5hbWUpO1xuICB9KTtcbiAgcmV0dXJuIGRlc2NyaXB0b3JzO1xufTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuXG4vLyByZW5kZXIgZW5xdWV1ZXIvZmx1c2hlclxubGV0IGZsdXNoTGlzdCA9IFtdO1xubGV0IHNjaGVkdWxlZDtcbmV4cG9ydCBmdW5jdGlvbiBlbnF1ZXVlKGNhbGxiYWNrKSB7XG4gIGlmICghc2NoZWR1bGVkKSB7XG4gICAgc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICB1dGlscy5taWNyb3Rhc2soZmx1c2gpO1xuICB9XG4gIGZsdXNoTGlzdC5wdXNoKGNhbGxiYWNrKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZsdXNoKCkge1xuICBzY2hlZHVsZWQgPSBmYWxzZTtcbiAgbGV0IGRpZEZsdXNoID0gQm9vbGVhbihmbHVzaExpc3QubGVuZ3RoKTtcbiAgd2hpbGUgKGZsdXNoTGlzdC5sZW5ndGgpIHtcbiAgICBmbHVzaExpc3Quc2hpZnQoKSgpO1xuICB9XG4gIHJldHVybiBkaWRGbHVzaDtcbn1cblxuZmx1c2hbJ2xpc3QnXSA9IGZsdXNoTGlzdDtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtlbnN1cmVTaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuL3NoYWR5LWRhdGEuanMnO1xuXG5jbGFzcyBBc3luY09ic2VydmVyIHtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmFkZGVkTm9kZXMgPSBbXTtcbiAgICB0aGlzLnJlbW92ZWROb2RlcyA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgc2NoZWR1bGUoKSB7XG4gICAgaWYgKCF0aGlzLl9zY2hlZHVsZWQpIHtcbiAgICAgIHRoaXMuX3NjaGVkdWxlZCA9IHRydWU7XG4gICAgICB1dGlscy5taWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5fc2NoZWR1bGVkKSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgIGxldCBtdXRhdGlvbnMgPSB0aGlzLnRha2VSZWNvcmRzKCk7XG4gICAgICBpZiAobXV0YXRpb25zLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmNhbGxiYWNrcy5mb3JFYWNoKGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgY2IobXV0YXRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdGFrZVJlY29yZHMoKSB7XG4gICAgaWYgKHRoaXMuYWRkZWROb2Rlcy5sZW5ndGggfHwgdGhpcy5yZW1vdmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICBsZXQgbXV0YXRpb25zID0gW3tcbiAgICAgICAgYWRkZWROb2RlczogdGhpcy5hZGRlZE5vZGVzLFxuICAgICAgICByZW1vdmVkTm9kZXM6IHRoaXMucmVtb3ZlZE5vZGVzXG4gICAgICB9XTtcbiAgICAgIHRoaXMuYWRkZWROb2RlcyA9IFtdO1xuICAgICAgdGhpcy5yZW1vdmVkTm9kZXMgPSBbXTtcbiAgICAgIHJldHVybiBtdXRhdGlvbnM7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuXG59XG5cbi8vIFRPRE8oc29ydmVsbCk6IGNvbnNpZGVyIGluc3RlYWQgcG9seWZpbGxpbmcgTXV0YXRpb25PYnNlcnZlclxuLy8gZGlyZWN0bHkgc28gdGhhdCB1c2VycyBkbyBub3QgaGF2ZSB0byBmb3JrIHRoZWlyIGNvZGUuXG4vLyBTdXBwb3J0aW5nIHRoZSBlbnRpcmUgYXBpIG1heSBiZSBjaGFsbGVuZ2luZzogZS5nLiBmaWx0ZXJpbmcgb3V0XG4vLyByZW1vdmVkIG5vZGVzIGluIHRoZSB3cm9uZyBzY29wZSBhbmQgc2VlaW5nIG5vbi1kaXN0cmlidXRpbmdcbi8vIHN1YnRyZWUgY2hpbGQgbXV0YXRpb25zLlxuZXhwb3J0IGxldCBvYnNlcnZlQ2hpbGRyZW4gPSBmdW5jdGlvbihub2RlLCBjYWxsYmFjaykge1xuICBjb25zdCBzZCA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIGlmICghc2Qub2JzZXJ2ZXIpIHtcbiAgICBzZC5vYnNlcnZlciA9IG5ldyBBc3luY09ic2VydmVyKCk7XG4gIH1cbiAgc2Qub2JzZXJ2ZXIuY2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gIGxldCBvYnNlcnZlciA9IHNkLm9ic2VydmVyO1xuICByZXR1cm4ge1xuICAgIF9jYWxsYmFjazogY2FsbGJhY2ssXG4gICAgX29ic2VydmVyOiBvYnNlcnZlcixcbiAgICBfbm9kZTogbm9kZSxcbiAgICB0YWtlUmVjb3JkcygpIHtcbiAgICAgIHJldHVybiBvYnNlcnZlci50YWtlUmVjb3JkcygpXG4gICAgfVxuICB9O1xufVxuXG5leHBvcnQgbGV0IHVub2JzZXJ2ZUNoaWxkcmVuID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gIGxldCBvYnNlcnZlciA9IGhhbmRsZSAmJiBoYW5kbGUuX29ic2VydmVyO1xuICBpZiAob2JzZXJ2ZXIpIHtcbiAgICBvYnNlcnZlci5jYWxsYmFja3MuZGVsZXRlKGhhbmRsZS5fY2FsbGJhY2spO1xuICAgIGlmICghb2JzZXJ2ZXIuY2FsbGJhY2tzLnNpemUpIHtcbiAgICAgIGVuc3VyZVNoYWR5RGF0YUZvck5vZGUoaGFuZGxlLl9ub2RlKS5vYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJNdXRhdGlvbnMobXV0YXRpb25zLCB0YXJnZXQpIHtcbiAgLyoqIEBjb25zdCB7Tm9kZX0gKi9cbiAgY29uc3QgdGFyZ2V0Um9vdE5vZGUgPSB0YXJnZXQuZ2V0Um9vdE5vZGUoKTtcbiAgcmV0dXJuIG11dGF0aW9ucy5tYXAoZnVuY3Rpb24obXV0YXRpb24pIHtcbiAgICAvKiogQGNvbnN0IHtib29sZWFufSAqL1xuICAgIGNvbnN0IG11dGF0aW9uSW5TY29wZSA9ICh0YXJnZXRSb290Tm9kZSA9PT0gbXV0YXRpb24udGFyZ2V0LmdldFJvb3ROb2RlKCkpO1xuICAgIGlmIChtdXRhdGlvbkluU2NvcGUgJiYgbXV0YXRpb24uYWRkZWROb2Rlcykge1xuICAgICAgbGV0IG5vZGVzID0gQXJyYXkuZnJvbShtdXRhdGlvbi5hZGRlZE5vZGVzKS5maWx0ZXIoZnVuY3Rpb24obikge1xuICAgICAgICByZXR1cm4gKHRhcmdldFJvb3ROb2RlID09PSBuLmdldFJvb3ROb2RlKCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAobm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIG11dGF0aW9uID0gT2JqZWN0LmNyZWF0ZShtdXRhdGlvbik7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtdXRhdGlvbiwgJ2FkZGVkTm9kZXMnLCB7XG4gICAgICAgICAgdmFsdWU6IG5vZGVzLFxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG11dGF0aW9uO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXV0YXRpb25JblNjb3BlKSB7XG4gICAgICByZXR1cm4gbXV0YXRpb247XG4gICAgfVxuICB9KS5maWx0ZXIoZnVuY3Rpb24obSkgeyByZXR1cm4gbX0pO1xufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuLy8gQ3JpYmJlZCBmcm9tIFNoYWRvd0RPTSBwb2x5ZmlsbFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvd2ViY29tcG9uZW50c2pzL2Jsb2IvbWFzdGVyL3NyYy9TaGFkb3dET00vd3JhcHBlcnMvSFRNTEVsZW1lbnQuanMjTDI4XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gaW5uZXJIVE1MIGFuZCBvdXRlckhUTUxcblxuLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWVuZC5odG1sI2VzY2FwaW5nU3RyaW5nXG5sZXQgZXNjYXBlQXR0clJlZ0V4cCA9IC9bJlxcdTAwQTBcIl0vZztcbmxldCBlc2NhcGVEYXRhUmVnRXhwID0gL1smXFx1MDBBMDw+XS9nO1xuXG5mdW5jdGlvbiBlc2NhcGVSZXBsYWNlKGMpIHtcbiAgc3dpdGNoIChjKSB7XG4gICAgY2FzZSAnJic6XG4gICAgICByZXR1cm4gJyZhbXA7JztcbiAgICBjYXNlICc8JzpcbiAgICAgIHJldHVybiAnJmx0Oyc7XG4gICAgY2FzZSAnPic6XG4gICAgICByZXR1cm4gJyZndDsnO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgIHJldHVybiAnJnF1b3Q7JztcbiAgICBjYXNlICdcXHUwMEEwJzpcbiAgICAgIHJldHVybiAnJm5ic3A7JztcbiAgfVxufVxuXG5mdW5jdGlvbiBlc2NhcGVBdHRyKHMpIHtcbiAgcmV0dXJuIHMucmVwbGFjZShlc2NhcGVBdHRyUmVnRXhwLCBlc2NhcGVSZXBsYWNlKTtcbn1cblxuZnVuY3Rpb24gZXNjYXBlRGF0YShzKSB7XG4gIHJldHVybiBzLnJlcGxhY2UoZXNjYXBlRGF0YVJlZ0V4cCwgZXNjYXBlUmVwbGFjZSk7XG59XG5cbmZ1bmN0aW9uIG1ha2VTZXQoYXJyKSB7XG4gIGxldCBzZXQgPSB7fTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICBzZXRbYXJyW2ldXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIHNldDtcbn1cblxuLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay8jdm9pZC1lbGVtZW50c1xubGV0IHZvaWRFbGVtZW50cyA9IG1ha2VTZXQoW1xuICAnYXJlYScsXG4gICdiYXNlJyxcbiAgJ2JyJyxcbiAgJ2NvbCcsXG4gICdjb21tYW5kJyxcbiAgJ2VtYmVkJyxcbiAgJ2hyJyxcbiAgJ2ltZycsXG4gICdpbnB1dCcsXG4gICdrZXlnZW4nLFxuICAnbGluaycsXG4gICdtZXRhJyxcbiAgJ3BhcmFtJyxcbiAgJ3NvdXJjZScsXG4gICd0cmFjaycsXG4gICd3YnInXG5dKTtcblxubGV0IHBsYWludGV4dFBhcmVudHMgPSBtYWtlU2V0KFtcbiAgJ3N0eWxlJyxcbiAgJ3NjcmlwdCcsXG4gICd4bXAnLFxuICAnaWZyYW1lJyxcbiAgJ25vZW1iZWQnLFxuICAnbm9mcmFtZXMnLFxuICAncGxhaW50ZXh0JyxcbiAgJ25vc2NyaXB0J1xuXSk7XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudE5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFja1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MKG5vZGUsIHBhcmVudE5vZGUsIGNhbGxiYWNrKSB7XG4gIHN3aXRjaCAobm9kZS5ub2RlVHlwZSkge1xuICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6IHtcbiAgICAgIGxldCB0YWdOYW1lID0gbm9kZS5sb2NhbE5hbWU7XG4gICAgICBsZXQgcyA9ICc8JyArIHRhZ05hbWU7XG4gICAgICBsZXQgYXR0cnMgPSBub2RlLmF0dHJpYnV0ZXM7XG4gICAgICBmb3IgKGxldCBpID0gMCwgYXR0cjsgKGF0dHIgPSBhdHRyc1tpXSk7IGkrKykge1xuICAgICAgICBzICs9ICcgJyArIGF0dHIubmFtZSArICc9XCInICsgZXNjYXBlQXR0cihhdHRyLnZhbHVlKSArICdcIic7XG4gICAgICB9XG4gICAgICBzICs9ICc+JztcbiAgICAgIGlmICh2b2lkRWxlbWVudHNbdGFnTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIHM7XG4gICAgICB9XG4gICAgICByZXR1cm4gcyArIGdldElubmVySFRNTChub2RlLCBjYWxsYmFjaykgKyAnPC8nICsgdGFnTmFtZSArICc+JztcbiAgICB9XG4gICAgY2FzZSBOb2RlLlRFWFRfTk9ERToge1xuICAgICAgbGV0IGRhdGEgPSAvKiogQHR5cGUge1RleHR9ICovIChub2RlKS5kYXRhO1xuICAgICAgaWYgKHBhcmVudE5vZGUgJiYgcGxhaW50ZXh0UGFyZW50c1twYXJlbnROb2RlLmxvY2FsTmFtZV0pIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXNjYXBlRGF0YShkYXRhKTtcbiAgICB9XG4gICAgY2FzZSBOb2RlLkNPTU1FTlRfTk9ERToge1xuICAgICAgcmV0dXJuICc8IS0tJyArIC8qKiBAdHlwZSB7Q29tbWVudH0gKi8gKG5vZGUpLmRhdGEgKyAnLS0+JztcbiAgICB9XG4gICAgZGVmYXVsdDoge1xuICAgICAgd2luZG93LmNvbnNvbGUuZXJyb3Iobm9kZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbm5lckhUTUwobm9kZSwgY2FsbGJhY2spIHtcbiAgaWYgKG5vZGUubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgbm9kZSA9ICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChub2RlKS5jb250ZW50O1xuICB9XG4gIGxldCBzID0gJyc7XG4gIGxldCBjJCA9IGNhbGxiYWNrID8gY2FsbGJhY2sobm9kZSkgOiBub2RlLmNoaWxkTm9kZXM7XG4gIGZvciAobGV0IGk9MCwgbD1jJC5sZW5ndGgsIGNoaWxkOyAoaTxsKSAmJiAoY2hpbGQ9YyRbaV0pOyBpKyspIHtcbiAgICBzICs9IGdldE91dGVySFRNTChjaGlsZCwgbm9kZSwgY2FsbGJhY2spO1xuICB9XG4gIHJldHVybiBzO1xufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtwYXRjaFByb3BlcnRpZXN9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtnZXRJbm5lckhUTUx9IGZyb20gJy4vaW5uZXJIVE1MLmpzJztcblxuY29uc3QgaGFzRGVzY3JpcHRvcnMgPSB1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycztcbmV4cG9ydCBjb25zdCBOQVRJVkVfUFJFRklYID0gdXRpbHMuTkFUSVZFX1BSRUZJWDtcblxuLy8gT2JqZWN0IG9uIHdoaWNoIHJhdyBuYXRpdmUgbWV0aG9kcyBhcmUgc3RvcmVkLlxuLy8gZS5nLiBgbmF0aXZlTWV0aG9kcy5xdWVyeVNlbGVjdG9yLmNhbGwobm9kZSwgc2VsZWN0b3IpYFxuLy8gc2FtZSBhcyBgbm9kZS5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKWBcbmV4cG9ydCBjb25zdCBuYXRpdmVNZXRob2RzID0ge1xuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpc1tOQVRJVkVfUFJFRklYICsgJ3F1ZXJ5U2VsZWN0b3InXShzZWxlY3Rvcik7XG4gIH0sXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcikge1xuICAgIHJldHVybiB0aGlzW05BVElWRV9QUkVGSVggKyAncXVlcnlTZWxlY3RvckFsbCddKHNlbGVjdG9yKTtcbiAgfVxufTtcbi8vIE9iamVjdCBvbiB3aGljaCByYXcgbmF0aXZlIGFjY2Vzc29ycyBhcmUgYXZhaWxhYmxlIHZpYSBgYWNjZXNzb3JOYW1lKG5vZGUpYC5cbi8vIGUuZy4gYG5hdGl2ZVRyZWUuZmlyc3RDaGlsZChub2RlKWBcbi8vIHNhbWUgYXMgYG5vZGUuZmlyc3RDaGlsZGBcbmV4cG9ydCBjb25zdCBuYXRpdmVUcmVlID0ge307XG5cbmNvbnN0IGluc3RhbGxOYXRpdmVBY2Nlc3NvciA9IChuYW1lKSA9PiB7XG4gIG5hdGl2ZVRyZWVbbmFtZV0gPSAobm9kZSkgPT4gbm9kZVtOQVRJVkVfUFJFRklYICsgbmFtZV07XG59XG5cbmNvbnN0IGluc3RhbGxOYXRpdmVNZXRob2QgPSAobmFtZSwgZm4pID0+IHtcbiAgaWYgKCFuYXRpdmVNZXRob2RzW25hbWVdKSB7XG4gICAgbmF0aXZlTWV0aG9kc1tuYW1lXSA9IGZuO1xuICB9XG59XG5cblxuY29uc3QgZGVmaW5lTmF0aXZlQWNjZXNzb3JzID0gKHByb3RvLCBkZXNjcmlwdG9ycykgPT4ge1xuICBwYXRjaFByb3BlcnRpZXMocHJvdG8sIGRlc2NyaXB0b3JzLCBOQVRJVkVfUFJFRklYKTtcbiAgLy8gbWFrZSBuYXRpdmUgYWNjZXNzb3JzIGF2YWlsYWJsZSB0byB1c2Vyc1xuICBmb3IgKGxldCBwcm9wIGluIGRlc2NyaXB0b3JzKSB7XG4gICAgaW5zdGFsbE5hdGl2ZUFjY2Vzc29yKHByb3ApO1xuICB9XG59XG5cbmNvbnN0IGNvcHlQcm9wZXJ0aWVzID0gKHByb3RvLCBsaXN0ID0gW10pID0+IHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmFtZSA9IGxpc3RbaV07XG4gICAgY29uc3QgZGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG8sIG5hbWUpO1xuICAgIGlmIChkZXNjcmlwdG9yKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIE5BVElWRV9QUkVGSVggKyBuYW1lLCBkZXNjcmlwdG9yKTtcbiAgICAgIC8vIG1ha2UgbmF0aXZlIG1ldGhvZHMvYWNjZXNzb3JzIGF2YWlsYWJsZSB0byB1c2Vyc1xuICAgICAgaWYgKGRlc2NyaXB0b3IudmFsdWUpIHtcbiAgICAgICAgaW5zdGFsbE5hdGl2ZU1ldGhvZChuYW1lLCBkZXNjcmlwdG9yLnZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluc3RhbGxOYXRpdmVBY2Nlc3NvcihuYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqIEB0eXBlIHshVHJlZVdhbGtlcn0gKi9cbmNvbnN0IG5vZGVXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKGRvY3VtZW50LCBOb2RlRmlsdGVyLlNIT1dfQUxMLFxuICBudWxsLCBmYWxzZSk7XG5cbi8qKiBAdHlwZSB7IVRyZWVXYWxrZXJ9ICovXG5jb25zdCBlbGVtZW50V2Fsa2VyID0gZG9jdW1lbnQuY3JlYXRlVHJlZVdhbGtlcihkb2N1bWVudCwgTm9kZUZpbHRlci5TSE9XX0VMRU1FTlQsXG4gIG51bGwsIGZhbHNlKTtcblxuLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG5jb25zdCBpbmVydERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnaW5lcnQnKTtcblxuY29uc3QgY2xlYXJOb2RlID0gbm9kZSA9PiB7XG4gIGxldCBmaXJzdENoaWxkO1xuICB3aGlsZSAoKGZpcnN0Q2hpbGQgPSBub2RlW05BVElWRV9QUkVGSVggKyAnZmlyc3RDaGlsZCddKSkge1xuICAgIG5vZGVbTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKGZpcnN0Q2hpbGQpO1xuICB9XG59XG5cbmNvbnN0IFBhcmVudE5vZGVBY2Nlc3NvcnMgPSBbXG4gICdmaXJzdEVsZW1lbnRDaGlsZCcsXG4gICdsYXN0RWxlbWVudENoaWxkJyxcbiAgJ2NoaWxkcmVuJyxcbiAgJ2NoaWxkRWxlbWVudENvdW50Jyxcbl07XG5cbmNvbnN0IFBhcmVudE5vZGVNZXRob2RzID0gW1xuICAncXVlcnlTZWxlY3RvcicsXG4gICdxdWVyeVNlbGVjdG9yQWxsJ1xuICAvLyAnYXBwZW5kJywgJ3ByZXBlbmQnXG5dO1xuXG5leHBvcnQgY29uc3QgYWRkTmF0aXZlUHJlZml4ZWRQcm9wZXJ0aWVzID0gKCkgPT4ge1xuXG4gIC8vIEV2ZW50VGFyZ2V0XG4gIGNvbnN0IGV2ZW50UHJvcHMgPSBbXG4gICAgJ2Rpc3BhdGNoRXZlbnQnLFxuICAgICdhZGRFdmVudExpc3RlbmVyJyxcbiAgICAncmVtb3ZlRXZlbnRMaXN0ZW5lcidcbiAgXTtcbiAgaWYgKHdpbmRvdy5FdmVudFRhcmdldCkge1xuICAgIGNvcHlQcm9wZXJ0aWVzKHdpbmRvdy5FdmVudFRhcmdldC5wcm90b3R5cGUsIGV2ZW50UHJvcHMpO1xuICB9IGVsc2Uge1xuICAgIGNvcHlQcm9wZXJ0aWVzKE5vZGUucHJvdG90eXBlLCBldmVudFByb3BzKTtcbiAgICBjb3B5UHJvcGVydGllcyhXaW5kb3cucHJvdG90eXBlLCBldmVudFByb3BzKTtcbiAgfVxuXG5cbiAgLy8gTm9kZVxuICBpZiAoaGFzRGVzY3JpcHRvcnMpIHtcbiAgICBjb3B5UHJvcGVydGllcyhOb2RlLnByb3RvdHlwZSwgW1xuICAgICAgJ3BhcmVudE5vZGUnLFxuICAgICAgJ2ZpcnN0Q2hpbGQnLFxuICAgICAgJ2xhc3RDaGlsZCcsXG4gICAgICAncHJldmlvdXNTaWJsaW5nJyxcbiAgICAgICduZXh0U2libGluZycsXG4gICAgICAnY2hpbGROb2RlcycsXG4gICAgICAncGFyZW50RWxlbWVudCcsXG4gICAgICAndGV4dENvbnRlbnQnLFxuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZU5hdGl2ZUFjY2Vzc29ycyhOb2RlLnByb3RvdHlwZSwge1xuICAgICAgcGFyZW50Tm9kZToge1xuICAgICAgICAvKiogQHRoaXMge05vZGV9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbm9kZVdhbGtlci5wYXJlbnROb2RlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBmaXJzdENoaWxkOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIG5vZGVXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBub2RlV2Fsa2VyLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGxhc3RDaGlsZDoge1xuICAgICAgICAvKiogQHRoaXMge05vZGV9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICBub2RlV2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgICByZXR1cm4gbm9kZVdhbGtlci5sYXN0Q2hpbGQoKTtcbiAgICAgICAgfVxuXG4gICAgICB9LFxuICAgICAgcHJldmlvdXNTaWJsaW5nOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIG5vZGVXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBub2RlV2Fsa2VyLnByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbmV4dFNpYmxpbmc6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIG5vZGVXYWxrZXIubmV4dFNpYmxpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIFRPRE8oc29ydmVsbCk6IG1ha2UgdGhpcyBhIE5vZGVMaXN0IG9yIHdoYXRldmVyXG4gICAgICBjaGlsZE5vZGVzOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVzID0gW107XG4gICAgICAgICAgbm9kZVdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgbGV0IG4gPSBub2RlV2Fsa2VyLmZpcnN0Q2hpbGQoKTtcbiAgICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgICAgIG4gPSBub2RlV2Fsa2VyLm5leHRTaWJsaW5nKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBub2RlcztcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgZWxlbWVudFdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRXYWxrZXIucGFyZW50Tm9kZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdGV4dENvbnRlbnQ6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbiAgICAgICAgICBzd2l0Y2ggKHRoaXMubm9kZVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICAgICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogVGhpcyBjYW5ub3QgYmUgYSBzaW5nbGUgVHJlZVdhbGtlciB0aGF0J3MgcmV1c2VkXG4gICAgICAgICAgICAgIC8vIGF0IGxlYXN0IGZvciBTYWZhcmkgOSwgYnV0IGl0J3MgdW5jbGVhciB3aHkuXG4gICAgICAgICAgICAgIGNvbnN0IHRleHRXYWxrZXIgPSBkb2N1bWVudC5jcmVhdGVUcmVlV2Fsa2VyKHRoaXMsIE5vZGVGaWx0ZXIuU0hPV19URVhULFxuICAgICAgICAgICAgICAgIG51bGwsIGZhbHNlKTtcbiAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSAnJywgbjtcbiAgICAgICAgICAgICAgd2hpbGUgKCAobiA9IHRleHRXYWxrZXIubmV4dE5vZGUoKSkgKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogY2FuJ3QgdXNlIHRleHRDb250ZW50IHNpbmNlIHdlIHBhdGNoIGl0IG9uIE5vZGUucHJvdG90eXBlIVxuICAgICAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHNob3VsZCBwcm9iYWJseSBwYXRjaCBpdCBvbmx5IG9uIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgY29udGVudCArPSBuLm5vZGVWYWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzLm5vZGVWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5lZWRlZCBvbiBicm93c2VycyB0aGF0IGRvIG5vdCBwcm9wZXIgYWNjZXNzb3JzIChlLmcuIG9sZCB2ZXJzaW9ucyBvZiBDaHJvbWUpXG4gICAgICAgIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gJydcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoICh0aGlzLm5vZGVUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIE5vZGUuRUxFTUVOVF9OT0RFOlxuICAgICAgICAgICAgY2FzZSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREU6XG4gICAgICAgICAgICAgIGNsZWFyTm9kZSh0aGlzKTtcbiAgICAgICAgICAgICAgLy8gRG9jdW1lbnQgZnJhZ21lbnRzIG11c3QgaGF2ZSBubyBjaGlsZG5vZGVzIGlmIHNldHRpbmcgYSBibGFuayBzdHJpbmdcbiAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDAgfHwgdGhpcy5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlOiBvbGQgQ2hyb21lIHZlcnNpb25zIHJlcXVpcmUgMm5kIGFyZ3VtZW50IGhlcmVcbiAgICAgICAgICAgICAgICB0aGlzW05BVElWRV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10oZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsdWUpLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogY2FuJ3QgZG8gdGhpcyBpZiBwYXRjaCBub2RlVmFsdWUuXG4gICAgICAgICAgICAgIHRoaXMubm9kZVZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29weVByb3BlcnRpZXMoTm9kZS5wcm90b3R5cGUsIFtcbiAgICAnYXBwZW5kQ2hpbGQnLFxuICAgICdpbnNlcnRCZWZvcmUnLFxuICAgICdyZW1vdmVDaGlsZCcsXG4gICAgJ3JlcGxhY2VDaGlsZCcsXG4gICAgJ2Nsb25lTm9kZScsXG4gICAgJ2NvbnRhaW5zJ1xuICBdKTtcblxuICAvLyBOT1RFLCBvbiBzb21lIGJyb3dzZXJzIElFIDExIC8gRWRnZSAxNSBzb21lIHByb3BlcnRpZXMgYXJlIGluY29ycmVjdGx5IG9uIEhUTUxFbGVtZW50XG4gIGNvcHlQcm9wZXJ0aWVzKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgW1xuICAgICdwYXJlbnRFbGVtZW50JyxcbiAgICAnY29udGFpbnMnXG4gIF0pO1xuXG4gIGNvbnN0IFBhcmVudE5vZGVXYWxrZXJEZXNjcmlwdG9ycyA9IHtcbiAgICBmaXJzdEVsZW1lbnRDaGlsZDoge1xuICAgICAgLyoqIEB0aGlzIHtQYXJlbnROb2RlfSAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRXYWxrZXIuZmlyc3RDaGlsZCgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgbGFzdEVsZW1lbnRDaGlsZDoge1xuICAgICAgLyoqIEB0aGlzIHtQYXJlbnROb2RlfSAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICBlbGVtZW50V2Fsa2VyLmN1cnJlbnROb2RlID0gdGhpcztcbiAgICAgICAgcmV0dXJuIGVsZW1lbnRXYWxrZXIubGFzdENoaWxkKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBjaGlsZHJlbjoge1xuICAgICAgLyoqIEB0aGlzIHtQYXJlbnROb2RlfSAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICBsZXQgbm9kZXMgPSBbXTtcbiAgICAgICAgZWxlbWVudFdhbGtlci5jdXJyZW50Tm9kZSA9IHRoaXM7XG4gICAgICAgIGxldCBuID0gZWxlbWVudFdhbGtlci5maXJzdENoaWxkKCk7XG4gICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgbm9kZXMucHVzaChuKTtcbiAgICAgICAgICBuID0gZWxlbWVudFdhbGtlci5uZXh0U2libGluZygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1dGlscy5jcmVhdGVQb2x5ZmlsbGVkSFRNTENvbGxlY3Rpb24obm9kZXMpO1xuICAgICAgfVxuICAgIH0sXG4gICAgY2hpbGRFbGVtZW50Q291bnQ6IHtcbiAgICAgIC8qKiBAdGhpcyB7UGFyZW50Tm9kZX0gKi9cbiAgICAgIGdldCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2hpbGRyZW4pIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8vIEVsZW1lbnRcbiAgaWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgY29weVByb3BlcnRpZXMoRWxlbWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVBY2Nlc3NvcnMpO1xuXG4gICAgY29weVByb3BlcnRpZXMoRWxlbWVudC5wcm90b3R5cGUsIFtcbiAgICAgICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJyxcbiAgICAgICduZXh0RWxlbWVudFNpYmxpbmcnLFxuICAgICAgJ2lubmVySFRNTCcsXG4gICAgICAnY2xhc3NOYW1lJ1xuICAgIF0pO1xuXG4gICAgLy8gTk9URSwgb24gc29tZSBicm93c2VycyBJRSAxMSAvIEVkZ2UgMTUgc29tZSBwcm9wZXJ0aWVzIGFyZSBpbmNvcnJlY3RseSBvbiBIVE1MRWxlbWVudFxuICAgIGNvcHlQcm9wZXJ0aWVzKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgW1xuICAgICAgJ2NoaWxkcmVuJyxcbiAgICAgICdpbm5lckhUTUwnLFxuICAgICAgJ2NsYXNzTmFtZSdcbiAgICBdKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVOYXRpdmVBY2Nlc3NvcnMoRWxlbWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVXYWxrZXJEZXNjcmlwdG9ycyk7XG4gICAgZGVmaW5lTmF0aXZlQWNjZXNzb3JzKEVsZW1lbnQucHJvdG90eXBlLCB7XG4gICAgICBwcmV2aW91c0VsZW1lbnRTaWJsaW5nOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGVsZW1lbnRXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50V2Fsa2VyLnByZXZpb3VzU2libGluZygpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgbmV4dEVsZW1lbnRTaWJsaW5nOiB7XG4gICAgICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgIGVsZW1lbnRXYWxrZXIuY3VycmVudE5vZGUgPSB0aGlzO1xuICAgICAgICAgIHJldHVybiBlbGVtZW50V2Fsa2VyLm5leHRTaWJsaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBpbm5lckhUTUw6IHtcbiAgICAgICAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgcmV0dXJuIGdldElubmVySFRNTCh0aGlzLCB1dGlscy5uYXRpdmVDaGlsZE5vZGVzQXJyYXkpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBOZWVkZWQgb24gYnJvd3NlcnMgdGhhdCBkbyBub3QgcHJvcGVyIGFjY2Vzc29ycyAoZS5nLiBvbGQgdmVyc2lvbnMgb2YgQ2hyb21lKVxuICAgICAgICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gICAgICAgIHNldCh2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJyA/XG4gICAgICAgICAgLyoqIEB0eXBlIHtIVE1MVGVtcGxhdGVFbGVtZW50fSAqLyh0aGlzKS5jb250ZW50IDogdGhpcztcbiAgICAgICAgICBjbGVhck5vZGUoY29udGVudCk7XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyTmFtZSA9IHRoaXMubG9jYWxOYW1lIHx8ICdkaXYnO1xuICAgICAgICAgIGxldCBodG1sQ29udGFpbmVyO1xuICAgICAgICAgIGlmICghdGhpcy5uYW1lc3BhY2VVUkkgfHwgdGhpcy5uYW1lc3BhY2VVUkkgPT09IGluZXJ0RG9jLm5hbWVzcGFjZVVSSSkge1xuICAgICAgICAgICAgaHRtbENvbnRhaW5lciA9IGluZXJ0RG9jLmNyZWF0ZUVsZW1lbnQoY29udGFpbmVyTmFtZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGh0bWxDb250YWluZXIgPSBpbmVydERvYy5jcmVhdGVFbGVtZW50TlModGhpcy5uYW1lc3BhY2VVUkksIGNvbnRhaW5lck5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sQ29udGFpbmVyLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgICAgIGNvbnN0IG5ld0NvbnRlbnQgPSB0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJyA/XG4gICAgICAgICAgICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKGh0bWxDb250YWluZXIpLmNvbnRlbnQgOiBodG1sQ29udGFpbmVyO1xuICAgICAgICAgIGxldCBmaXJzdENoaWxkO1xuICAgICAgICAgIHdoaWxlICgoZmlyc3RDaGlsZCA9IG5ld0NvbnRlbnRbTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ10pKSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBvbGQgQ2hyb21lIHZlcnNpb25zIHJlcXVpcmUgMm5kIGFyZ3VtZW50IGhlcmVcbiAgICAgICAgICAgIGNvbnRlbnRbTkFUSVZFX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShmaXJzdENoaWxkLCB1bmRlZmluZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJyc7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICAgICAgc2V0KHZhbHVlKSB7XG4gICAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb3B5UHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgW1xuICAgICdzZXRBdHRyaWJ1dGUnLFxuICAgICdnZXRBdHRyaWJ1dGUnLFxuICAgICdoYXNBdHRyaWJ1dGUnLFxuICAgICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgIC8vIG9uIG9sZGVyIFNhZmFyaSwgdGhlc2UgYXJlIG9uIEVsZW1lbnQuXG4gICAgJ2ZvY3VzJyxcbiAgICAnYmx1cicsXG4gIF0pO1xuICBjb3B5UHJvcGVydGllcyhFbGVtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZU1ldGhvZHMpO1xuXG4gIC8vIEhUTUxFbGVtZW50XG4gIGNvcHlQcm9wZXJ0aWVzKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgW1xuICAgICdmb2N1cycsXG4gICAgJ2JsdXInXG4gIF0pO1xuXG4gIC8vIEhUTUxUZW1wbGF0ZUVsZW1lbnRcbiAgaWYgKHdpbmRvdy5IVE1MVGVtcGxhdGVFbGVtZW50KSB7XG4gICAgY29weVByb3BlcnRpZXMod2luZG93LkhUTUxUZW1wbGF0ZUVsZW1lbnQucHJvdG90eXBlLCBbJ2lubmVySFRNTCddKTtcbiAgfVxuXG4gIC8vIERvY3VtZW50RnJhZ21lbnRcbiAgaWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgLy8gTk9URSwgSUUgMTEgZG9lcyBub3QgaGF2ZSBvbiBEb2N1bWVudEZyYWdtZW50XG4gICAgLy8gZmlyc3RFbGVtZW50Q2hpbGRcbiAgICAvLyBsYXN0RWxlbWVudENoaWxkXG4gICAgY29weVByb3BlcnRpZXMoRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVBY2Nlc3NvcnMpO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZU5hdGl2ZUFjY2Vzc29ycyhEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSwgUGFyZW50Tm9kZVdhbGtlckRlc2NyaXB0b3JzKTtcbiAgfVxuXG4gIGNvcHlQcm9wZXJ0aWVzKERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLCBQYXJlbnROb2RlTWV0aG9kcyk7XG5cbiAgLy8gRG9jdW1lbnRcbiAgaWYgKGhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgY29weVByb3BlcnRpZXMoRG9jdW1lbnQucHJvdG90eXBlLCBQYXJlbnROb2RlQWNjZXNzb3JzKTtcbiAgICBjb3B5UHJvcGVydGllcyhEb2N1bWVudC5wcm90b3R5cGUsIFtcbiAgICAgICdhY3RpdmVFbGVtZW50J1xuICAgIF0pO1xuICB9IGVsc2Uge1xuICAgIGRlZmluZU5hdGl2ZUFjY2Vzc29ycyhEb2N1bWVudC5wcm90b3R5cGUsIFBhcmVudE5vZGVXYWxrZXJEZXNjcmlwdG9ycyk7XG4gIH1cblxuICBjb3B5UHJvcGVydGllcyhEb2N1bWVudC5wcm90b3R5cGUsIFtcbiAgICAnaW1wb3J0Tm9kZScsXG4gICAgJ2dldEVsZW1lbnRCeUlkJ1xuICBdKTtcbiAgY29weVByb3BlcnRpZXMoRG9jdW1lbnQucHJvdG90eXBlLCBQYXJlbnROb2RlTWV0aG9kcyk7XG5cbn07XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7ZW5zdXJlU2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi9zaGFkeS1kYXRhLmpzJztcblxuZXhwb3J0IGNvbnN0IEluc2lkZURlc2NyaXB0b3JzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnY2hpbGROb2RlcyddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBsYXN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGNoaWxkRWxlbWVudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdjaGlsZEVsZW1lbnRDb3VudCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGNoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdjaGlsZHJlbiddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGZpcnN0RWxlbWVudENoaWxkKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdEVsZW1lbnRDaGlsZCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGxhc3RFbGVtZW50Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RFbGVtZW50Q2hpbGQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBzaGFkb3dSb290KCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdzaGFkb3dSb290J107XG4gIH0sXG5cbn0pO1xuXG5leHBvcnQgY29uc3QgVGV4dENvbnRlbnRJbm5lckhUTUxEZXNjcmlwdG9ycyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAndGV4dENvbnRlbnQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIHNldCB0ZXh0Q29udGVudCh2YWx1ZSkge1xuICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3RleHRDb250ZW50J10gPSB2YWx1ZTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBpbm5lckhUTUwoKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2lubmVySFRNTCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgc2V0IGlubmVySFRNTCh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbm5lckhUTUwnXSA9IHZhbHVlO1xuICB9LFxufSk7XG5cbmV4cG9ydCBjb25zdCBPdXRzaWRlRGVzY3JpcHRvcnMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnRFbGVtZW50J107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgcGFyZW50Tm9kZSgpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHByZXZpb3VzU2libGluZygpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncHJldmlvdXNTaWJsaW5nJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgbmV4dEVsZW1lbnRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0RWxlbWVudFNpYmxpbmcnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBwcmV2aW91c0VsZW1lbnRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdwcmV2aW91c0VsZW1lbnRTaWJsaW5nJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgY2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdjbGFzc05hbWUnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIHNldCBjbGFzc05hbWUodmFsdWUpIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnY2xhc3NOYW1lJ10gPSB2YWx1ZTtcbiAgfVxuXG59KTtcblxuZm9yIChsZXQgcHJvcCBpbiBJbnNpZGVEZXNjcmlwdG9ycykge1xuICBJbnNpZGVEZXNjcmlwdG9yc1twcm9wXS5lbnVtZXJhYmxlID0gZmFsc2U7XG59XG5cbmZvciAobGV0IHByb3AgaW4gVGV4dENvbnRlbnRJbm5lckhUTUxEZXNjcmlwdG9ycykge1xuICBUZXh0Q29udGVudElubmVySFRNTERlc2NyaXB0b3JzW3Byb3BdLmVudW1lcmFibGUgPSBmYWxzZTtcbn1cblxuZm9yIChsZXQgcHJvcCBpbiBPdXRzaWRlRGVzY3JpcHRvcnMpIHtcbiAgT3V0c2lkZURlc2NyaXB0b3JzW3Byb3BdLmVudW1lcmFibGUgPSBmYWxzZTtcbn1cblxuY29uc3Qgbm9JbnN0YW5jZVBhdGNoaW5nID0gdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMgfHwgdXRpbHMuc2V0dGluZ3Mubm9QYXRjaDtcblxuLy8gZW5zdXJlIGFuIGVsZW1lbnQgaGFzIHBhdGNoZWQgXCJvdXRzaWRlXCIgYWNjZXNzb3JzOyBuby1vcCB3aGVuIG5vdCBuZWVkZWRcbmV4cG9ydCBsZXQgcGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29ycyA9IG5vSW5zdGFuY2VQYXRjaGluZyA/XG4gIGZ1bmN0aW9uKCkge30gOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgY29uc3Qgc2QgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKGVsZW1lbnQpO1xuICAgIGlmICghc2QuX19vdXRzaWRlQWNjZXNzb3JzKSB7XG4gICAgICBzZC5fX291dHNpZGVBY2Nlc3NvcnMgPSB0cnVlO1xuICAgICAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKGVsZW1lbnQsIE91dHNpZGVEZXNjcmlwdG9ycyk7XG4gICAgfVxuICB9XG5cbi8vIGVuc3VyZSBhbiBlbGVtZW50IGhhcyBwYXRjaGVkIFwiaW5zaWRlXCIgYWNjZXNzb3JzOyBuby1vcCB3aGVuIG5vdCBuZWVkZWRcbmV4cG9ydCBsZXQgcGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzID0gbm9JbnN0YW5jZVBhdGNoaW5nID9cbiAgZnVuY3Rpb24oKSB7fSA6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICBjb25zdCBzZCA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUoZWxlbWVudCk7XG4gICAgaWYgKCFzZC5fX2luc2lkZUFjY2Vzc29ycykge1xuICAgICAgc2QuX19pbnNpZGVBY2Nlc3NvcnMgPSB0cnVlO1xuICAgICAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKGVsZW1lbnQsIEluc2lkZURlc2NyaXB0b3JzKTtcbiAgICAgIC8vIE5PVEU6IFRoZXJlIGFyZSBjb21wYXRpYmlsaXR5IGlzc3VlcyB3aXRoIHBhdGNoZXMgZm9yIGB0ZXh0Q29udGVudGBcbiAgICAgIC8vIGFuZCBgaW5uZXJIVE1MYCBiZXR3ZWVuIENFIGFuZCBTRC4gU2luY2UgU0QgcGF0Y2hlcyBhcmUgYXBwbGllZFxuICAgICAgLy8gdmlhIGBTaGFkeURPTS5wYXRjaGAgYW5kIENFIHBhdGNoZXMgYXJlIGFwcGxpZWQgYXMgdGhlIHRyZWUgaXMgd2Fsa2VkLFxuICAgICAgLy8gU0QgcGF0Y2hlcyBvdmVyd3JpdGUgQ0UgcGF0Y2hlcy5cbiAgICAgIC8vICogV2hlbiBTRCBpcyBpbiBwYXRjaGluZyBtb2RlLCBTRCBjYWxscyB0aHJvdWdoIHRvIG5hdGl2ZVxuICAgICAgLy8gbWV0aG9kcyBub3QgcGF0Y2hlZCBieSBDRSAoc2luY2UgU0QgaXMgYXQgdGhlIGJvdHRvbSkgYW5kIENFIGRvZXMgbm90XG4gICAgICAvLyB1cGdyYWRlLCBjb25uZWN0LCBvciBkaXNjb25uZWN0IGVsZW1lbnRzLiBUaGVyZWZvcmUgZG8gKm5vdCBwYXRjaCpcbiAgICAgIC8vIHRoZXNlIGFjY2Vzc29ycyBpbiB0aGlzIGNhc2UuXG4gICAgICAvLyAqIFdoZW4gU0QgaXMgaW4gYG5vUGF0Y2hgIG1vZGUsIHRoZSBTRCBwYXRjaGVzIGNhbGwgdGhyb3VnaCB0b1xuICAgICAgLy8gXCJuYXRpdmVcIiBtZXRob2RzIHRoYXQgYXJlIHBhdGNoZWQgYnkgQ0UgKHNpbmNlIENFIGlzIGF0IHRoZSBib3R0b20pLlxuICAgICAgLy8gVGhlcmVmb3JlIGNvbnRpbnVlIHRvIHBhdGNoIGluIHRoaXMgY2FzZS5cbiAgICAgIC8vIElmIGN1c3RvbUVsZW1lbnRzIGlzIG5vdCBsb2FkZWQsIHRoZW4gdGhlc2UgYWNjZXNzb3JzIHNob3VsZCBiZVxuICAgICAgLy8gcGF0Y2hlZCBzbyB0aGV5IHdvcmsgY29ycmVjdGx5LlxuICAgICAgaWYgKCF3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ10gfHwgdXRpbHMuc2V0dGluZ3Mubm9QYXRjaCkge1xuICAgICAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMoZWxlbWVudCwgVGV4dENvbnRlbnRJbm5lckhUTUxEZXNjcmlwdG9ycyk7XG4gICAgICB9XG4gICAgfVxuICB9IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4vc2hhZHktZGF0YS5qcyc7XG5cbi8qXG5NYWtlIHRoaXMgbmFtZSB1bmlxdWUgc28gaXQgaXMgdW5saWtlbHkgdG8gY29uZmxpY3Qgd2l0aCBwcm9wZXJ0aWVzIG9uIG9iamVjdHMgcGFzc2VkIHRvIGBhZGRFdmVudExpc3RlbmVyYFxuaHR0cHM6Ly9naXRodWIuY29tL3dlYmNvbXBvbmVudHMvc2hhZHlkb20vaXNzdWVzLzE3M1xuKi9cbmNvbnN0IC8qKiBzdHJpbmcgKi8gZXZlbnRXcmFwcGVyc05hbWUgPSBgX19ldmVudFdyYXBwZXJzJHtEYXRlLm5vdygpfWA7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCFFdmVudCk6IGJvb2xlYW59ICovXG5jb25zdCBjb21wb3NlZEdldHRlciA9ICgoKSA9PiB7XG4gIGNvbnN0IGNvbXBvc2VkUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoRXZlbnQucHJvdG90eXBlLCAnY29tcG9zZWQnKTtcbiAgcmV0dXJuIGNvbXBvc2VkUHJvcCA/IChldikgPT4gY29tcG9zZWRQcm9wLmdldC5jYWxsKGV2KSA6IG51bGw7XG59KSgpO1xuXG5jb25zdCBzdXBwb3J0c0V2ZW50T3B0aW9ucyA9ICgoKSA9PiB7XG4gIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgbGV0IGV2ZW50T3B0aW9ucyA9IHtcbiAgICBnZXQgY2FwdHVyZSgpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfVxuICB9XG4gIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge31cbiAgLy8gTk9URTogVGhlc2Ugd2lsbCBiZSB1bnBhdGNoZWQgYXQgdGhpcyBwb2ludC5cbiAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgZXZlbnRPcHRpb25zKTtcbiAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBsaXN0ZW5lciwgZXZlbnRPcHRpb25zKTtcbiAgcmV0dXJuIHN1cHBvcnRlZDtcbn0pKCk7XG5cbmNvbnN0IHBhcnNlRXZlbnRPcHRpb25zID0gKG9wdGlvbnNPckNhcHR1cmUpID0+IHtcbiAgbGV0IGNhcHR1cmUsIG9uY2UsIHBhc3NpdmUsIHNoYWR5VGFyZ2V0O1xuICBpZiAob3B0aW9uc09yQ2FwdHVyZSAmJiB0eXBlb2Ygb3B0aW9uc09yQ2FwdHVyZSA9PT0gJ29iamVjdCcpIHtcbiAgICBjYXB0dXJlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlLmNhcHR1cmUpO1xuICAgIG9uY2UgPSBCb29sZWFuKG9wdGlvbnNPckNhcHR1cmUub25jZSk7XG4gICAgcGFzc2l2ZSA9IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZS5wYXNzaXZlKTtcbiAgICBzaGFkeVRhcmdldCA9IG9wdGlvbnNPckNhcHR1cmUuX19zaGFkeVRhcmdldDtcbiAgfSBlbHNlIHtcbiAgICBjYXB0dXJlID0gQm9vbGVhbihvcHRpb25zT3JDYXB0dXJlKTtcbiAgICBvbmNlID0gZmFsc2U7XG4gICAgcGFzc2l2ZSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB7XG4gICAgc2hhZHlUYXJnZXQsXG4gICAgY2FwdHVyZSxcbiAgICBvbmNlLFxuICAgIHBhc3NpdmUsXG4gICAgbmF0aXZlRXZlbnRPcHRpb25zOiBzdXBwb3J0c0V2ZW50T3B0aW9ucyA/IG9wdGlvbnNPckNhcHR1cmUgOiBjYXB0dXJlXG4gIH1cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3czYy93ZWJjb21wb25lbnRzL2lzc3Vlcy81MTMjaXNzdWVjb21tZW50LTIyNDE4MzkzN1xuY29uc3QgYWx3YXlzQ29tcG9zZWQgPSB7XG4gICdibHVyJzogdHJ1ZSxcbiAgJ2ZvY3VzJzogdHJ1ZSxcbiAgJ2ZvY3VzaW4nOiB0cnVlLFxuICAnZm9jdXNvdXQnOiB0cnVlLFxuICAnY2xpY2snOiB0cnVlLFxuICAnZGJsY2xpY2snOiB0cnVlLFxuICAnbW91c2Vkb3duJzogdHJ1ZSxcbiAgJ21vdXNlZW50ZXInOiB0cnVlLFxuICAnbW91c2VsZWF2ZSc6IHRydWUsXG4gICdtb3VzZW1vdmUnOiB0cnVlLFxuICAnbW91c2VvdXQnOiB0cnVlLFxuICAnbW91c2VvdmVyJzogdHJ1ZSxcbiAgJ21vdXNldXAnOiB0cnVlLFxuICAnd2hlZWwnOiB0cnVlLFxuICAnYmVmb3JlaW5wdXQnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5ZG93bic6IHRydWUsXG4gICdrZXl1cCc6IHRydWUsXG4gICdjb21wb3NpdGlvbnN0YXJ0JzogdHJ1ZSxcbiAgJ2NvbXBvc2l0aW9udXBkYXRlJzogdHJ1ZSxcbiAgJ2NvbXBvc2l0aW9uZW5kJzogdHJ1ZSxcbiAgJ3RvdWNoc3RhcnQnOiB0cnVlLFxuICAndG91Y2hlbmQnOiB0cnVlLFxuICAndG91Y2htb3ZlJzogdHJ1ZSxcbiAgJ3RvdWNoY2FuY2VsJzogdHJ1ZSxcbiAgJ3BvaW50ZXJvdmVyJzogdHJ1ZSxcbiAgJ3BvaW50ZXJlbnRlcic6IHRydWUsXG4gICdwb2ludGVyZG93bic6IHRydWUsXG4gICdwb2ludGVybW92ZSc6IHRydWUsXG4gICdwb2ludGVydXAnOiB0cnVlLFxuICAncG9pbnRlcmNhbmNlbCc6IHRydWUsXG4gICdwb2ludGVyb3V0JzogdHJ1ZSxcbiAgJ3BvaW50ZXJsZWF2ZSc6IHRydWUsXG4gICdnb3Rwb2ludGVyY2FwdHVyZSc6IHRydWUsXG4gICdsb3N0cG9pbnRlcmNhcHR1cmUnOiB0cnVlLFxuICAnZHJhZ3N0YXJ0JzogdHJ1ZSxcbiAgJ2RyYWcnOiB0cnVlLFxuICAnZHJhZ2VudGVyJzogdHJ1ZSxcbiAgJ2RyYWdsZWF2ZSc6IHRydWUsXG4gICdkcmFnb3Zlcic6IHRydWUsXG4gICdkcm9wJzogdHJ1ZSxcbiAgJ2RyYWdlbmQnOiB0cnVlLFxuICAnRE9NQWN0aXZhdGUnOiB0cnVlLFxuICAnRE9NRm9jdXNJbic6IHRydWUsXG4gICdET01Gb2N1c091dCc6IHRydWUsXG4gICdrZXlwcmVzcyc6IHRydWVcbn07XG5cbmNvbnN0IHVucGF0Y2hlZEV2ZW50cyA9IHtcbiAgJ0RPTUF0dHJNb2RpZmllZCc6IHRydWUsXG4gICdET01BdHRyaWJ1dGVOYW1lQ2hhbmdlZCc6IHRydWUsXG4gICdET01DaGFyYWN0ZXJEYXRhTW9kaWZpZWQnOiB0cnVlLFxuICAnRE9NRWxlbWVudE5hbWVDaGFuZ2VkJzogdHJ1ZSxcbiAgJ0RPTU5vZGVJbnNlcnRlZCc6IHRydWUsXG4gICdET01Ob2RlSW5zZXJ0ZWRJbnRvRG9jdW1lbnQnOiB0cnVlLFxuICAnRE9NTm9kZVJlbW92ZWQnOiB0cnVlLFxuICAnRE9NTm9kZVJlbW92ZWRGcm9tRG9jdW1lbnQnOiB0cnVlLFxuICAnRE9NU3VidHJlZU1vZGlmaWVkJzogdHJ1ZVxufVxuXG4vKipcbiAqIFNvbWUgRXZlbnRUYXJnZXQgc3ViY2xhc3NlcyBhcmUgbm90IE5vZGUgc3ViY2xhc3NlcywgYW5kIHlvdSBjYW5ub3QgY2FsbFxuICogYGdldFJvb3ROb2RlKClgIG9uIHRoZW0uXG4gKlxuICogQHBhcmFtIHshKE5vZGV8RXZlbnRUYXJnZXQpfSBldmVudFRhcmdldFxuICogQHJldHVybiB7IShOb2RlfEV2ZW50VGFyZ2V0KX1cbiAqL1xuZnVuY3Rpb24gZ2V0Um9vdE5vZGVXaXRoRmFsbGJhY2soZXZlbnRUYXJnZXQpIHtcbiAgaWYgKGV2ZW50VGFyZ2V0IGluc3RhbmNlb2YgTm9kZSkge1xuICAgIHJldHVybiBldmVudFRhcmdldFt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXSgpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBldmVudFRhcmdldDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXRoQ29tcG9zZXIoc3RhcnROb2RlLCBjb21wb3NlZCkge1xuICBsZXQgY29tcG9zZWRQYXRoID0gW107XG4gIGxldCBjdXJyZW50ID0gc3RhcnROb2RlO1xuICBsZXQgc3RhcnRSb290ID0gZ2V0Um9vdE5vZGVXaXRoRmFsbGJhY2soc3RhcnROb2RlKTtcbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBjb21wb3NlZFBhdGgucHVzaChjdXJyZW50KTtcbiAgICBpZiAoY3VycmVudFt1dGlscy5TSEFEWV9QUkVGSVggKyAnYXNzaWduZWRTbG90J10pIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdhc3NpZ25lZFNsb3QnXTtcbiAgICB9IGVsc2UgaWYgKGN1cnJlbnQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAmJiBjdXJyZW50Lmhvc3QgJiYgKGNvbXBvc2VkIHx8IGN1cnJlbnQgIT09IHN0YXJ0Um9vdCkpIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lmhvc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQgPSBjdXJyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgfVxuICB9XG4gIC8vIGV2ZW50IGNvbXBvc2VkUGF0aCBpbmNsdWRlcyB3aW5kb3cgd2hlbiBzdGFydE5vZGUncyBvd25lclJvb3QgaXMgZG9jdW1lbnRcbiAgaWYgKGNvbXBvc2VkUGF0aFtjb21wb3NlZFBhdGgubGVuZ3RoIC0gMV0gPT09IGRvY3VtZW50KSB7XG4gICAgY29tcG9zZWRQYXRoLnB1c2god2luZG93KTtcbiAgfVxuICByZXR1cm4gY29tcG9zZWRQYXRoO1xufVxuXG5leHBvcnQgY29uc3QgY29tcG9zZWRQYXRoID0gKGV2ZW50KSA9PiB7XG4gIGlmICghZXZlbnQuX19jb21wb3NlZFBhdGgpIHtcbiAgICBldmVudC5fX2NvbXBvc2VkUGF0aCA9IHBhdGhDb21wb3NlcihldmVudC50YXJnZXQsIHRydWUpO1xuICB9XG4gIHJldHVybiBldmVudC5fX2NvbXBvc2VkUGF0aDtcbn1cblxuZnVuY3Rpb24gcmV0YXJnZXQocmVmTm9kZSwgcGF0aCkge1xuICBpZiAoIXV0aWxzLmlzU2hhZHlSb290KSB7XG4gICAgcmV0dXJuIHJlZk5vZGU7XG4gIH1cbiAgLy8gSWYgQU5DRVNUT1IncyByb290IGlzIG5vdCBhIHNoYWRvdyByb290IG9yIEFOQ0VTVE9SJ3Mgcm9vdCBpcyBCQVNFJ3NcbiAgLy8gc2hhZG93LWluY2x1ZGluZyBpbmNsdXNpdmUgYW5jZXN0b3IsIHJldHVybiBBTkNFU1RPUi5cbiAgbGV0IHJlZk5vZGVQYXRoID0gcGF0aENvbXBvc2VyKHJlZk5vZGUsIHRydWUpO1xuICBsZXQgcCQgPSBwYXRoO1xuICBmb3IgKGxldCBpPTAsIGFuY2VzdG9yLCBsYXN0Um9vdCwgcm9vdCwgcm9vdElkeDsgaSA8IHAkLmxlbmd0aDsgaSsrKSB7XG4gICAgYW5jZXN0b3IgPSBwJFtpXTtcbiAgICByb290ID0gZ2V0Um9vdE5vZGVXaXRoRmFsbGJhY2soYW5jZXN0b3IpO1xuICAgIGlmIChyb290ICE9PSBsYXN0Um9vdCkge1xuICAgICAgcm9vdElkeCA9IHJlZk5vZGVQYXRoLmluZGV4T2Yocm9vdCk7XG4gICAgICBsYXN0Um9vdCA9IHJvb3Q7XG4gICAgfVxuICAgIGlmICghdXRpbHMuaXNTaGFkeVJvb3Qocm9vdCkgfHwgcm9vdElkeCA+IC0xKSB7XG4gICAgICByZXR1cm4gYW5jZXN0b3I7XG4gICAgfVxuICB9XG59XG5cbmxldCBFdmVudFBhdGNoZXMgPSB7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtFdmVudH1cbiAgICovXG4gIGdldCBjb21wb3NlZCgpIHtcbiAgICBpZiAodGhpcy5fX2NvbXBvc2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIGlmIHRoZXJlJ3MgYW4gb3JpZ2luYWwgYGNvbXBvc2VkYCBnZXR0ZXIgb24gdGhlIEV2ZW50IHByb3RvdHlwZSwgdXNlIHRoYXRcbiAgICAgIGlmIChjb21wb3NlZEdldHRlcikge1xuICAgICAgICAvLyBUT0RPKHdlYi1wYWRhd2FuKTogc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJjb21wb25lbnRzL3NoYWR5ZG9tL2lzc3Vlcy8yNzVcbiAgICAgICAgdGhpcy5fX2NvbXBvc2VkID0gdGhpcy50eXBlID09PSAnZm9jdXNpbicgfHwgdGhpcy50eXBlID09PSAnZm9jdXNvdXQnIHx8IGNvbXBvc2VkR2V0dGVyKHRoaXMpO1xuICAgICAgLy8gSWYgdGhlIGV2ZW50IGlzIHRydXN0ZWQsIG9yIGBpc1RydXN0ZWRgIGlzIG5vdCBzdXBwb3J0ZWQsIGNoZWNrIHRoZSBsaXN0IG9mIGFsd2F5cyBjb21wb3NlZCBldmVudHNcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RydXN0ZWQgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX19jb21wb3NlZCA9IGFsd2F5c0NvbXBvc2VkW3RoaXMudHlwZV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAvKiogQHR5cGUgeyFFdmVudH0gKi8odGhpcykuX19jb21wb3NlZCB8fCBmYWxzZTtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgY29tcG9zZWRQYXRoKCkge1xuICAgIGlmICghdGhpcy5fX2NvbXBvc2VkUGF0aCkge1xuICAgICAgdGhpcy5fX2NvbXBvc2VkUGF0aCA9IHBhdGhDb21wb3Nlcih0aGlzWydfX3RhcmdldCddLCB0aGlzLmNvbXBvc2VkKTtcbiAgICB9XG4gICAgcmV0dXJuIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyh0aGlzKS5fX2NvbXBvc2VkUGF0aDtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgZ2V0IHRhcmdldCgpIHtcbiAgICByZXR1cm4gcmV0YXJnZXQodGhpcy5jdXJyZW50VGFyZ2V0IHx8IHRoaXNbJ19fcHJldmlvdXNDdXJyZW50VGFyZ2V0J10sIHRoaXMuY29tcG9zZWRQYXRoKCkpO1xuICB9LFxuXG4gIC8vIGh0dHA6Ly93M2MuZ2l0aHViLmlvL3dlYmNvbXBvbmVudHMvc3BlYy9zaGFkb3cvI2V2ZW50LXJlbGF0ZWR0YXJnZXQtcmV0YXJnZXRpbmdcbiAgLyoqXG4gICAqIEB0aGlzIHtFdmVudH1cbiAgICovXG4gIGdldCByZWxhdGVkVGFyZ2V0KCkge1xuICAgIGlmICghdGhpcy5fX3JlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX19yZWxhdGVkVGFyZ2V0Q29tcG9zZWRQYXRoKSB7XG4gICAgICB0aGlzLl9fcmVsYXRlZFRhcmdldENvbXBvc2VkUGF0aCA9IHBhdGhDb21wb3Nlcih0aGlzLl9fcmVsYXRlZFRhcmdldCwgdHJ1ZSk7XG4gICAgfVxuICAgIC8vIGZpbmQgdGhlIGRlZXBlc3Qgbm9kZSBpbiByZWxhdGVkVGFyZ2V0IGNvbXBvc2VkIHBhdGggdGhhdCBpcyBpbiB0aGUgc2FtZSByb290IHdpdGggdGhlIGN1cnJlbnRUYXJnZXRcbiAgICByZXR1cm4gcmV0YXJnZXQodGhpcy5jdXJyZW50VGFyZ2V0IHx8IHRoaXNbJ19fcHJldmlvdXNDdXJyZW50VGFyZ2V0J10sIC8qKiBAdHlwZSB7IUV2ZW50fSAqLyh0aGlzKS5fX3JlbGF0ZWRUYXJnZXRDb21wb3NlZFBhdGgpO1xuICB9LFxuICAvKipcbiAgICogQHRoaXMge0V2ZW50fVxuICAgKi9cbiAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgIEV2ZW50LnByb3RvdHlwZS5zdG9wUHJvcGFnYXRpb24uY2FsbCh0aGlzKTtcbiAgICB0aGlzLl9fcHJvcGFnYXRpb25TdG9wcGVkID0gdHJ1ZTtcbiAgfSxcbiAgLyoqXG4gICAqIEB0aGlzIHtFdmVudH1cbiAgICovXG4gIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICBFdmVudC5wcm90b3R5cGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uLmNhbGwodGhpcyk7XG4gICAgdGhpcy5fX2ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gICAgdGhpcy5fX3Byb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG4gIH1cblxufTtcblxuZnVuY3Rpb24gbWl4aW5Db21wb3NlZEZsYWcoQmFzZSkge1xuICAvLyBOT1RFOiBhdm9pZGluZyB1c2Ugb2YgYGNsYXNzYCBoZXJlIHNvIHRoYXQgdHJhbnNwaWxlZCBvdXRwdXQgZG9lcyBub3RcbiAgLy8gdHJ5IHRvIGRvIGBCYXNlLmNhbGxgIHdpdGggYSBkb20gY29uc3RydXRvci5cbiAgbGV0IGtsYXp6ID0gZnVuY3Rpb24odHlwZSwgb3B0aW9ucykge1xuICAgIGxldCBldmVudCA9IG5ldyBCYXNlKHR5cGUsIG9wdGlvbnMpO1xuICAgIGV2ZW50Ll9fY29tcG9zZWQgPSBvcHRpb25zICYmIEJvb2xlYW4ob3B0aW9uc1snY29tcG9zZWQnXSk7XG4gICAgcmV0dXJuIGV2ZW50O1xuICB9XG4gIC8vIHB1dCBjb25zdHJ1Y3RvciBwcm9wZXJ0aWVzIG9uIHN1YmNsYXNzXG4gIGtsYXp6Ll9fcHJvdG9fXyA9IEJhc2U7XG4gIGtsYXp6LnByb3RvdHlwZSA9IEJhc2UucHJvdG90eXBlO1xuICByZXR1cm4ga2xheno7XG59XG5cbmxldCBub25CdWJibGluZ0V2ZW50c1RvUmV0YXJnZXQgPSB7XG4gICdmb2N1cyc6IHRydWUsXG4gICdibHVyJzogdHJ1ZVxufTtcblxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBldmVudCBoYXMgYmVlbiByZXRhcmdldGVkIGJ5IGNvbXBhcmluZyBvcmlnaW5hbCBgdGFyZ2V0YCwgYW5kIGNhbGN1bGF0ZWQgYHRhcmdldGBcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHRoZSBvcmlnaW5hbCB0YXJnZXQgYW5kIGNhbGN1bGF0ZWQgdGFyZ2V0IGFyZSB0aGUgc2FtZVxuICovXG5mdW5jdGlvbiBoYXNSZXRhcmdldGVkKGV2ZW50KSB7XG4gIHJldHVybiBldmVudFsnX190YXJnZXQnXSAhPT0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50Ll9fcmVsYXRlZFRhcmdldCAhPT0gZXZlbnQucmVsYXRlZFRhcmdldDtcbn1cblxuLyoqXG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXZlbnRcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICogQHBhcmFtIHtzdHJpbmd9IHBoYXNlXG4gKi9cbmZ1bmN0aW9uIGZpcmVIYW5kbGVycyhldmVudCwgbm9kZSwgcGhhc2UpIHtcbiAgbGV0IGhzID0gbm9kZS5fX2hhbmRsZXJzICYmIG5vZGUuX19oYW5kbGVyc1tldmVudC50eXBlXSAmJlxuICAgIG5vZGUuX19oYW5kbGVyc1tldmVudC50eXBlXVtwaGFzZV07XG4gIGlmIChocykge1xuICAgIGZvciAobGV0IGkgPSAwLCBmbjsgKGZuID0gaHNbaV0pOyBpKyspIHtcbiAgICAgIGlmIChoYXNSZXRhcmdldGVkKGV2ZW50KSAmJiBldmVudC50YXJnZXQgPT09IGV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm4uY2FsbChub2RlLCBldmVudCk7XG4gICAgICBpZiAoZXZlbnQuX19pbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXRhcmdldE5vbkJ1YmJsaW5nRXZlbnQoZSkge1xuICBsZXQgcGF0aCA9IGUuY29tcG9zZWRQYXRoKCk7XG4gIGxldCBub2RlO1xuICAvLyBvdmVycmlkZSBgY3VycmVudFRhcmdldGAgdG8gbGV0IHBhdGNoZWQgYHRhcmdldGAgY2FsY3VsYXRlIGNvcnJlY3RseVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2N1cnJlbnRUYXJnZXQnLCB7XG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBmb3IgKGxldCBpID0gcGF0aC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIG5vZGUgPSBwYXRoW2ldO1xuICAgIC8vIGNhcHR1cmUgcGhhc2UgZmlyZXMgYWxsIGNhcHR1cmUgaGFuZGxlcnNcbiAgICBmaXJlSGFuZGxlcnMoZSwgbm9kZSwgJ2NhcHR1cmUnKTtcbiAgICBpZiAoZS5fX3Byb3BhZ2F0aW9uU3RvcHBlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCB0aGUgZXZlbnQgcGhhc2UgdG8gYEFUX1RBUkdFVGAgYXMgaW4gc3BlY1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2V2ZW50UGhhc2UnLCB7Z2V0KCkgeyByZXR1cm4gRXZlbnQuQVRfVEFSR0VUIH19KTtcblxuICAvLyB0aGUgZXZlbnQgb25seSBuZWVkcyB0byBiZSBmaXJlZCB3aGVuIG93bmVyIHJvb3RzIGNoYW5nZSB3aGVuIGl0ZXJhdGluZyB0aGUgZXZlbnQgcGF0aFxuICAvLyBrZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHNlZW4gb3duZXIgcm9vdFxuICBsZXQgbGFzdEZpcmVkUm9vdDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgbm9kZSA9IHBhdGhbaV07XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICAgIGNvbnN0IHJvb3QgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5yb290O1xuICAgIGlmIChpID09PSAwIHx8IChyb290ICYmIHJvb3QgPT09IGxhc3RGaXJlZFJvb3QpKSB7XG4gICAgICBmaXJlSGFuZGxlcnMoZSwgbm9kZSwgJ2J1YmJsZScpO1xuICAgICAgLy8gZG9uJ3QgYm90aGVyIHdpdGggd2luZG93LCBpdCBkb2Vzbid0IGhhdmUgYGdldFJvb3ROb2RlYCBhbmQgd2lsbCBiZSBsYXN0IGluIHRoZSBwYXRoIGFueXdheVxuICAgICAgaWYgKG5vZGUgIT09IHdpbmRvdykge1xuICAgICAgICBsYXN0RmlyZWRSb290ID0gbm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXSgpO1xuICAgICAgfVxuICAgICAgaWYgKGUuX19wcm9wYWdhdGlvblN0b3BwZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBsaXN0ZW5lclNldHRpbmdzRXF1YWwoc2F2ZWRMaXN0ZW5lciwgbm9kZSwgdHlwZSwgY2FwdHVyZSwgb25jZSwgcGFzc2l2ZSkge1xuICBsZXQge1xuICAgIG5vZGU6IHNhdmVkTm9kZSxcbiAgICB0eXBlOiBzYXZlZFR5cGUsXG4gICAgY2FwdHVyZTogc2F2ZWRDYXB0dXJlLFxuICAgIG9uY2U6IHNhdmVkT25jZSxcbiAgICBwYXNzaXZlOiBzYXZlZFBhc3NpdmVcbiAgfSA9IHNhdmVkTGlzdGVuZXI7XG4gIHJldHVybiBub2RlID09PSBzYXZlZE5vZGUgJiZcbiAgICB0eXBlID09PSBzYXZlZFR5cGUgJiZcbiAgICBjYXB0dXJlID09PSBzYXZlZENhcHR1cmUgJiZcbiAgICBvbmNlID09PSBzYXZlZE9uY2UgJiZcbiAgICBwYXNzaXZlID09PSBzYXZlZFBhc3NpdmU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTGlzdGVuZXIod3JhcHBlcnMsIG5vZGUsIHR5cGUsIGNhcHR1cmUsIG9uY2UsIHBhc3NpdmUpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB3cmFwcGVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsaXN0ZW5lclNldHRpbmdzRXF1YWwod3JhcHBlcnNbaV0sIG5vZGUsIHR5cGUsIGNhcHR1cmUsIG9uY2UsIHBhc3NpdmUpKSB7XG4gICAgICByZXR1cm4gaTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIC0xO1xufVxuXG4vKipcbiAqIEZpcmVmb3ggY2FuIHRocm93IG9uIGFjY2Vzc2luZyBldmVudFdyYXBwZXJzIGluc2lkZSBvZiBgcmVtb3ZlRXZlbnRMaXN0ZW5lcmAgZHVyaW5nIGEgc2VsZW5pdW0gcnVuXG4gKiBUcnkvQ2F0Y2ggYWNjZXNzaW5nIGV2ZW50V3JhcHBlcnMgdG8gd29yayBhcm91bmRcbiAqIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTEzNTMwNzRcbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRXcmFwcGVycyhldmVudExpa2UpIHtcbiAgbGV0IHdyYXBwZXJzID0gbnVsbDtcbiAgdHJ5IHtcbiAgICB3cmFwcGVycyA9IGV2ZW50TGlrZVtldmVudFdyYXBwZXJzTmFtZV07XG4gIH0gY2F0Y2ggKGUpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgcmV0dXJuIHdyYXBwZXJzO1xufVxuXG5mdW5jdGlvbiB0YXJnZXROZWVkc1BhdGhDaGVjayhub2RlKSB7XG4gIHJldHVybiB1dGlscy5pc1NoYWR5Um9vdChub2RlKSB8fCBub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnO1xufVxuXG4vKipcbiAqIEB0aGlzIHtFdmVudFRhcmdldH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgZm5Pck9iaiwgb3B0aW9uc09yQ2FwdHVyZSkge1xuICBjb25zdCB7Y2FwdHVyZSwgb25jZSwgcGFzc2l2ZSwgc2hhZHlUYXJnZXQsIG5hdGl2ZUV2ZW50T3B0aW9uc30gPVxuICAgIHBhcnNlRXZlbnRPcHRpb25zKG9wdGlvbnNPckNhcHR1cmUpO1xuICBpZiAoIWZuT3JPYmopIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBoYW5kbGVyVHlwZSA9IHR5cGVvZiBmbk9yT2JqO1xuXG4gIC8vIGJhaWwgaWYgYGZuT3JPYmpgIGlzIG5vdCBhIGZ1bmN0aW9uLCBub3QgYW4gb2JqZWN0XG4gIGlmIChoYW5kbGVyVHlwZSAhPT0gJ2Z1bmN0aW9uJyAmJiBoYW5kbGVyVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBiYWlsIGlmIGBmbk9yT2JqYCBpcyBhbiBvYmplY3Qgd2l0aG91dCBhIGBoYW5kbGVFdmVudGAgbWV0aG9kXG4gIGlmIChoYW5kbGVyVHlwZSA9PT0gJ29iamVjdCcgJiYgKCFmbk9yT2JqLmhhbmRsZUV2ZW50IHx8IHR5cGVvZiBmbk9yT2JqLmhhbmRsZUV2ZW50ICE9PSAnZnVuY3Rpb24nKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICh1bnBhdGNoZWRFdmVudHNbdHlwZV0pIHtcbiAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXSh0eXBlLCBmbk9yT2JqLCBuYXRpdmVFdmVudE9wdGlvbnMpO1xuICB9XG5cbiAgLy8gaGFjayB0byBsZXQgU2hhZHlSb290cyBoYXZlIGV2ZW50IGxpc3RlbmVyc1xuICAvLyBldmVudCBsaXN0ZW5lciB3aWxsIGJlIG9uIGhvc3QsIGJ1dCBgY3VycmVudFRhcmdldGBcbiAgLy8gd2lsbCBiZSBzZXQgdG8gc2hhZHlyb290IGZvciBldmVudCBsaXN0ZW5lclxuICBsZXQgdGFyZ2V0ID0gc2hhZHlUYXJnZXQgfHwgdGhpcztcblxuICBsZXQgd3JhcHBlcnMgPSBmbk9yT2JqW2V2ZW50V3JhcHBlcnNOYW1lXTtcbiAgaWYgKHdyYXBwZXJzKSB7XG4gICAgLy8gVGhlIGNhbGxiYWNrIGBmbmAgbWlnaHQgYmUgdXNlZCBmb3IgbXVsdGlwbGUgbm9kZXMvZXZlbnRzLiBTaW5jZSB3ZSBnZW5lcmF0ZVxuICAgIC8vIGEgd3JhcHBlciBmdW5jdGlvbiwgd2UgbmVlZCB0byBrZWVwIHRyYWNrIG9mIGl0IHdoZW4gd2UgcmVtb3ZlIHRoZSBsaXN0ZW5lci5cbiAgICAvLyBJdCdzIG1vcmUgZWZmaWNpZW50IHRvIHN0b3JlIHRoZSBub2RlL3R5cGUvb3B0aW9ucyBpbmZvcm1hdGlvbiBhcyBBcnJheSBpblxuICAgIC8vIGBmbmAgaXRzZWxmIHJhdGhlciB0aGFuIHRoZSBub2RlICh3ZSBhc3N1bWUgdGhhdCB0aGUgc2FtZSBjYWxsYmFjayBpcyB1c2VkXG4gICAgLy8gZm9yIGZldyBub2RlcyBhdCBtb3N0LCB3aGVyZWFzIGEgbm9kZSB3aWxsIGxpa2VseSBoYXZlIG1hbnkgZXZlbnQgbGlzdGVuZXJzKS5cbiAgICAvLyBOT1RFKHZhbGRyaW4pIGludm9raW5nIGV4dGVybmFsIGZ1bmN0aW9ucyBpcyBjb3N0bHksIGlubGluZSBoYXMgYmV0dGVyIHBlcmYuXG4gICAgLy8gU3RvcCBpZiB0aGUgd3JhcHBlciBmdW5jdGlvbiBoYXMgYWxyZWFkeSBiZWVuIGNyZWF0ZWQuXG4gICAgaWYgKGZpbmRMaXN0ZW5lcih3cmFwcGVycywgdGFyZ2V0LCB0eXBlLCBjYXB0dXJlLCBvbmNlLCBwYXNzaXZlKSA+IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZuT3JPYmpbZXZlbnRXcmFwcGVyc05hbWVdID0gW107XG4gIH1cblxuICAvKipcbiAgICogQHRoaXMge0hUTUxFbGVtZW50fVxuICAgKiBAcGFyYW0ge0V2ZW50fSBlXG4gICAqL1xuICBjb25zdCB3cmFwcGVyRm4gPSBmdW5jdGlvbihlKSB7XG4gICAgLy8gU3VwcG9ydCBgb25jZWAgb3B0aW9uLlxuICAgIGlmIChvbmNlKSB7XG4gICAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVFdmVudExpc3RlbmVyJ10odHlwZSwgZm5Pck9iaiwgb3B0aW9uc09yQ2FwdHVyZSk7XG4gICAgfVxuICAgIGlmICghZVsnX190YXJnZXQnXSkge1xuICAgICAgcGF0Y2hFdmVudChlKTtcbiAgICB9XG4gICAgbGV0IGxhc3RDdXJyZW50VGFyZ2V0RGVzYztcbiAgICBpZiAodGFyZ2V0ICE9PSB0aGlzKSB7XG4gICAgICAvLyByZXBsYWNlIGBjdXJyZW50VGFyZ2V0YCB0byBtYWtlIGB0YXJnZXRgIGFuZCBgcmVsYXRlZFRhcmdldGAgY29ycmVjdCBmb3IgaW5zaWRlIHRoZSBzaGFkb3dyb290XG4gICAgICBsYXN0Q3VycmVudFRhcmdldERlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsICdjdXJyZW50VGFyZ2V0Jyk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2N1cnJlbnRUYXJnZXQnLCB7Z2V0KCkgeyByZXR1cm4gdGFyZ2V0IH0sIGNvbmZpZ3VyYWJsZTogdHJ1ZX0pO1xuICAgIH1cbiAgICBlWydfX3ByZXZpb3VzQ3VycmVudFRhcmdldCddID0gZVsnY3VycmVudFRhcmdldCddO1xuICAgIC8vIEFsd2F5cyBjaGVjayBpZiBhIHNoYWRvd1Jvb3Qgb3Igc2xvdCBpcyBpbiB0aGUgY3VycmVudCBldmVudCBwYXRoLlxuICAgIC8vIElmIGl0IGlzIG5vdCwgdGhlIGV2ZW50IHdhcyBnZW5lcmF0ZWQgb24gZWl0aGVyIHRoZSBob3N0IG9mIHRoZSBzaGFkb3dSb290XG4gICAgLy8gb3IgYSBjaGlsZHJlbiBvZiB0aGUgaG9zdC5cbiAgICBpZiAodGFyZ2V0TmVlZHNQYXRoQ2hlY2sodGFyZ2V0KSAmJiBlLmNvbXBvc2VkUGF0aCgpLmluZGV4T2YodGFyZ2V0KSA9PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBUaGVyZSBhcmUgdHdvIGNyaXRlcmEgdGhhdCBzaG91bGQgc3RvcCBldmVudHMgZnJvbSBmaXJpbmcgb24gdGhpcyBub2RlXG4gICAgLy8gMS4gdGhlIGV2ZW50IGlzIG5vdCBjb21wb3NlZCBhbmQgdGhlIGN1cnJlbnQgbm9kZSBpcyBub3QgaW4gdGhlIHNhbWUgcm9vdCBhcyB0aGUgdGFyZ2V0XG4gICAgLy8gMi4gd2hlbiBidWJibGluZywgaWYgYWZ0ZXIgcmV0YXJnZXRpbmcsIHJlbGF0ZWRUYXJnZXQgYW5kIHRhcmdldCBwb2ludCB0byB0aGUgc2FtZSBub2RlXG4gICAgaWYgKGUuY29tcG9zZWQgfHwgZS5jb21wb3NlZFBhdGgoKS5pbmRleE9mKHRhcmdldCkgPiAtMSkge1xuICAgICAgaWYgKGhhc1JldGFyZ2V0ZWQoZSkgJiYgZS50YXJnZXQgPT09IGUucmVsYXRlZFRhcmdldCkge1xuICAgICAgICBpZiAoZS5ldmVudFBoYXNlID09PSBFdmVudC5CVUJCTElOR19QSEFTRSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gcHJldmVudCBub24tYnViYmxpbmcgZXZlbnRzIGZyb20gdHJpZ2dlcmluZyBidWJibGluZyBoYW5kbGVycyBvbiBzaGFkb3dyb290LCBidXQgb25seSBpZiBub3QgaW4gY2FwdHVyZSBwaGFzZVxuICAgICAgaWYgKGUuZXZlbnRQaGFzZSAhPT0gRXZlbnQuQ0FQVFVSSU5HX1BIQVNFICYmICFlLmJ1YmJsZXMgJiYgZS50YXJnZXQgIT09IHRhcmdldCAmJiAhKHRhcmdldCBpbnN0YW5jZW9mIFdpbmRvdykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IHJldCA9IGhhbmRsZXJUeXBlID09PSAnZnVuY3Rpb24nID9cbiAgICAgICAgZm5Pck9iai5jYWxsKHRhcmdldCwgZSkgOlxuICAgICAgICAoZm5Pck9iai5oYW5kbGVFdmVudCAmJiBmbk9yT2JqLmhhbmRsZUV2ZW50KGUpKTtcbiAgICAgIGlmICh0YXJnZXQgIT09IHRoaXMpIHtcbiAgICAgICAgLy8gcmVwbGFjZSB0aGUgXCJjb3JyZWN0XCIgYGN1cnJlbnRUYXJnZXRgXG4gICAgICAgIGlmIChsYXN0Q3VycmVudFRhcmdldERlc2MpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgJ2N1cnJlbnRUYXJnZXQnLCBsYXN0Q3VycmVudFRhcmdldERlc2MpO1xuICAgICAgICAgIGxhc3RDdXJyZW50VGFyZ2V0RGVzYyA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGVbJ2N1cnJlbnRUYXJnZXQnXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH07XG5cbiAgLy8gU3RvcmUgdGhlIHdyYXBwZXIgaW5mb3JtYXRpb24uXG4gIGZuT3JPYmpbZXZlbnRXcmFwcGVyc05hbWVdLnB1c2goe1xuICAgIC8vIG5vdGU6IHVzZSB0YXJnZXQgaGVyZSB3aGljaCBpcyBlaXRoZXIgYSBzaGFkb3dSb290XG4gICAgLy8gKHdoZW4gdGhlIGhvc3QgZWxlbWVudCBpcyBwcm94eSdpbmcgdGhlIGV2ZW50KSBvciB0aGlzIGVsZW1lbnRcbiAgICBub2RlOiB0YXJnZXQsXG4gICAgdHlwZTogdHlwZSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIG9uY2U6IG9uY2UsXG4gICAgcGFzc2l2ZTogcGFzc2l2ZSxcbiAgICB3cmFwcGVyRm46IHdyYXBwZXJGblxuICB9KTtcblxuICBpZiAobm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0W3R5cGVdKSB7XG4gICAgdGhpcy5fX2hhbmRsZXJzID0gdGhpcy5fX2hhbmRsZXJzIHx8IHt9O1xuICAgIHRoaXMuX19oYW5kbGVyc1t0eXBlXSA9IHRoaXMuX19oYW5kbGVyc1t0eXBlXSB8fFxuICAgICAgeydjYXB0dXJlJzogW10sICdidWJibGUnOiBbXX07XG4gICAgdGhpcy5fX2hhbmRsZXJzW3R5cGVdW2NhcHR1cmUgPyAnY2FwdHVyZScgOiAnYnViYmxlJ10ucHVzaCh3cmFwcGVyRm4pO1xuICB9IGVsc2Uge1xuICAgIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdhZGRFdmVudExpc3RlbmVyJ10odHlwZSwgd3JhcHBlckZuLCBuYXRpdmVFdmVudE9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxuICogQHRoaXMge0V2ZW50VGFyZ2V0fVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbk9yT2JqLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gIGlmICghZm5Pck9iaikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCB7Y2FwdHVyZSwgb25jZSwgcGFzc2l2ZSwgc2hhZHlUYXJnZXQsIG5hdGl2ZUV2ZW50T3B0aW9uc30gPVxuICAgIHBhcnNlRXZlbnRPcHRpb25zKG9wdGlvbnNPckNhcHR1cmUpO1xuICBpZiAodW5wYXRjaGVkRXZlbnRzW3R5cGVdKSB7XG4gICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVFdmVudExpc3RlbmVyJ10odHlwZSwgZm5Pck9iaiwgbmF0aXZlRXZlbnRPcHRpb25zKTtcbiAgfVxuICBsZXQgdGFyZ2V0ID0gc2hhZHlUYXJnZXQgfHwgdGhpcztcbiAgLy8gU2VhcmNoIHRoZSB3cmFwcGVkIGZ1bmN0aW9uLlxuICBsZXQgd3JhcHBlckZuID0gdW5kZWZpbmVkO1xuICBsZXQgd3JhcHBlcnMgPSBnZXRFdmVudFdyYXBwZXJzKGZuT3JPYmopO1xuICBpZiAod3JhcHBlcnMpIHtcbiAgICBsZXQgaWR4ID0gZmluZExpc3RlbmVyKHdyYXBwZXJzLCB0YXJnZXQsIHR5cGUsIGNhcHR1cmUsIG9uY2UsIHBhc3NpdmUpO1xuICAgIGlmIChpZHggPiAtMSkge1xuICAgICAgd3JhcHBlckZuID0gd3JhcHBlcnMuc3BsaWNlKGlkeCwgMSlbMF0ud3JhcHBlckZuO1xuICAgICAgLy8gQ2xlYW51cC5cbiAgICAgIGlmICghd3JhcHBlcnMubGVuZ3RoKSB7XG4gICAgICAgIGZuT3JPYmpbZXZlbnRXcmFwcGVyc05hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncmVtb3ZlRXZlbnRMaXN0ZW5lciddKHR5cGUsIHdyYXBwZXJGbiB8fCBmbk9yT2JqLFxuICAgIG5hdGl2ZUV2ZW50T3B0aW9ucyk7XG4gIGlmICh3cmFwcGVyRm4gJiYgbm9uQnViYmxpbmdFdmVudHNUb1JldGFyZ2V0W3R5cGVdICYmXG4gICAgICB0aGlzLl9faGFuZGxlcnMgJiYgdGhpcy5fX2hhbmRsZXJzW3R5cGVdKSB7XG4gICAgY29uc3QgYXJyID0gdGhpcy5fX2hhbmRsZXJzW3R5cGVdW2NhcHR1cmUgPyAnY2FwdHVyZScgOiAnYnViYmxlJ107XG4gICAgY29uc3QgaWR4ID0gYXJyLmluZGV4T2Yod3JhcHBlckZuKTtcbiAgICBpZiAoaWR4ID4gLTEpIHtcbiAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0aXZhdGVGb2N1c0V2ZW50T3ZlcnJpZGVzKCkge1xuICBmb3IgKGxldCBldiBpbiBub25CdWJibGluZ0V2ZW50c1RvUmV0YXJnZXQpIHtcbiAgICB3aW5kb3dbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdhZGRFdmVudExpc3RlbmVyJ10oZXYsIGZ1bmN0aW9uKGUpIHtcbiAgICAgIGlmICghZVsnX190YXJnZXQnXSkge1xuICAgICAgICBwYXRjaEV2ZW50KGUpO1xuICAgICAgICByZXRhcmdldE5vbkJ1YmJsaW5nRXZlbnQoZSk7XG4gICAgICB9XG4gICAgfSwgdHJ1ZSk7XG4gIH1cbn1cblxuY29uc3QgRXZlbnRQYXRjaGVzRGVzY3JpcHRvcnMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKEV2ZW50UGF0Y2hlcyk7XG5cbmNvbnN0IFNIQURZX1BST1RPID0gJ19fc2hhZHlfcGF0Y2hlZFByb3RvJztcbmNvbnN0IFNIQURZX1NPVVJDRV9QUk9UTyA9ICdfX3NoYWR5X3NvdXJjZVByb3RvJztcblxuZnVuY3Rpb24gcGF0Y2hFdmVudChldmVudCkge1xuICBldmVudFsnX190YXJnZXQnXSA9IGV2ZW50LnRhcmdldDtcbiAgZXZlbnQuX19yZWxhdGVkVGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgLy8gYXR0ZW1wdCB0byBwYXRjaCBwcm90b3R5cGUgKHZpYSBjYWNoZSlcbiAgaWYgKHV0aWxzLnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzKSB7XG4gICAgY29uc3QgcHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZXZlbnQpO1xuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3RvLCBTSEFEWV9QUk9UTykpIHtcbiAgICAgIGNvbnN0IHBhdGNoZWRQcm90byA9IE9iamVjdC5jcmVhdGUocHJvdG8pO1xuICAgICAgcGF0Y2hlZFByb3RvW1NIQURZX1NPVVJDRV9QUk9UT10gPSBwcm90bztcbiAgICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwYXRjaGVkUHJvdG8sIEV2ZW50UGF0Y2hlc0Rlc2NyaXB0b3JzKTtcbiAgICAgIHByb3RvW1NIQURZX1BST1RPXSA9IHBhdGNoZWRQcm90bztcbiAgICB9XG4gICAgZXZlbnQuX19wcm90b19fID0gcHJvdG9bU0hBRFlfUFJPVE9dO1xuICAvLyBhbmQgZmFsbGJhY2sgdG8gcGF0Y2hpbmcgaW5zdGFuY2VcbiAgfSBlbHNlIHtcbiAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMoZXZlbnQsIEV2ZW50UGF0Y2hlc0Rlc2NyaXB0b3JzKTtcbiAgfVxufVxuXG5sZXQgUGF0Y2hlZEV2ZW50ID0gbWl4aW5Db21wb3NlZEZsYWcoRXZlbnQpO1xubGV0IFBhdGNoZWRDdXN0b21FdmVudCA9IG1peGluQ29tcG9zZWRGbGFnKEN1c3RvbUV2ZW50KTtcbmxldCBQYXRjaGVkTW91c2VFdmVudCA9IG1peGluQ29tcG9zZWRGbGFnKE1vdXNlRXZlbnQpO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXRjaEV2ZW50cygpIHtcbiAgYWN0aXZhdGVGb2N1c0V2ZW50T3ZlcnJpZGVzKCk7XG4gIHdpbmRvdy5FdmVudCA9IFBhdGNoZWRFdmVudDtcbiAgd2luZG93LkN1c3RvbUV2ZW50ID0gUGF0Y2hlZEN1c3RvbUV2ZW50O1xuICB3aW5kb3cuTW91c2VFdmVudCA9IFBhdGNoZWRNb3VzZUV2ZW50O1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGF0Y2hDbGljaygpIHtcbiAgLy8gRml4IHVwIGBFbGVtZW50LnByb3RvdHlwZS5jbGljaygpYCBpZiBgaXNUcnVzdGVkYCBpcyBzdXBwb3J0ZWQsIGJ1dCBgY29tcG9zZWRgIGlzbid0XG4gIGlmICghY29tcG9zZWRHZXR0ZXIgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFdmVudC5wcm90b3R5cGUsICdpc1RydXN0ZWQnKSkge1xuICAgIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgICBjb25zdCBjb21wb3NlZENsaWNrRm4gPSBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnN0IGV2ID0gbmV3IE1vdXNlRXZlbnQoJ2NsaWNrJywge1xuICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICBjb21wb3NlZDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdkaXNwYXRjaEV2ZW50J10oZXYpO1xuICAgIH07XG4gICAgaWYgKEVsZW1lbnQucHJvdG90eXBlLmNsaWNrKSB7XG4gICAgICBFbGVtZW50LnByb3RvdHlwZS5jbGljayA9IGNvbXBvc2VkQ2xpY2tGbjtcbiAgICB9IGVsc2UgaWYgKEhUTUxFbGVtZW50LnByb3RvdHlwZS5jbGljaykge1xuICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLmNsaWNrID0gY29tcG9zZWRDbGlja0ZuO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgY29uc3QgZXZlbnRQcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoRG9jdW1lbnQucHJvdG90eXBlKVxuICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLnN1YnN0cmluZygwLDIpID09PSAnb24nKTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmZ1bmN0aW9uIG5ld1NwbGljZShpbmRleCwgcmVtb3ZlZCwgYWRkZWRDb3VudCkge1xuICByZXR1cm4ge1xuICAgIGluZGV4OiBpbmRleCxcbiAgICByZW1vdmVkOiByZW1vdmVkLFxuICAgIGFkZGVkQ291bnQ6IGFkZGVkQ291bnRcbiAgfTtcbn1cblxuY29uc3QgRURJVF9MRUFWRSA9IDA7XG5jb25zdCBFRElUX1VQREFURSA9IDE7XG5jb25zdCBFRElUX0FERCA9IDI7XG5jb25zdCBFRElUX0RFTEVURSA9IDM7XG5cbi8vIE5vdGU6IFRoaXMgZnVuY3Rpb24gaXMgKmJhc2VkKiBvbiB0aGUgY29tcHV0YXRpb24gb2YgdGhlIExldmVuc2h0ZWluXG4vLyBcImVkaXRcIiBkaXN0YW5jZS4gVGhlIG9uZSBjaGFuZ2UgaXMgdGhhdCBcInVwZGF0ZXNcIiBhcmUgdHJlYXRlZCBhcyB0d29cbi8vIGVkaXRzIC0gbm90IG9uZS4gV2l0aCBBcnJheSBzcGxpY2VzLCBhbiB1cGRhdGUgaXMgcmVhbGx5IGEgZGVsZXRlXG4vLyBmb2xsb3dlZCBieSBhbiBhZGQuIEJ5IHJldGFpbmluZyB0aGlzLCB3ZSBvcHRpbWl6ZSBmb3IgXCJrZWVwaW5nXCIgdGhlXG4vLyBtYXhpbXVtIGFycmF5IGl0ZW1zIGluIHRoZSBvcmlnaW5hbCBhcnJheS4gRm9yIGV4YW1wbGU6XG4vL1xuLy8gICAneHh4eDEyMycgLT4gJzEyM3l5eXknXG4vL1xuLy8gV2l0aCAxLWVkaXQgdXBkYXRlcywgdGhlIHNob3J0ZXN0IHBhdGggd291bGQgYmUganVzdCB0byB1cGRhdGUgYWxsIHNldmVuXG4vLyBjaGFyYWN0ZXJzLiBXaXRoIDItZWRpdCB1cGRhdGVzLCB3ZSBkZWxldGUgNCwgbGVhdmUgMywgYW5kIGFkZCA0LiBUaGlzXG4vLyBsZWF2ZXMgdGhlIHN1YnN0cmluZyAnMTIzJyBpbnRhY3QuXG5mdW5jdGlvbiBjYWxjRWRpdERpc3RhbmNlcyhjdXJyZW50LCBjdXJyZW50U3RhcnQsIGN1cnJlbnRFbmQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkLCBvbGRTdGFydCwgb2xkRW5kKSB7XG4gIC8vIFwiRGVsZXRpb25cIiBjb2x1bW5zXG4gIGxldCByb3dDb3VudCA9IG9sZEVuZCAtIG9sZFN0YXJ0ICsgMTtcbiAgbGV0IGNvbHVtbkNvdW50ID0gY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCArIDE7XG4gIGxldCBkaXN0YW5jZXMgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuXG4gIC8vIFwiQWRkaXRpb25cIiByb3dzLiBJbml0aWFsaXplIG51bGwgY29sdW1uLlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHJvd0NvdW50OyBpKyspIHtcbiAgICBkaXN0YW5jZXNbaV0gPSBuZXcgQXJyYXkoY29sdW1uQ291bnQpO1xuICAgIGRpc3RhbmNlc1tpXVswXSA9IGk7XG4gIH1cblxuICAvLyBJbml0aWFsaXplIG51bGwgcm93XG4gIGZvciAobGV0IGogPSAwOyBqIDwgY29sdW1uQ291bnQ7IGorKylcbiAgICBkaXN0YW5jZXNbMF1bal0gPSBqO1xuXG4gIGZvciAobGV0IGkgPSAxOyBpIDwgcm93Q291bnQ7IGkrKykge1xuICAgIGZvciAobGV0IGogPSAxOyBqIDwgY29sdW1uQ291bnQ7IGorKykge1xuICAgICAgaWYgKGVxdWFscyhjdXJyZW50W2N1cnJlbnRTdGFydCArIGogLSAxXSwgb2xkW29sZFN0YXJ0ICsgaSAtIDFdKSlcbiAgICAgICAgZGlzdGFuY2VzW2ldW2pdID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgICBlbHNlIHtcbiAgICAgICAgbGV0IG5vcnRoID0gZGlzdGFuY2VzW2kgLSAxXVtqXSArIDE7XG4gICAgICAgIGxldCB3ZXN0ID0gZGlzdGFuY2VzW2ldW2ogLSAxXSArIDE7XG4gICAgICAgIGRpc3RhbmNlc1tpXVtqXSA9IG5vcnRoIDwgd2VzdCA/IG5vcnRoIDogd2VzdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZGlzdGFuY2VzO1xufVxuXG4vLyBUaGlzIHN0YXJ0cyBhdCB0aGUgZmluYWwgd2VpZ2h0LCBhbmQgd2Fsa3MgXCJiYWNrd2FyZFwiIGJ5IGZpbmRpbmdcbi8vIHRoZSBtaW5pbXVtIHByZXZpb3VzIHdlaWdodCByZWN1cnNpdmVseSB1bnRpbCB0aGUgb3JpZ2luIG9mIHRoZSB3ZWlnaHRcbi8vIG1hdHJpeC5cbmZ1bmN0aW9uIHNwbGljZU9wZXJhdGlvbnNGcm9tRWRpdERpc3RhbmNlcyhkaXN0YW5jZXMpIHtcbiAgbGV0IGkgPSBkaXN0YW5jZXMubGVuZ3RoIC0gMTtcbiAgbGV0IGogPSBkaXN0YW5jZXNbMF0ubGVuZ3RoIC0gMTtcbiAgbGV0IGN1cnJlbnQgPSBkaXN0YW5jZXNbaV1bal07XG4gIGxldCBlZGl0cyA9IFtdO1xuICB3aGlsZSAoaSA+IDAgfHwgaiA+IDApIHtcbiAgICBpZiAoaSA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfQUREKTtcbiAgICAgIGotLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoaiA9PSAwKSB7XG4gICAgICBlZGl0cy5wdXNoKEVESVRfREVMRVRFKTtcbiAgICAgIGktLTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBsZXQgbm9ydGhXZXN0ID0gZGlzdGFuY2VzW2kgLSAxXVtqIC0gMV07XG4gICAgbGV0IHdlc3QgPSBkaXN0YW5jZXNbaSAtIDFdW2pdO1xuICAgIGxldCBub3J0aCA9IGRpc3RhbmNlc1tpXVtqIC0gMV07XG5cbiAgICBsZXQgbWluO1xuICAgIGlmICh3ZXN0IDwgbm9ydGgpXG4gICAgICBtaW4gPSB3ZXN0IDwgbm9ydGhXZXN0ID8gd2VzdCA6IG5vcnRoV2VzdDtcbiAgICBlbHNlXG4gICAgICBtaW4gPSBub3J0aCA8IG5vcnRoV2VzdCA/IG5vcnRoIDogbm9ydGhXZXN0O1xuXG4gICAgaWYgKG1pbiA9PSBub3J0aFdlc3QpIHtcbiAgICAgIGlmIChub3J0aFdlc3QgPT0gY3VycmVudCkge1xuICAgICAgICBlZGl0cy5wdXNoKEVESVRfTEVBVkUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZWRpdHMucHVzaChFRElUX1VQREFURSk7XG4gICAgICAgIGN1cnJlbnQgPSBub3J0aFdlc3Q7XG4gICAgICB9XG4gICAgICBpLS07XG4gICAgICBqLS07XG4gICAgfSBlbHNlIGlmIChtaW4gPT0gd2VzdCkge1xuICAgICAgZWRpdHMucHVzaChFRElUX0RFTEVURSk7XG4gICAgICBpLS07XG4gICAgICBjdXJyZW50ID0gd2VzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdHMucHVzaChFRElUX0FERCk7XG4gICAgICBqLS07XG4gICAgICBjdXJyZW50ID0gbm9ydGg7XG4gICAgfVxuICB9XG5cbiAgZWRpdHMucmV2ZXJzZSgpO1xuICByZXR1cm4gZWRpdHM7XG59XG5cbi8qKlxuICogU3BsaWNlIFByb2plY3Rpb24gZnVuY3Rpb25zOlxuICpcbiAqIEEgc3BsaWNlIG1hcCBpcyBhIHJlcHJlc2VudGF0aW9uIG9mIGhvdyBhIHByZXZpb3VzIGFycmF5IG9mIGl0ZW1zXG4gKiB3YXMgdHJhbnNmb3JtZWQgaW50byBhIG5ldyBhcnJheSBvZiBpdGVtcy4gQ29uY2VwdHVhbGx5IGl0IGlzIGEgbGlzdCBvZlxuICogdHVwbGVzIG9mXG4gKlxuICogICA8aW5kZXgsIHJlbW92ZWQsIGFkZGVkQ291bnQ+XG4gKlxuICogd2hpY2ggYXJlIGtlcHQgaW4gYXNjZW5kaW5nIGluZGV4IG9yZGVyIG9mLiBUaGUgdHVwbGUgcmVwcmVzZW50cyB0aGF0IGF0XG4gKiB0aGUgfGluZGV4fCwgfHJlbW92ZWR8IHNlcXVlbmNlIG9mIGl0ZW1zIHdlcmUgcmVtb3ZlZCwgYW5kIGNvdW50aW5nIGZvcndhcmRcbiAqIGZyb20gfGluZGV4fCwgfGFkZGVkQ291bnR8IGl0ZW1zIHdlcmUgYWRkZWQuXG4gKi9cblxuLyoqXG4gKiBMYWNraW5nIGluZGl2aWR1YWwgc3BsaWNlIG11dGF0aW9uIGluZm9ybWF0aW9uLCB0aGUgbWluaW1hbCBzZXQgb2ZcbiAqIHNwbGljZXMgY2FuIGJlIHN5bnRoZXNpemVkIGdpdmVuIHRoZSBwcmV2aW91cyBzdGF0ZSBhbmQgZmluYWwgc3RhdGUgb2YgYW5cbiAqIGFycmF5LiBUaGUgYmFzaWMgYXBwcm9hY2ggaXMgdG8gY2FsY3VsYXRlIHRoZSBlZGl0IGRpc3RhbmNlIG1hdHJpeCBhbmRcbiAqIGNob29zZSB0aGUgc2hvcnRlc3QgcGF0aCB0aHJvdWdoIGl0LlxuICpcbiAqIENvbXBsZXhpdHk6IE8obCAqIHApXG4gKiAgIGw6IFRoZSBsZW5ndGggb2YgdGhlIGN1cnJlbnQgYXJyYXlcbiAqICAgcDogVGhlIGxlbmd0aCBvZiB0aGUgb2xkIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNhbGNTcGxpY2VzKGN1cnJlbnQsIGN1cnJlbnRTdGFydCwgY3VycmVudEVuZCxcbiAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpIHtcbiAgbGV0IHByZWZpeENvdW50ID0gMDtcbiAgbGV0IHN1ZmZpeENvdW50ID0gMDtcbiAgbGV0IHNwbGljZTtcblxuICBsZXQgbWluTGVuZ3RoID0gTWF0aC5taW4oY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCwgb2xkRW5kIC0gb2xkU3RhcnQpO1xuICBpZiAoY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkU3RhcnQgPT0gMClcbiAgICBwcmVmaXhDb3VudCA9IHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIG1pbkxlbmd0aCk7XG5cbiAgaWYgKGN1cnJlbnRFbmQgPT0gY3VycmVudC5sZW5ndGggJiYgb2xkRW5kID09IG9sZC5sZW5ndGgpXG4gICAgc3VmZml4Q291bnQgPSBzaGFyZWRTdWZmaXgoY3VycmVudCwgb2xkLCBtaW5MZW5ndGggLSBwcmVmaXhDb3VudCk7XG5cbiAgY3VycmVudFN0YXJ0ICs9IHByZWZpeENvdW50O1xuICBvbGRTdGFydCArPSBwcmVmaXhDb3VudDtcbiAgY3VycmVudEVuZCAtPSBzdWZmaXhDb3VudDtcbiAgb2xkRW5kIC09IHN1ZmZpeENvdW50O1xuXG4gIGlmIChjdXJyZW50RW5kIC0gY3VycmVudFN0YXJ0ID09IDAgJiYgb2xkRW5kIC0gb2xkU3RhcnQgPT0gMClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKGN1cnJlbnRTdGFydCA9PSBjdXJyZW50RW5kKSB7XG4gICAgc3BsaWNlID0gbmV3U3BsaWNlKGN1cnJlbnRTdGFydCwgW10sIDApO1xuICAgIHdoaWxlIChvbGRTdGFydCA8IG9sZEVuZClcbiAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZFN0YXJ0KytdKTtcblxuICAgIHJldHVybiBbIHNwbGljZSBdO1xuICB9IGVsc2UgaWYgKG9sZFN0YXJ0ID09IG9sZEVuZClcbiAgICByZXR1cm4gWyBuZXdTcGxpY2UoY3VycmVudFN0YXJ0LCBbXSwgY3VycmVudEVuZCAtIGN1cnJlbnRTdGFydCkgXTtcblxuICBsZXQgb3BzID0gc3BsaWNlT3BlcmF0aW9uc0Zyb21FZGl0RGlzdGFuY2VzKFxuICAgICAgY2FsY0VkaXREaXN0YW5jZXMoY3VycmVudCwgY3VycmVudFN0YXJ0LCBjdXJyZW50RW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGQsIG9sZFN0YXJ0LCBvbGRFbmQpKTtcblxuICBzcGxpY2UgPSB1bmRlZmluZWQ7XG4gIGxldCBzcGxpY2VzID0gW107XG4gIGxldCBpbmRleCA9IGN1cnJlbnRTdGFydDtcbiAgbGV0IG9sZEluZGV4ID0gb2xkU3RhcnQ7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3dpdGNoKG9wc1tpXSkge1xuICAgICAgY2FzZSBFRElUX0xFQVZFOlxuICAgICAgICBpZiAoc3BsaWNlKSB7XG4gICAgICAgICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gICAgICAgICAgc3BsaWNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgb2xkSW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfVVBEQVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UuYWRkZWRDb3VudCsrO1xuICAgICAgICBpbmRleCsrO1xuXG4gICAgICAgIHNwbGljZS5yZW1vdmVkLnB1c2gob2xkW29sZEluZGV4XSk7XG4gICAgICAgIG9sZEluZGV4Kys7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBFRElUX0FERDpcbiAgICAgICAgaWYgKCFzcGxpY2UpXG4gICAgICAgICAgc3BsaWNlID0gbmV3U3BsaWNlKGluZGV4LCBbXSwgMCk7XG5cbiAgICAgICAgc3BsaWNlLmFkZGVkQ291bnQrKztcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEVESVRfREVMRVRFOlxuICAgICAgICBpZiAoIXNwbGljZSlcbiAgICAgICAgICBzcGxpY2UgPSBuZXdTcGxpY2UoaW5kZXgsIFtdLCAwKTtcblxuICAgICAgICBzcGxpY2UucmVtb3ZlZC5wdXNoKG9sZFtvbGRJbmRleF0pO1xuICAgICAgICBvbGRJbmRleCsrO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICBpZiAoc3BsaWNlKSB7XG4gICAgc3BsaWNlcy5wdXNoKHNwbGljZSk7XG4gIH1cbiAgcmV0dXJuIHNwbGljZXM7XG59XG5cbmZ1bmN0aW9uIHNoYXJlZFByZWZpeChjdXJyZW50LCBvbGQsIHNlYXJjaExlbmd0aCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlYXJjaExlbmd0aDsgaSsrKVxuICAgIGlmICghZXF1YWxzKGN1cnJlbnRbaV0sIG9sZFtpXSkpXG4gICAgICByZXR1cm4gaTtcbiAgcmV0dXJuIHNlYXJjaExlbmd0aDtcbn1cblxuZnVuY3Rpb24gc2hhcmVkU3VmZml4KGN1cnJlbnQsIG9sZCwgc2VhcmNoTGVuZ3RoKSB7XG4gIGxldCBpbmRleDEgPSBjdXJyZW50Lmxlbmd0aDtcbiAgbGV0IGluZGV4MiA9IG9sZC5sZW5ndGg7XG4gIGxldCBjb3VudCA9IDA7XG4gIHdoaWxlIChjb3VudCA8IHNlYXJjaExlbmd0aCAmJiBlcXVhbHMoY3VycmVudFstLWluZGV4MV0sIG9sZFstLWluZGV4Ml0pKVxuICAgIGNvdW50Kys7XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG5mdW5jdGlvbiBlcXVhbHMoY3VycmVudFZhbHVlLCBwcmV2aW91c1ZhbHVlKSB7XG4gIHJldHVybiBjdXJyZW50VmFsdWUgPT09IHByZXZpb3VzVmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYWxjdWxhdGVTcGxpY2VzKGN1cnJlbnQsIHByZXZpb3VzKSB7XG4gIHJldHVybiBjYWxjU3BsaWNlcyhjdXJyZW50LCAwLCBjdXJyZW50Lmxlbmd0aCwgcHJldmlvdXMsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHByZXZpb3VzLmxlbmd0aCk7XG59XG5cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlLCBlbnN1cmVTaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuL3NoYWR5LWRhdGEuanMnO1xuaW1wb3J0IHtwYXRjaEluc2lkZUVsZW1lbnRBY2Nlc3NvcnMsIHBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnN9IGZyb20gJy4vcGF0Y2gtaW5zdGFuY2VzLmpzJztcblxuZnVuY3Rpb24gbGlua05vZGUobm9kZSwgY29udGFpbmVyLCBjb250YWluZXJEYXRhLCByZWZfbm9kZSkge1xuICBwYXRjaE91dHNpZGVFbGVtZW50QWNjZXNzb3JzKG5vZGUpO1xuICByZWZfbm9kZSA9IHJlZl9ub2RlIHx8IG51bGw7XG4gIGNvbnN0IG5vZGVEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgY29uc3QgcmVmX25vZGVEYXRhID0gcmVmX25vZGUgPyBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHJlZl9ub2RlKSA6IG51bGw7XG4gIC8vIHVwZGF0ZSByZWZfbm9kZS5wcmV2aW91c1NpYmxpbmcgPC0+IG5vZGVcbiAgbm9kZURhdGEucHJldmlvdXNTaWJsaW5nID0gcmVmX25vZGUgPyByZWZfbm9kZURhdGEucHJldmlvdXNTaWJsaW5nIDpcbiAgICBjb250YWluZXJbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICBsZXQgcHNkID0gc2hhZHlEYXRhRm9yTm9kZShub2RlRGF0YS5wcmV2aW91c1NpYmxpbmcpO1xuICBpZiAocHNkKSB7XG4gICAgcHNkLm5leHRTaWJsaW5nID0gbm9kZTtcbiAgfVxuICAvLyB1cGRhdGUgbm9kZSA8LT4gcmVmX25vZGVcbiAgbGV0IG5zZCA9IHNoYWR5RGF0YUZvck5vZGUobm9kZURhdGEubmV4dFNpYmxpbmcgPSByZWZfbm9kZSk7XG4gIGlmIChuc2QpIHtcbiAgICBuc2QucHJldmlvdXNTaWJsaW5nID0gbm9kZTtcbiAgfVxuICAvLyB1cGRhdGUgbm9kZSA8LT4gY29udGFpbmVyXG4gIG5vZGVEYXRhLnBhcmVudE5vZGUgPSBjb250YWluZXI7XG4gIGlmIChyZWZfbm9kZSkge1xuICAgIGlmIChyZWZfbm9kZSA9PT0gY29udGFpbmVyRGF0YS5maXJzdENoaWxkKSB7XG4gICAgICBjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQgPSBub2RlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250YWluZXJEYXRhLmxhc3RDaGlsZCA9IG5vZGU7XG4gICAgaWYgKCFjb250YWluZXJEYXRhLmZpcnN0Q2hpbGQpIHtcbiAgICAgIGNvbnRhaW5lckRhdGEuZmlyc3RDaGlsZCA9IG5vZGU7XG4gICAgfVxuICB9XG4gIC8vIHJlbW92ZSBjYWNoaW5nIG9mIGNoaWxkTm9kZXNcbiAgY29udGFpbmVyRGF0YS5jaGlsZE5vZGVzID0gbnVsbDtcbn1cblxuZXhwb3J0IGNvbnN0IHJlY29yZEluc2VydEJlZm9yZSA9IChub2RlLCBjb250YWluZXIsIHJlZl9ub2RlKSA9PiB7XG4gIHBhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycyhjb250YWluZXIpO1xuICBjb25zdCBjb250YWluZXJEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShjb250YWluZXIpO1xuICBpZiAoY29udGFpbmVyRGF0YS5maXJzdENoaWxkICE9PSB1bmRlZmluZWQpIHtcbiAgICBjb250YWluZXJEYXRhLmNoaWxkTm9kZXMgPSBudWxsO1xuICB9XG4gIC8vIGhhbmRsZSBkb2N1bWVudCBmcmFnbWVudHNcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgIC8vIE5vdGUsIGRvY3VtZW50RnJhZ21lbnRzIHNob3VsZCBub3QgaGF2ZSBsb2dpY2FsIERPTSBzbyB0aGVyZSdzXG4gICAgLy8gbm8gbmVlZCB1cGRhdGUgdGhhdC4gSXQgaXMgcG9zc2libGUgdG8gYXBwZW5kIGEgU2hhZG93Um9vdCwgYnV0IHdlJ3JlXG4gICAgLy8gY2hvb3Npbmcgbm90IHRvIHN1cHBvcnQgdGhhdC5cbiAgICBjb25zdCBmaXJzdCA9IG5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ107XG4gICAgZm9yIChsZXQgbiA9IGZpcnN0OyBuOyAobiA9IG5bdXRpbHMuTkFUSVZFX1BSRUZJWCArICduZXh0U2libGluZyddKSkge1xuICAgICAgbGlua05vZGUobiwgY29udGFpbmVyLCBjb250YWluZXJEYXRhLCByZWZfbm9kZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGxpbmtOb2RlKG5vZGUsIGNvbnRhaW5lciwgY29udGFpbmVyRGF0YSwgcmVmX25vZGUpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCByZWNvcmRSZW1vdmVDaGlsZCA9IChub2RlLCBjb250YWluZXIpID0+IHtcbiAgY29uc3Qgbm9kZURhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBjb25zdCBjb250YWluZXJEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShjb250YWluZXIpO1xuICBpZiAobm9kZSA9PT0gY29udGFpbmVyRGF0YS5maXJzdENoaWxkKSB7XG4gICAgY29udGFpbmVyRGF0YS5maXJzdENoaWxkID0gbm9kZURhdGEubmV4dFNpYmxpbmc7XG4gIH1cbiAgaWYgKG5vZGUgPT09IGNvbnRhaW5lckRhdGEubGFzdENoaWxkKSB7XG4gICAgY29udGFpbmVyRGF0YS5sYXN0Q2hpbGQgPSBub2RlRGF0YS5wcmV2aW91c1NpYmxpbmc7XG4gIH1cbiAgbGV0IHAgPSBub2RlRGF0YS5wcmV2aW91c1NpYmxpbmc7XG4gIGxldCBuID0gbm9kZURhdGEubmV4dFNpYmxpbmc7XG4gIGlmIChwKSB7XG4gICAgZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShwKS5uZXh0U2libGluZyA9IG47XG4gIH1cbiAgaWYgKG4pIHtcbiAgICBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG4pLnByZXZpb3VzU2libGluZyA9IHA7XG4gIH1cbiAgLy8gV2hlbiBhbiBlbGVtZW50IGlzIHJlbW92ZWQsIGxvZ2ljYWwgZGF0YSBpcyBubyBsb25nZXIgdHJhY2tlZC5cbiAgLy8gRXhwbGljaXRseSBzZXQgYHVuZGVmaW5lZGAgaGVyZSB0byBpbmRpY2F0ZSB0aGlzLiBUaGlzIGlzIGRpc2dpbmd1aXNoZWRcbiAgLy8gZnJvbSBgbnVsbGAgd2hpY2ggaXMgc2V0IGlmIGluZm8gaXMgbnVsbC5cbiAgbm9kZURhdGEucGFyZW50Tm9kZSA9IG5vZGVEYXRhLnByZXZpb3VzU2libGluZyA9XG4gIG5vZGVEYXRhLm5leHRTaWJsaW5nID0gdW5kZWZpbmVkO1xuICBpZiAoY29udGFpbmVyRGF0YS5jaGlsZE5vZGVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyByZW1vdmUgY2FjaGluZyBvZiBjaGlsZE5vZGVzXG4gICAgY29udGFpbmVyRGF0YS5jaGlsZE5vZGVzID0gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSAgeyFOb2RlfERvY3VtZW50RnJhZ21lbnR9IG5vZGVcbiAqIEBwYXJhbSAgeyFOb2RlfERvY3VtZW50RnJhZ21lbnQ9fSBhZG9wdGVkUGFyZW50XG4gKi9cbmV4cG9ydCBjb25zdCByZWNvcmRDaGlsZE5vZGVzID0gKG5vZGUsIGFkb3B0ZWRQYXJlbnQpID0+IHtcbiAgY29uc3Qgbm9kZURhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBpZiAoIWFkb3B0ZWRQYXJlbnQgJiYgbm9kZURhdGEuZmlyc3RDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIHJlbW92ZSBjYWNoaW5nIG9mIGNoaWxkTm9kZXNcbiAgbm9kZURhdGEuY2hpbGROb2RlcyA9IG51bGw7XG4gIGNvbnN0IGZpcnN0ID0gbm9kZURhdGEuZmlyc3RDaGlsZCA9IG5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ107XG4gIG5vZGVEYXRhLmxhc3RDaGlsZCA9IG5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdsYXN0Q2hpbGQnXTtcbiAgcGF0Y2hJbnNpZGVFbGVtZW50QWNjZXNzb3JzKG5vZGUpO1xuICBmb3IgKGxldCBuID0gZmlyc3QsIHByZXZpb3VzOyBuOyAobiA9IG5bdXRpbHMuTkFUSVZFX1BSRUZJWCArICduZXh0U2libGluZyddKSkge1xuICAgIGNvbnN0IHNkID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShuKTtcbiAgICBzZC5wYXJlbnROb2RlID0gYWRvcHRlZFBhcmVudCB8fCBub2RlO1xuICAgIHNkLm5leHRTaWJsaW5nID0gblt1dGlscy5OQVRJVkVfUFJFRklYICsgJ25leHRTaWJsaW5nJ107XG4gICAgc2QucHJldmlvdXNTaWJsaW5nID0gcHJldmlvdXMgfHwgbnVsbDtcbiAgICBwcmV2aW91cyA9IG47XG4gICAgcGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29ycyhuKTtcbiAgfVxufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5cbmxldCBzY29waW5nU2hpbSA9IG51bGw7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY29waW5nU2hpbSgpIHtcbiAgaWYgKCFzY29waW5nU2hpbSkge1xuICAgIHNjb3BpbmdTaGltID0gd2luZG93WydTaGFkeUNTUyddICYmIHdpbmRvd1snU2hhZHlDU1MnXVsnU2NvcGluZ1NoaW0nXTtcbiAgfVxuICByZXR1cm4gc2NvcGluZ1NoaW0gfHwgbnVsbDtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0clxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzY29wZUNsYXNzQXR0cmlidXRlKG5vZGUsIGF0dHIsIHZhbHVlKSB7XG4gIGNvbnN0IHNjb3BpbmdTaGltID0gZ2V0U2NvcGluZ1NoaW0oKTtcbiAgaWYgKHNjb3BpbmdTaGltICYmIGF0dHIgPT09ICdjbGFzcycpIHtcbiAgICBzY29waW5nU2hpbVsnc2V0RWxlbWVudENsYXNzJ10obm9kZSwgdmFsdWUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3U2NvcGVOYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhZGRTaGFkeVNjb3Bpbmcobm9kZSwgbmV3U2NvcGVOYW1lKSB7XG4gIGNvbnN0IHNjb3BpbmdTaGltID0gZ2V0U2NvcGluZ1NoaW0oKTtcbiAgaWYgKCFzY29waW5nU2hpbSkge1xuICAgIHJldHVybjtcbiAgfVxuICBzY29waW5nU2hpbVsnc2NvcGVOb2RlJ10obm9kZSwgbmV3U2NvcGVOYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFNjb3BlTmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlU2hhZHlTY29waW5nKG5vZGUsIGN1cnJlbnRTY29wZU5hbWUpIHtcbiAgY29uc3Qgc2NvcGluZ1NoaW0gPSBnZXRTY29waW5nU2hpbSgpO1xuICBpZiAoIXNjb3BpbmdTaGltKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNjb3BpbmdTaGltWyd1bnNjb3BlTm9kZSddKG5vZGUsIGN1cnJlbnRTY29wZU5hbWUpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdTY29wZU5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBvbGRTY29wZU5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJlcGxhY2VTaGFkeVNjb3Bpbmcobm9kZSwgbmV3U2NvcGVOYW1lLCBvbGRTY29wZU5hbWUpIHtcbiAgY29uc3Qgc2NvcGluZ1NoaW0gPSBnZXRTY29waW5nU2hpbSgpO1xuICBpZiAoIXNjb3BpbmdTaGltKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChvbGRTY29wZU5hbWUpIHtcbiAgICByZW1vdmVTaGFkeVNjb3Bpbmcobm9kZSwgb2xkU2NvcGVOYW1lKTtcbiAgfVxuICBhZGRTaGFkeVNjb3Bpbmcobm9kZSwgbmV3U2NvcGVOYW1lKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3U2NvcGVOYW1lXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gY3VycmVudFNjb3BlSXNDb3JyZWN0KG5vZGUsIG5ld1Njb3BlTmFtZSkge1xuICBjb25zdCBzY29waW5nU2hpbSA9IGdldFNjb3BpbmdTaGltKCk7XG4gIGlmICghc2NvcGluZ1NoaW0pIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFKSB7XG4gICAgLy8gTk9URTogYXMgYW4gb3B0aW1pemF0aW9uLCBvbmx5IGNoZWNrIHRoYXQgYWxsIHRoZSB0b3AtbGV2ZWwgY2hpbGRyZW5cbiAgICAvLyBoYXZlIHRoZSBjb3JyZWN0IHNjb3BlLlxuICAgIGxldCBjb3JyZWN0U2NvcGUgPSB0cnVlO1xuICAgIGZvciAobGV0IG49bm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkge1xuICAgICAgY29ycmVjdFNjb3BlID0gY29ycmVjdFNjb3BlICYmXG4gICAgICAgIGN1cnJlbnRTY29wZUlzQ29ycmVjdChuLCBuZXdTY29wZU5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gY29ycmVjdFNjb3BlO1xuICB9XG4gIGlmIChub2RlLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IGN1cnJlbnRTY29wZSA9IHNjb3BpbmdTaGltWydjdXJyZW50U2NvcGVGb3JOb2RlJ10obm9kZSk7XG4gIHJldHVybiBjdXJyZW50U2NvcGUgPT09IG5ld1Njb3BlTmFtZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjdXJyZW50U2NvcGVGb3JOb2RlKG5vZGUpIHtcbiAgaWYgKG5vZGUubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGNvbnN0IHNjb3BpbmdTaGltID0gZ2V0U2NvcGluZ1NoaW0oKTtcbiAgaWYgKCFzY29waW5nU2hpbSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICByZXR1cm4gc2NvcGluZ1NoaW1bJ2N1cnJlbnRTY29wZUZvck5vZGUnXShub2RlKTtcbn1cblxuLyoqXG4gKiBXYWxrIG92ZXIgYSBub2RlJ3MgdHJlZSBhbmQgYXBwbHkgdmlzaXRvckZuIHRvIGVhY2ggZWxlbWVudCBub2RlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCFOb2RlKTp2b2lkfSB2aXNpdG9yRm5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyZWVWaXNpdG9yKG5vZGUsIHZpc2l0b3JGbikge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGhpcyBjaGVjayBpcyBuZWNlc3NhcnkgaWYgYG5vZGVgIGlzIGEgRG9jdW1lbnQgRnJhZ21lbnRcbiAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgdmlzaXRvckZuKG5vZGUpO1xuICB9XG4gIGZvciAobGV0IG4gPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IChuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXSkpIHtcbiAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHRyZWVWaXNpdG9yKG4sIHZpc2l0b3JGbik7XG4gICAgfVxuICB9XG59IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtnZXRTY29waW5nU2hpbSwgcmVtb3ZlU2hhZHlTY29waW5nLCByZXBsYWNlU2hhZHlTY29waW5nLFxuICB0cmVlVmlzaXRvciwgY3VycmVudFNjb3BlRm9yTm9kZSwgY3VycmVudFNjb3BlSXNDb3JyZWN0IH0gZnJvbSAnLi4vc3R5bGUtc2NvcGluZy5qcyc7XG5pbXBvcnQge3NoYWR5RGF0YUZvck5vZGUsIGVuc3VyZVNoYWR5RGF0YUZvck5vZGV9IGZyb20gJy4uL3NoYWR5LWRhdGEuanMnO1xuaW1wb3J0IHtyZWNvcmRJbnNlcnRCZWZvcmUsIHJlY29yZFJlbW92ZUNoaWxkfSBmcm9tICcuLi9saW5rLW5vZGVzLmpzJztcbmltcG9ydCB7b3duZXJTaGFkeVJvb3RGb3JOb2RlfSBmcm9tICcuLi9hdHRhY2gtc2hhZG93LmpzJztcblxuY29uc3QgZG9jID0gd2luZG93LmRvY3VtZW50O1xuXG5jb25zdCBwcmVmZXJQZXJmb3JtYW5jZSA9IHV0aWxzLnNldHRpbmdzLnByZWZlclBlcmZvcm1hbmNlO1xuXG5jb25zdCBuYXRpdmVJc0Nvbm5lY3RlZEFjY2Vzc29ycyA9XG4vKiogQHR5cGUge09iamVjdFByb3BlcnR5RGVzY3JpcHRvcn0gKi8oXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoTm9kZS5wcm90b3R5cGUsICdpc0Nvbm5lY3RlZCcpXG4pO1xuXG5jb25zdCBuYXRpdmVJc0Nvbm5lY3RlZCA9IG5hdGl2ZUlzQ29ubmVjdGVkQWNjZXNzb3JzICYmIG5hdGl2ZUlzQ29ubmVjdGVkQWNjZXNzb3JzLmdldDtcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyTm9kZShub2RlKSB7XG4gIGxldCBmaXJzdENoaWxkO1xuICB3aGlsZSAoKGZpcnN0Q2hpbGQgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ10pKSB7XG4gICAgbm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlQ2hpbGQnXShmaXJzdENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW1vdmVPd25lclNoYWR5Um9vdChub2RlKSB7XG4gIC8vIG9wdGltaXphdGlvbjogb25seSByZXNldCB0aGUgdHJlZSBpZiBub2RlIGlzIGFjdHVhbGx5IGluIGEgcm9vdFxuICBpZiAoaGFzQ2FjaGVkT3duZXJSb290KG5vZGUpKSB7XG4gICAgZm9yIChsZXQgbj1ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICByZW1vdmVPd25lclNoYWR5Um9vdChuKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKG5vZGUpO1xuICBpZiAobm9kZURhdGEpIHtcbiAgICBub2RlRGF0YS5vd25lclNoYWR5Um9vdCA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNDYWNoZWRPd25lclJvb3Qobm9kZSkge1xuICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gIHJldHVybiBCb29sZWFuKG5vZGVEYXRhICYmIG5vZGVEYXRhLm93bmVyU2hhZHlSb290ICE9PSB1bmRlZmluZWQpO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBmaXJzdCBmbGF0dGVuZWQgbm9kZSB0aGF0IGlzIGNvbXBvc2VkIGluIHRoZSBub2RlJ3MgcGFyZW50LlxuICogSWYgdGhlIGdpdmVuIG5vZGUgaXMgYSBzbG90LCB0aGVuIHRoZSBmaXJzdCBmbGF0dGVuZWQgbm9kZSBpcyByZXR1cm5lZFxuICogaWYgaXQgZXhpc3RzLCBvdGhlcndpc2UgYWR2YW5jZSB0byB0aGUgbm9kZSdzIG5leHRTaWJsaW5nLlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHdpdGhpbiB3aGljaCB0byBmaW5kIGZpcnN0IGNvbXBvc2VkIG5vZGVcbiAqIEByZXR1cm5zIHtOb2RlfSBmaXJzdCBjb21wb3NlZCBub2RlXG4gKi9cbmZ1bmN0aW9uIGZpcnN0Q29tcG9zZWROb2RlKG5vZGUpIHtcbiAgbGV0IGNvbXBvc2VkID0gbm9kZTtcbiAgaWYgKG5vZGUgJiYgbm9kZS5sb2NhbE5hbWUgPT09ICdzbG90Jykge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgICBjb25zdCBmbGF0dGVuZWQgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5mbGF0dGVuZWROb2RlcztcbiAgICBjb21wb3NlZCA9IGZsYXR0ZW5lZCAmJiBmbGF0dGVuZWQubGVuZ3RoID8gZmxhdHRlbmVkWzBdIDpcbiAgICAgIGZpcnN0Q29tcG9zZWROb2RlKG5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pO1xuICB9XG4gIHJldHVybiBjb21wb3NlZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7Tm9kZT19IGFkZGVkTm9kZVxuICogQHBhcmFtIHtOb2RlPX0gcmVtb3ZlZE5vZGVcbiAqL1xuZnVuY3Rpb24gc2NoZWR1bGVPYnNlcnZlcihub2RlLCBhZGRlZE5vZGUsIHJlbW92ZWROb2RlKSB7XG4gIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZShub2RlKTtcbiAgY29uc3Qgb2JzZXJ2ZXIgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5vYnNlcnZlcjtcbiAgaWYgKG9ic2VydmVyKSB7XG4gICAgaWYgKGFkZGVkTm9kZSkge1xuICAgICAgb2JzZXJ2ZXIuYWRkZWROb2Rlcy5wdXNoKGFkZGVkTm9kZSk7XG4gICAgfVxuICAgIGlmIChyZW1vdmVkTm9kZSkge1xuICAgICAgb2JzZXJ2ZXIucmVtb3ZlZE5vZGVzLnB1c2gocmVtb3ZlZE5vZGUpO1xuICAgIH1cbiAgICBvYnNlcnZlci5zY2hlZHVsZSgpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBOb2RlUGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHBhcmVudE5vZGUoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGNvbnN0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5wYXJlbnROb2RlO1xuICAgIHJldHVybiBsICE9PSB1bmRlZmluZWQgPyBsIDogdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBmaXJzdENoaWxkKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBjb25zdCBsID0gbm9kZURhdGEgJiYgbm9kZURhdGEuZmlyc3RDaGlsZDtcbiAgICByZXR1cm4gbCAhPT0gdW5kZWZpbmVkID8gbCA6IHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgbGFzdENoaWxkKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBjb25zdCBsID0gbm9kZURhdGEgJiYgbm9kZURhdGEubGFzdENoaWxkO1xuICAgIHJldHVybiBsICE9PSB1bmRlZmluZWQgPyBsIDogdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IG5leHRTaWJsaW5nKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBjb25zdCBsID0gbm9kZURhdGEgJiYgbm9kZURhdGEubmV4dFNpYmxpbmc7XG4gICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBwcmV2aW91c1NpYmxpbmcoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGNvbnN0IGwgPSBub2RlRGF0YSAmJiBub2RlRGF0YS5wcmV2aW91c1NpYmxpbmc7XG4gICAgcmV0dXJuIGwgIT09IHVuZGVmaW5lZCA/IGwgOiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncHJldmlvdXNTaWJsaW5nJ107XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgY2hpbGROb2RlcygpIHtcbiAgICBsZXQgY2hpbGROb2RlcztcbiAgICBpZiAodXRpbHMuaXNUcmFja2luZ0xvZ2ljYWxDaGlsZE5vZGVzKHRoaXMpKSB7XG4gICAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgICBpZiAoIW5vZGVEYXRhLmNoaWxkTm9kZXMpIHtcbiAgICAgICAgbm9kZURhdGEuY2hpbGROb2RlcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBuPXRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbj1uW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICAgICAgbm9kZURhdGEuY2hpbGROb2Rlcy5wdXNoKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjaGlsZE5vZGVzID0gbm9kZURhdGEuY2hpbGROb2RlcztcbiAgICB9IGVsc2Uge1xuICAgICAgY2hpbGROb2RlcyA9IHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdjaGlsZE5vZGVzJ107XG4gICAgfVxuICAgIGNoaWxkTm9kZXMuaXRlbSA9IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICByZXR1cm4gY2hpbGROb2Rlc1tpbmRleF07XG4gICAgfVxuICAgIHJldHVybiBjaGlsZE5vZGVzO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IHBhcmVudEVsZW1lbnQoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGxldCBsID0gbm9kZURhdGEgJiYgbm9kZURhdGEucGFyZW50Tm9kZTtcbiAgICBpZiAobCAmJiBsLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgbCA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBsICE9PSB1bmRlZmluZWQgPyBsIDogdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3BhcmVudEVsZW1lbnQnXTtcbiAgfSxcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGdldCBpc0Nvbm5lY3RlZCgpIHtcbiAgICBpZiAobmF0aXZlSXNDb25uZWN0ZWQgJiYgbmF0aXZlSXNDb25uZWN0ZWQuY2FsbCh0aGlzKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLm5vZGVUeXBlID09IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGYXN0IHBhdGggZm9yIGRpc3RyaWJ1dGVkIG5vZGVzLlxuICAgIGNvbnN0IG93bmVyRG9jdW1lbnQgPSB0aGlzLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHV0aWxzLmhhc0RvY3VtZW50Q29udGFpbnMpIHtcbiAgICAgIGlmIChvd25lckRvY3VtZW50W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY29udGFpbnMnXSh0aGlzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXG4gICAgICBvd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2NvbnRhaW5zJ10odGhpcykpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBTbG93IHBhdGggZm9yIG5vbi1kaXN0cmlidXRlZCBub2Rlcy5cbiAgICBsZXQgbm9kZSA9IHRoaXM7XG4gICAgd2hpbGUgKG5vZGUgJiYgIShub2RlIGluc3RhbmNlb2YgRG9jdW1lbnQpKSB7XG4gICAgICBub2RlID0gbm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddIHx8ICh1dGlscy5pc1NoYWR5Um9vdChub2RlKSA/IC8qKiBAdHlwZSB7U2hhZG93Um9vdH0gKi8obm9kZSkuaG9zdCA6IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiAhIShub2RlICYmIG5vZGUgaW5zdGFuY2VvZiBEb2N1bWVudCk7XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtOb2RlfSAqL1xuICBnZXQgdGV4dENvbnRlbnQoKSB7XG4gICAgaWYgKHV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSkge1xuICAgICAgbGV0IHRjID0gW107XG4gICAgICBmb3IgKGxldCBuPXRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgaWYgKG4ubm9kZVR5cGUgIT09IE5vZGUuQ09NTUVOVF9OT0RFKSB7XG4gICAgICAgICAgdGMucHVzaChuW3V0aWxzLlNIQURZX1BSRUZJWCArICd0ZXh0Q29udGVudCddKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRjLmpvaW4oJycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ3RleHRDb250ZW50J107XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Tm9kZX1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXQgdGV4dENvbnRlbnQodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSAnJ1xuICAgIH1cbiAgICBzd2l0Y2ggKHRoaXMubm9kZVR5cGUpIHtcbiAgICAgIGNhc2UgTm9kZS5FTEVNRU5UX05PREU6XG4gICAgICBjYXNlIE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERTpcbiAgICAgICAgaWYgKCF1dGlscy5pc1RyYWNraW5nTG9naWNhbENoaWxkTm9kZXModGhpcykgJiYgdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgICAvLyBtYXkgYmUgcmVtb3ZpbmcgYSBuZXN0ZWQgc2xvdCBidXQgZmFzdCBwYXRoIGlmIHdlIGtub3cgd2UgYXJlIG5vdC5cbiAgICAgICAgICBjb25zdCBmaXJzdENoaWxkID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddO1xuICAgICAgICAgIGlmIChmaXJzdENoaWxkICE9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RDaGlsZCddIHx8XG4gICAgICAgICAgICAoZmlyc3RDaGlsZCAmJiBmaXJzdENoaWxkLm5vZGVUeXBlICE9IE5vZGUuVEVYVF9OT0RFKSkge1xuICAgICAgICAgICAgY2xlYXJOb2RlKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAndGV4dENvbnRlbnQnXSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsZWFyTm9kZSh0aGlzKTtcbiAgICAgICAgICAvLyBEb2N1bWVudCBmcmFnbWVudHMgbXVzdCBoYXZlIG5vIGNoaWxkTm9kZXMgaWYgc2V0dGluZyBhIGJsYW5rIHN0cmluZ1xuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAwIHx8IHRoaXMubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWx1ZSkpXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gTm90ZSwgYmUgd2FyeSBvZiBwYXRjaGluZyBgbm9kZVZhbHVlYC5cbiAgICAgICAgdGhpcy5ub2RlVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9LFxuXG4gIC8vIFBhdGNoZWQgYGluc2VydEJlZm9yZWAuIE5vdGUgdGhhdCBhbGwgbXV0YXRpb25zIHRoYXQgYWRkIG5vZGVzIGFyZSByb3V0ZWRcbiAgLy8gaGVyZS4gV2hlbiBhIDxzbG90PiBpcyBhZGRlZCBvciBhIG5vZGUgaXMgYWRkZWQgdG8gYSBob3N0IHdpdGggYSBzaGFkb3dSb290XG4gIC8vIHdpdGggYSBzbG90LCBhIHN0YW5kYXJkIGRvbSBgaW5zZXJ0YCBjYWxsIGlzIGFib3J0ZWQgYW5kIGBfYXN5bmNSZW5kZXJgXG4gIC8vIGlzIGNhbGxlZCBvbiB0aGUgcmVsZXZhbnQgc2hhZG93Um9vdC4gSW4gYWxsIG90aGVyIGNhc2VzLCBhIHN0YW5kYXJkIGRvbVxuICAvLyBgaW5zZXJ0YCBjYW4gYmUgbWFkZSwgYnV0IHRoZSBsb2NhdGlvbiBhbmQgcmVmX25vZGUgbWF5IG5lZWQgdG8gYmUgY2hhbmdlZC5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtOb2RlPX0gcmVmX25vZGVcbiAgICovXG4gIGluc2VydEJlZm9yZShub2RlLCByZWZfbm9kZSkge1xuICAgIC8vIG9wdGltaXphdGlvbjogYXNzdW1lIG5hdGl2ZSBpbnNlcnRCZWZvcmUgaXMgb2sgaWYgdGhlIG5vZGVzIGFyZSBub3QgaW4gdGhlIGRvY3VtZW50LlxuICAgIGlmICh0aGlzLm93bmVyRG9jdW1lbnQgIT09IGRvYyAmJiBub2RlLm93bmVyRG9jdW1lbnQgIT09IGRvYykge1xuICAgICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKG5vZGUsIHJlZl9ub2RlKTtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBpZiAobm9kZSA9PT0gdGhpcykge1xuICAgICAgdGhyb3cgRXJyb3IoYEZhaWxlZCB0byBleGVjdXRlICdhcHBlbmRDaGlsZCcgb24gJ05vZGUnOiBUaGUgbmV3IGNoaWxkIGVsZW1lbnQgY29udGFpbnMgdGhlIHBhcmVudC5gKTtcbiAgICB9XG4gICAgaWYgKHJlZl9ub2RlKSB7XG4gICAgICBjb25zdCByZWZEYXRhID0gc2hhZHlEYXRhRm9yTm9kZShyZWZfbm9kZSk7XG4gICAgICBjb25zdCBwID0gcmVmRGF0YSAmJiByZWZEYXRhLnBhcmVudE5vZGU7XG4gICAgICBpZiAoKHAgIT09IHVuZGVmaW5lZCAmJiBwICE9PSB0aGlzKSB8fFxuICAgICAgICAocCA9PT0gdW5kZWZpbmVkICYmIHJlZl9ub2RlW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddICE9PSB0aGlzKSkge1xuICAgICAgICB0aHJvdyBFcnJvcihgRmFpbGVkIHRvIGV4ZWN1dGUgJ2luc2VydEJlZm9yZScgb24gJ05vZGUnOiBUaGUgbm9kZSBgICtcbiAgICAgICAgYGJlZm9yZSB3aGljaCB0aGUgbmV3IG5vZGUgaXMgdG8gYmUgaW5zZXJ0ZWQgaXMgbm90IGEgY2hpbGQgb2YgdGhpcyBub2RlLmApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVmX25vZGUgPT09IG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICAvKiogQHR5cGUgeyFBcnJheTwhSFRNTFNsb3RFbGVtZW50Pn0gKi9cbiAgICBjb25zdCBzbG90c0FkZGVkID0gW107XG4gICAgY29uc3Qgb3duZXJSb290ID0gb3duZXJTaGFkeVJvb3RGb3JOb2RlKHRoaXMpO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIGNvbnN0IG5ld1Njb3BlTmFtZSA9IG93bmVyUm9vdCA/IG93bmVyUm9vdC5ob3N0LmxvY2FsTmFtZSA6IGN1cnJlbnRTY29wZUZvck5vZGUodGhpcyk7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgbGV0IG9sZFNjb3BlTmFtZTtcbiAgICAvLyByZW1vdmUgZnJvbSBleGlzdGluZyBsb2NhdGlvblxuICAgIGNvbnN0IHBhcmVudE5vZGUgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgaWYgKHBhcmVudE5vZGUpIHtcbiAgICAgIG9sZFNjb3BlTmFtZSA9IGN1cnJlbnRTY29wZUZvck5vZGUobm9kZSk7XG4gICAgICBjb25zdCBza2lwVW5zY29waW5nID1cbiAgICAgICAgLy8gRG9uJ3QgcmVtb3ZlIHNjb3BpbmcgaWYgd2UncmUgaW5zZXJ0aW5nIGludG8gYW5vdGhlciBzaGFkb3dSb290O1xuICAgICAgICAvLyB0aGlzIHdvdWxkIGJlIHVubmVjZXNzYXJ5IHNpbmNlIGl0IHdpbGwgYmUgcmUtc2NvcGVkIGJlbG93XG4gICAgICAgIEJvb2xlYW4ob3duZXJSb290KSB8fFxuICAgICAgICAvLyBEb24ndCByZW1vdmUgc2NvcGluZyBpZiB3ZSdyZSBiZWluZyBtb3ZlZCBiZXR3ZWVuIG5vbi1zaGFkb3dSb290XG4gICAgICAgIC8vIGxvY2F0aW9ucyAodGhlIGxpa2VseSBjYXNlIGlzIHdoZW4gbW92aW5nIHByZS1zY29wZWQgbm9kZXMgaW4gYSB0ZW1wbGF0ZSlcbiAgICAgICAgIW93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKSB8fFxuICAgICAgICAvLyBVbmRlciBwcmVmZXJQZXJmb3JtYW5jZSwgZG9uJ3QgcmVtb3ZlIHNjb3Bpbmcgd2hlbiBtb3ZpbmcgYmFjayBpbnRvXG4gICAgICAgIC8vIGEgZG9jdW1lbnQgZnJhZ21lbnQgdGhhdCB3YXMgcHJldmlvdXNseSBzY29wZWQ7IHRoZSBhc3N1bXB0aW9uIGlzXG4gICAgICAgIC8vIHRoYXQgdGhlIHVzZXIgc2hvdWxkIG9ubHkgbW92ZSBjb3JyZWN0bHktc2NvcGVkIERPTSBiYWNrIGludG8gaXRcbiAgICAgICAgKHByZWZlclBlcmZvcm1hbmNlICYmIHRoaXNbJ19fbm9JbnNlcnRpb25Qb2ludCddICE9PSB1bmRlZmluZWQpO1xuICAgICAgcGFyZW50Tm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlQ2hpbGQnXShub2RlLCBza2lwVW5zY29waW5nKTtcbiAgICB9XG4gICAgLy8gYWRkIHRvIG5ldyBwYXJlbnRcbiAgICBsZXQgYWxsb3dOYXRpdmVJbnNlcnQgPSB0cnVlO1xuICAgIGNvbnN0IG5lZWRzU2NvcGluZyA9ICghcHJlZmVyUGVyZm9ybWFuY2UgfHxcbiAgICAgICAgLy8gVW5kZXIgcHJlZmVyUGVyZm9ybWFuY2UsIG9ubHkgcmUtc2NvcGUgaWYgd2UncmUgbm90IGNvbWluZyBmcm9tIGFcbiAgICAgICAgLy8gcHJlLXNjb3BlZCBkb2MgZnJhZ21lbnQgb3IgYmFjayBpbnRvIGEgcHJlLXNjb3BlZCBkb2MgZnJhZ21lbnRcbiAgICAgICAgKG5vZGVbJ19fbm9JbnNlcnRpb25Qb2ludCddID09PSB1bmRlZmluZWQgJiZcbiAgICAgICAgIHRoaXNbJ19fbm9JbnNlcnRpb25Qb2ludCddID09PSB1bmRlZmluZWQpKSAmJlxuICAgICAgICAhY3VycmVudFNjb3BlSXNDb3JyZWN0KG5vZGUsIG5ld1Njb3BlTmFtZSk7XG4gICAgY29uc3QgbmVlZHNTbG90RmluZGluZyA9IG93bmVyUm9vdCAmJiAhbm9kZVsnX19ub0luc2VydGlvblBvaW50J10gJiZcbiAgICAgICAgKCFwcmVmZXJQZXJmb3JtYW5jZSB8fCBub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX0ZSQUdNRU5UX05PREUpO1xuICAgIGlmIChuZWVkc1Nsb3RGaW5kaW5nIHx8IG5lZWRzU2NvcGluZykge1xuICAgICAgLy8gTk9URTogYXZvaWQgbm9kZS5yZW1vdmVDaGlsZCBhcyB0aGlzICpjYW4qIHRyaWdnZXIgYW5vdGhlciBwYXRjaGVkXG4gICAgICAvLyBtZXRob2QgKGUuZy4gY3VzdG9tIGVsZW1lbnRzKSBhbmQgd2Ugd2FudCBvbmx5IHRoZSBzaGFkeSBtZXRob2QgdG8gcnVuLlxuICAgICAgLy8gVGhlIGZvbGxvd2luZyB0YWJsZSBkZXNjcmliZXMgd2hhdCBzdHlsZSBzY29waW5nIGFjdGlvbnMgc2hvdWxkIGhhcHBlbiBhcyBhIHJlc3VsdCBvZiB0aGlzIGluc2VydGlvbi5cbiAgICAgIC8vIGRvY3VtZW50IC0+IHNoYWRvd1Jvb3Q6IHJlcGxhY2VcbiAgICAgIC8vIHNoYWRvd1Jvb3QgLT4gc2hhZG93Um9vdDogcmVwbGFjZVxuICAgICAgLy8gc2hhZG93Um9vdCAtPiBzaGFkb3dSb290IG9mIHNhbWUgdHlwZTogZG8gbm90aGluZ1xuICAgICAgLy8gc2hhZG93Um9vdCAtPiBkb2N1bWVudDogYWxsb3cgdW5zY29waW5nXG4gICAgICAvLyBkb2N1bWVudCAtPiBkb2N1bWVudDogZG8gbm90aGluZ1xuICAgICAgLy8gVGhlIFwic2FtZSB0eXBlIG9mIHNoYWRvd1Jvb3RcIiBhbmQgXCJkb2N1bWVudCB0byBkb2N1bWVudCBjYXNlcyByZWx5IG9uIGBjdXJyZW50U2NvcGVJc0NvcnJlY3RgIHJldHVybmluZyB0cnVlXG4gICAgICBpZiAobmVlZHNTY29waW5nKSB7XG4gICAgICAgIC8vIGluIGEgZG9jdW1lbnQgb3IgZGlzY29ubmVjdGVkIHRyZWUsIHJlcGxhY2Ugc2NvcGluZyBpZiBuZWNlc3NhcnlcbiAgICAgICAgb2xkU2NvcGVOYW1lID0gb2xkU2NvcGVOYW1lIHx8IGN1cnJlbnRTY29wZUZvck5vZGUobm9kZSk7XG4gICAgICB9XG4gICAgICB0cmVlVmlzaXRvcihub2RlLCAobm9kZSkgPT4ge1xuICAgICAgICBpZiAobmVlZHNTbG90RmluZGluZyAmJiBub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICAgICAgc2xvdHNBZGRlZC5wdXNoKC8qKiBAdHlwZSB7IUhUTUxTbG90RWxlbWVudH0gKi8obm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1Njb3BpbmcpIHtcbiAgICAgICAgICByZXBsYWNlU2hhZHlTY29waW5nKG5vZGUsIG5ld1Njb3BlTmFtZSwgb2xkU2NvcGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGlmIGEgc2xvdCBpcyBhZGRlZCwgbXVzdCByZW5kZXIgY29udGFpbmluZyByb290LlxuICAgIGlmIChzbG90c0FkZGVkLmxlbmd0aCkge1xuICAgICAgb3duZXJSb290Ll9hZGRTbG90cyhzbG90c0FkZGVkKTtcbiAgICAgIG93bmVyUm9vdC5fYXN5bmNSZW5kZXIoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSkge1xuICAgICAgcmVjb3JkSW5zZXJ0QmVmb3JlKG5vZGUsIHRoaXMsIHJlZl9ub2RlKTtcbiAgICAgIC8vIHdoZW4gaW5zZXJ0aW5nIGludG8gYSBob3N0IHdpdGggYSBzaGFkb3dSb290IHdpdGggc2xvdCwgdXNlXG4gICAgICAvLyBgc2hhZG93Um9vdC5fYXN5bmNSZW5kZXIoKWAgdmlhIGBhdHRhY2gtc2hhZG93YCBtb2R1bGVcbiAgICAgIGNvbnN0IHBhcmVudERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgICAgaWYgKHV0aWxzLmhhc1NoYWRvd1Jvb3RXaXRoU2xvdCh0aGlzKSkge1xuICAgICAgICBwYXJlbnREYXRhLnJvb3QuX2FzeW5jUmVuZGVyKCk7XG4gICAgICAgIGFsbG93TmF0aXZlSW5zZXJ0ID0gZmFsc2U7XG4gICAgICAvLyB3aGVuIGluc2VydGluZyBpbnRvIGEgaG9zdCB3aXRoIHNoYWRvd1Jvb3Qgd2l0aCBOTyBzbG90LCBkbyBub3RoaW5nXG4gICAgICAvLyBhcyB0aGUgbm9kZSBzaG91bGQgbm90IGJlIGFkZGVkIHRvIGNvbXBvc2VkIGRvbWUgYW55d2hlcmUuXG4gICAgICB9IGVsc2UgaWYgKHBhcmVudERhdGEucm9vdCkge1xuICAgICAgICBhbGxvd05hdGl2ZUluc2VydCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsb3dOYXRpdmVJbnNlcnQpIHtcbiAgICAgIC8vIGlmIGFkZGluZyB0byBhIHNoYWR5Um9vdCwgYWRkIHRvIGhvc3QgaW5zdGVhZFxuICAgICAgbGV0IGNvbnRhaW5lciA9IHV0aWxzLmlzU2hhZHlSb290KHRoaXMpID9cbiAgICAgICAgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyh0aGlzKS5ob3N0IDogdGhpcztcbiAgICAgIC8vIGlmIHJlZl9ub2RlLCBnZXQgdGhlIHJlZl9ub2RlIHRoYXQncyBhY3R1YWxseSBpbiBjb21wb3NlZCBkb20uXG4gICAgICBpZiAocmVmX25vZGUpIHtcbiAgICAgICAgcmVmX25vZGUgPSBmaXJzdENvbXBvc2VkTm9kZShyZWZfbm9kZSk7XG4gICAgICAgIGNvbnRhaW5lclt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKG5vZGUsIHJlZl9ub2RlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lclt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2FwcGVuZENoaWxkJ10obm9kZSk7XG4gICAgICB9XG4gICAgLy8gU2luY2Ugb3duZXJEb2N1bWVudCBpcyBub3QgcGF0Y2hlZCwgaXQgY2FuIGJlIGluY29ycmVjdCBhZnRlciB0aGlzIGNhbGxcbiAgICAvLyBpZiB0aGUgbm9kZSBpcyBwaHlzaWNhbGx5IGFwcGVuZGVkIHZpYSBkaXN0cmlidXRpb24uIFRoaXMgY2FuIHJlc3VsdFxuICAgIC8vIGluIHRoZSBjdXN0b20gZWxlbWVudHMgcG9seWZpbGwgbm90IHVwZ3JhZGluZyB0aGUgbm9kZSBpZiBpdCdzIGluIGFuIGluZXJ0IGRvYy5cbiAgICAvLyBXZSBjb3JyZWN0IHRoaXMgYnkgY2FsbGluZyBgYWRvcHROb2RlYC5cbiAgICB9IGVsc2UgaWYgKG5vZGUub3duZXJEb2N1bWVudCAhPT0gdGhpcy5vd25lckRvY3VtZW50KSB7XG4gICAgICB0aGlzLm93bmVyRG9jdW1lbnQuYWRvcHROb2RlKG5vZGUpO1xuICAgIH1cbiAgICBzY2hlZHVsZU9ic2VydmVyKHRoaXMsIG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Tm9kZX1cbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqL1xuICBhcHBlbmRDaGlsZChub2RlKSB7XG4gICAgLy8gaWYgdGhpcyBpcyBhIHNoYWRvd1Jvb3QgYW5kIHRoZSBzaGFkb3dSb290IGlzIHBhc3NlZCBhcyBgbm9kZWBcbiAgICAvLyB0aGVuIGFuIG9wdGltaXplZCBhcHBlbmQgaGFzIGFscmVhZHkgYmVlbiBwZXJmb3JtZWQsIHNvIGRvIG5vdGhpbmcuXG4gICAgaWYgKCEodGhpcyA9PSBub2RlICYmIHV0aWxzLmlzU2hhZHlSb290KG5vZGUpKSkge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKG5vZGUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGF0Y2hlZCBgcmVtb3ZlQ2hpbGRgLiBOb3RlIHRoYXQgYWxsIGRvbSBcInJlbW92YWxzXCIgYXJlIHJvdXRlZCBoZXJlLlxuICAgKiBSZW1vdmVzIHRoZSBnaXZlbiBgbm9kZWAgZnJvbSB0aGUgZWxlbWVudCdzIGBjaGlsZHJlbmAuXG4gICAqIFRoaXMgbWV0aG9kIGFsc28gcGVyZm9ybXMgZG9tIGNvbXBvc2l0aW9uLlxuICAgKiBAdGhpcyB7Tm9kZX1cbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNraXBVbnNjb3BpbmdcbiAgICovXG4gIHJlbW92ZUNoaWxkKG5vZGUsIHNraXBVbnNjb3BpbmcgPSBmYWxzZSkge1xuICAgIGlmICh0aGlzLm93bmVyRG9jdW1lbnQgIT09IGRvYykge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG5vZGUpO1xuICAgIH1cbiAgICBpZiAobm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddICE9PSB0aGlzKSB7XG4gICAgICB0aHJvdyBFcnJvcignVGhlIG5vZGUgdG8gYmUgcmVtb3ZlZCBpcyBub3QgYSBjaGlsZCBvZiB0aGlzIG5vZGU6ICcgK1xuICAgICAgICBub2RlKTtcbiAgICB9XG4gICAgbGV0IHByZXZlbnROYXRpdmVSZW1vdmU7XG4gICAgbGV0IG93bmVyUm9vdCA9IG93bmVyU2hhZHlSb290Rm9yTm9kZShub2RlKTtcbiAgICBjb25zdCByZW1vdmluZ0luc2VydGlvblBvaW50ID0gb3duZXJSb290ICYmIG93bmVyUm9vdC5fcmVtb3ZlQ29udGFpbmVkU2xvdHMobm9kZSk7XG4gICAgY29uc3QgcGFyZW50RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgaWYgKHV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSkge1xuICAgICAgcmVjb3JkUmVtb3ZlQ2hpbGQobm9kZSwgdGhpcyk7XG4gICAgICBpZiAodXRpbHMuaGFzU2hhZG93Um9vdFdpdGhTbG90KHRoaXMpKSB7XG4gICAgICAgIHBhcmVudERhdGEucm9vdC5fYXN5bmNSZW5kZXIoKTtcbiAgICAgICAgcHJldmVudE5hdGl2ZVJlbW92ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVuc2NvcGUgYSBub2RlIGxlYXZpbmcgYSBTaGFkb3dSb290IGlmIFNoYWR5Q1NTIGlzIHByZXNlbnQsIGFuZCB0aGlzIG5vZGVcbiAgICAvLyBpcyBub3QgZ29pbmcgdG8gYmUgcmVzY29wZWQgaW4gYGluc2VydEJlZm9yZWBcbiAgICBpZiAoZ2V0U2NvcGluZ1NoaW0oKSAmJiAhc2tpcFVuc2NvcGluZyAmJiBvd25lclJvb3RcbiAgICAgICYmIG5vZGUubm9kZVR5cGUgIT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICBjb25zdCBvbGRTY29wZU5hbWUgPSBjdXJyZW50U2NvcGVGb3JOb2RlKG5vZGUpO1xuICAgICAgdHJlZVZpc2l0b3Iobm9kZSwgKG5vZGUpID0+IHtcbiAgICAgICAgcmVtb3ZlU2hhZHlTY29waW5nKG5vZGUsIG9sZFNjb3BlTmFtZSk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlT3duZXJTaGFkeVJvb3Qobm9kZSk7XG4gICAgLy8gaWYgcmVtb3Zpbmcgc2xvdCwgbXVzdCByZW5kZXIgY29udGFpbmluZyByb290XG4gICAgaWYgKG93bmVyUm9vdCkge1xuICAgICAgbGV0IGNoYW5nZVNsb3RDb250ZW50ID0gdGhpcyAmJiB0aGlzLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnO1xuICAgICAgaWYgKGNoYW5nZVNsb3RDb250ZW50KSB7XG4gICAgICAgIHByZXZlbnROYXRpdmVSZW1vdmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlbW92aW5nSW5zZXJ0aW9uUG9pbnQgfHwgY2hhbmdlU2xvdENvbnRlbnQpIHtcbiAgICAgICAgb3duZXJSb290Ll9hc3luY1JlbmRlcigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXByZXZlbnROYXRpdmVSZW1vdmUpIHtcbiAgICAgIC8vIGlmIHJlbW92aW5nIGZyb20gYSBzaGFkeVJvb3QsIHJlbW92ZSBmcm9tIGhvc3QgaW5zdGVhZFxuICAgICAgbGV0IGNvbnRhaW5lciA9IHV0aWxzLmlzU2hhZHlSb290KHRoaXMpID9cbiAgICAgICAgLyoqIEB0eXBlIHtTaGFkb3dSb290fSAqLyh0aGlzKS5ob3N0IDpcbiAgICAgICAgdGhpcztcbiAgICAgIC8vIG5vdCBndWFyYW50ZWVkIHRvIHBoeXNpY2FsbHkgYmUgaW4gY29udGFpbmVyOyBlLmcuXG4gICAgICAvLyAoMSkgaWYgcGFyZW50IGhhcyBhIHNoYWR5Um9vdCwgZWxlbWVudCBtYXkgb3IgbWF5IG5vdCBhdCBkaXN0cmlidXRlZFxuICAgICAgLy8gbG9jYXRpb24gKGNvdWxkIGJlIHVuZGlzdHJpYnV0ZWQpXG4gICAgICAvLyAoMikgaWYgcGFyZW50IGlzIGEgc2xvdCwgZWxlbWVudCBtYXkgbm90IGJlbiBpbiBjb21wb3NlZCBkb21cbiAgICAgIGlmICghKHBhcmVudERhdGEucm9vdCB8fCBub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB8fFxuICAgICAgICAoY29udGFpbmVyID09PSBub2RlW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddKSkge1xuICAgICAgICBjb250YWluZXJbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBzY2hlZHVsZU9ic2VydmVyKHRoaXMsIG51bGwsIG5vZGUpO1xuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Tm9kZX1cbiAgICogQHBhcmFtIHtOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7Tm9kZT19IHJlZl9ub2RlXG4gICAqL1xuICByZXBsYWNlQ2hpbGQobm9kZSwgcmVmX25vZGUpIHtcbiAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbnNlcnRCZWZvcmUnXShub2RlLCByZWZfbm9kZSk7XG4gICAgdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlQ2hpbGQnXShyZWZfbm9kZSk7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtOb2RlfVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBkZWVwXG4gICAqL1xuICBjbG9uZU5vZGUoZGVlcCkge1xuICAgIGlmICh0aGlzLmxvY2FsTmFtZSA9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2Nsb25lTm9kZSddKGRlZXApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBuID0gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2Nsb25lTm9kZSddKGZhbHNlKTtcbiAgICAgIC8vIEF0dHJpYnV0ZSBub2RlcyBoaXN0b3JpY2FsbHkgaGFkIGNoaWxkTm9kZXMsIGJ1dCB0aGV5IGhhdmUgbGF0ZXJcbiAgICAgIC8vIGJlZW4gcmVtb3ZlZCBmcm9tIHRoZSBzcGVjLlxuICAgICAgLy8gTWFrZSBzdXJlIHdlIGRvIG5vdCBkbyBhIGRlZXAgY2xvbmUgb24gdGhlbSBmb3Igb2xkIGJyb3dzZXJzIChJRTExKVxuICAgICAgaWYgKGRlZXAgJiYgbi5ub2RlVHlwZSAhPT0gTm9kZS5BVFRSSUJVVEVfTk9ERSkge1xuICAgICAgICBmb3IgKGxldCBjPXRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXSwgbmM7IGM7IGMgPSBjW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICAgICAgbmMgPSBjW3V0aWxzLlNIQURZX1BSRUZJWCArICdjbG9uZU5vZGUnXSh0cnVlKTtcbiAgICAgICAgICBuW3V0aWxzLlNIQURZX1BSRUZJWCArICdhcHBlbmRDaGlsZCddKG5jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7Tm9kZX1cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqL1xuICAvLyBUT0RPKHNvcnZlbGwpOiBpbXBsZW1lbnQgYG9wdGlvbnNgIGUuZy4gYHsgY29tcG9zZWQ6IGJvb2xlYW4gfWBcbiAgZ2V0Um9vdE5vZGUob3B0aW9ucykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG4gICAgaWYgKCF0aGlzIHx8ICF0aGlzLm5vZGVUeXBlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5vZGVEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBsZXQgcm9vdCA9IG5vZGVEYXRhLm93bmVyU2hhZHlSb290O1xuICAgIGlmIChyb290ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh1dGlscy5pc1NoYWR5Um9vdCh0aGlzKSkge1xuICAgICAgICByb290ID0gdGhpcztcbiAgICAgICAgbm9kZURhdGEub3duZXJTaGFkeVJvb3QgPSByb290O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGV0IHBhcmVudCA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICAgICAgcm9vdCA9IHBhcmVudCA/IHBhcmVudFt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXShvcHRpb25zKSA6IHRoaXM7XG4gICAgICAgIC8vIG1lbW8taXplIHJlc3VsdCBmb3IgcGVyZm9ybWFuY2UgYnV0IG9ubHkgbWVtby1pemVcbiAgICAgICAgLy8gcmVzdWx0IGlmIG5vZGUgaXMgaW4gdGhlIGRvY3VtZW50LiBUaGlzIGF2b2lkcyBhIHByb2JsZW0gd2hlcmUgYSByb290XG4gICAgICAgIC8vIGNhbiBiZSBjYWNoZWQgd2hpbGUgYW4gZWxlbWVudCBpcyBpbnNpZGUgYSBmcmFnbWVudC5cbiAgICAgICAgLy8gSWYgdGhpcyBoYXBwZW5zIGFuZCB3ZSBjYWNoZSB0aGUgcmVzdWx0LCB0aGUgdmFsdWUgY2FuIGJlY29tZSBzdGFsZVxuICAgICAgICAvLyBiZWNhdXNlIGZvciBwZXJmIHdlIGF2b2lkIHByb2Nlc3NpbmcgdGhlIHN1YnRyZWUgb2YgYWRkZWQgZnJhZ21lbnRzLlxuICAgICAgICBpZiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnY29udGFpbnMnXSh0aGlzKSkge1xuICAgICAgICAgIG5vZGVEYXRhLm93bmVyU2hhZHlSb290ID0gcm9vdDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgfVxuICAgIHJldHVybiByb290O1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgY29udGFpbnMobm9kZSkge1xuICAgIHJldHVybiB1dGlscy5jb250YWlucyh0aGlzLCBub2RlKTtcbiAgfVxuXG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7c2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi4vc2hhZHktZGF0YS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtOb2RlfSBub2RlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBtYXRjaGVyXG4gKiBAcGFyYW0ge0Z1bmN0aW9uPX0gaGFsdGVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBxdWVyeShub2RlLCBtYXRjaGVyLCBoYWx0ZXIpIHtcbiAgbGV0IGxpc3QgPSBbXTtcbiAgcXVlcnlDaGlsZE5vZGVzKG5vZGUsIG1hdGNoZXIsXG4gICAgaGFsdGVyLCBsaXN0KTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbmZ1bmN0aW9uIHF1ZXJ5Q2hpbGROb2RlcyhwYXJlbnQsIG1hdGNoZXIsIGhhbHRlciwgbGlzdCkge1xuICBmb3IgKGxldCBuID0gcGFyZW50W3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgaWYgKG4ubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFICYmXG4gICAgICAgIHF1ZXJ5RWxlbWVudChuLCBtYXRjaGVyLCBoYWx0ZXIsIGxpc3QpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcXVlcnlFbGVtZW50KG5vZGUsIG1hdGNoZXIsIGhhbHRlciwgbGlzdCkge1xuICBsZXQgcmVzdWx0ID0gbWF0Y2hlcihub2RlKTtcbiAgaWYgKHJlc3VsdCkge1xuICAgIGxpc3QucHVzaChub2RlKTtcbiAgfVxuICBpZiAoaGFsdGVyICYmIGhhbHRlcihyZXN1bHQpKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBxdWVyeUNoaWxkTm9kZXMobm9kZSwgbWF0Y2hlcixcbiAgICBoYWx0ZXIsIGxpc3QpO1xufVxuXG4vLyBOZWVkZWQgb24gRWxlbWVudCwgRG9jdW1lbnRGcmFnbWVudCwgRG9jdW1lbnRcbmV4cG9ydCBjb25zdCBQYXJlbnROb2RlUGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IGZpcnN0RWxlbWVudENoaWxkKCkge1xuICAgIGNvbnN0IG5vZGVEYXRhID0gc2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICBpZiAobm9kZURhdGEgJiYgbm9kZURhdGEuZmlyc3RDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbiA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTtcbiAgICAgIHdoaWxlIChuICYmIG4ubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnZmlyc3RFbGVtZW50Q2hpbGQnXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgbGFzdEVsZW1lbnRDaGlsZCgpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgaWYgKG5vZGVEYXRhICYmIG5vZGVEYXRhLmxhc3RDaGlsZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbiA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2xhc3RDaGlsZCddO1xuICAgICAgd2hpbGUgKG4gJiYgbi5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzU2libGluZyddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnbGFzdEVsZW1lbnRDaGlsZCddO1xuICAgIH1cbiAgfSxcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICBpZiAoIXV0aWxzLmlzVHJhY2tpbmdMb2dpY2FsQ2hpbGROb2Rlcyh0aGlzKSkge1xuICAgICAgcmV0dXJuIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdjaGlsZHJlbiddO1xuICAgIH1cbiAgICByZXR1cm4gdXRpbHMuY3JlYXRlUG9seWZpbGxlZEhUTUxDb2xsZWN0aW9uKEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChcbiAgICAgICAgdXRpbHMuY2hpbGROb2Rlc0FycmF5KHRoaXMpLCAobikgPT4ge1xuICAgICAgcmV0dXJuIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSk7XG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgZ2V0IGNoaWxkRWxlbWVudENvdW50KCkge1xuICAgIGxldCBjaGlsZHJlbiA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkcmVuJ107XG4gICAgaWYoY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBjaGlsZHJlbi5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG5cbn0pO1xuXG5leHBvcnQgY29uc3QgUXVlcnlQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG4gIC8vIFRPRE8oc29ydmVsbCk6IGNvbnNpZGVyIGRvaW5nIG5hdGl2ZSBRU0EgYW5kIGZpbHRlcmluZyByZXN1bHRzLlxuICAvKipcbiAgICogQHRoaXMge0VsZW1lbnR9XG4gICAqIEBwYXJhbSAge3N0cmluZ30gc2VsZWN0b3JcbiAgICovXG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICAvLyBtYXRjaCBzZWxlY3RvciBhbmQgaGFsdCBvbiBmaXJzdCByZXN1bHQuXG4gICAgbGV0IHJlc3VsdCA9IHF1ZXJ5KHRoaXMsIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiB1dGlscy5tYXRjaGVzU2VsZWN0b3Iobiwgc2VsZWN0b3IpO1xuICAgIH0sIGZ1bmN0aW9uKG4pIHtcbiAgICAgIHJldHVybiBCb29sZWFuKG4pO1xuICAgIH0pWzBdO1xuICAgIHJldHVybiByZXN1bHQgfHwgbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0VsZW1lbnR9XG4gICAqIEBwYXJhbSAge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHBhcmFtICB7Ym9vbGVhbn0gdXNlTmF0aXZlXG4gICAqL1xuICAvLyBUT0RPKHNvcnZlbGwpOiBgdXNlTmF0aXZlYCBvcHRpb24gcmVsaWVzIG9uIG5hdGl2ZSBxdWVyeVNlbGVjdG9yQWxsIGFuZFxuICAvLyBtaXNzZXMgZGlzdHJpYnV0ZWQgbm9kZXMsIHNlZVxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2ViY29tcG9uZW50cy9zaGFkeWRvbS9wdWxsLzIxMCNpc3N1ZWNvbW1lbnQtMzYxNDM1NTAzXG4gIHF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IsIHVzZU5hdGl2ZSkge1xuICAgIGlmICh1c2VOYXRpdmUpIHtcbiAgICAgIGNvbnN0IG8gPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncXVlcnlTZWxlY3RvckFsbCddKHNlbGVjdG9yKSk7XG4gICAgICBjb25zdCByb290ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXSgpO1xuICAgICAgcmV0dXJuIG8uZmlsdGVyKGUgPT4gZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZ2V0Um9vdE5vZGUnXSgpID09IHJvb3QpO1xuICAgIH1cbiAgICByZXR1cm4gcXVlcnkodGhpcywgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIHV0aWxzLm1hdGNoZXNTZWxlY3RvcihuLCBzZWxlY3Rvcik7XG4gICAgfSk7XG4gIH1cblxufSk7XG5cbi8vIEluIHByZWZlclBlcmZvcm1hbmNlIG1vZGUsIGNyZWF0ZSBhIGN1c3RvbSBgUGFyZW50Tm9kZURvY3VtZW50T3JGcmFnbWVudGBcbi8vIHRoYXQgb3B0aW9uYWxseSBkb2VzIG5vdCBtaXhpbiBxdWVyeVNlbGVjdG9yL0FsbDsgdGhpcyBpcyBhIHBlcmZvcm1hbmNlXG4vLyBvcHRpbWl6YXRpb24uIEluIG5vUGF0Y2gsIHdlIG5lZWQgdG8ga2VlcCB0aGUgcXVlcnkgcGF0Y2hlcyBoZXJlIGluIG9yZGVyIHRvXG4vLyBlbnN1cmUgdGhlIHF1ZXJ5IEFQSSBpcyBhdmFpbGFibGUgb24gdGhlIHdyYXBwZXJcbmV4cG9ydCBjb25zdCBQYXJlbnROb2RlRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcyA9XG4gICh1dGlscy5zZXR0aW5ncy5wcmVmZXJQZXJmb3JtYW5jZSAmJiAhdXRpbHMuc2V0dGluZ3Mubm9QYXRjaCkgP1xuICBPYmplY3QuYXNzaWduKHt9LCBQYXJlbnROb2RlUGF0Y2hlcykgOiBQYXJlbnROb2RlUGF0Y2hlcztcblxuT2JqZWN0LmFzc2lnbihQYXJlbnROb2RlUGF0Y2hlcywgUXVlcnlQYXRjaGVzKTsiLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHsgcXVlcnkgfSBmcm9tICcuL1BhcmVudE5vZGUuanMnO1xuXG5leHBvcnQgY29uc3QgRG9jdW1lbnRPckZyYWdtZW50UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAqL1xuICBnZXRFbGVtZW50QnlJZChpZCkge1xuICAgIGlmIChpZCA9PT0gJycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gcXVlcnkodGhpcywgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIG4uaWQgPT0gaWQ7XG4gICAgfSwgZnVuY3Rpb24obikge1xuICAgICAgcmV0dXJuIEJvb2xlYW4obik7XG4gICAgfSlbMF07XG4gICAgcmV0dXJuIHJlc3VsdCB8fCBudWxsO1xuICB9XG5cbn0pOyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7b3duZXJTaGFkeVJvb3RGb3JOb2RlfSBmcm9tICcuLi9hdHRhY2gtc2hhZG93LmpzJztcblxuZnVuY3Rpb24gZ2V0RG9jdW1lbnRBY3RpdmVFbGVtZW50KCkge1xuICBpZiAodXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnRbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdhY3RpdmVFbGVtZW50J107XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IERvY3VtZW50T3JTaGFkb3dSb290UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7RG9jdW1lbnR8U2hhZG93Um9vdH0gKi9cbiAgZ2V0IGFjdGl2ZUVsZW1lbnQoKSB7XG4gICAgbGV0IGFjdGl2ZSA9IGdldERvY3VtZW50QWN0aXZlRWxlbWVudCgpO1xuICAgIC8vIEluIElFMTEsIGFjdGl2ZUVsZW1lbnQgbWlnaHQgYmUgYW4gZW1wdHkgb2JqZWN0IGlmIHRoZSBkb2N1bWVudCBpc1xuICAgIC8vIGNvbnRhaW5lZCBpbiBhbiBpZnJhbWUuXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubWljcm9zb2Z0LmNvbS9lbi11cy9taWNyb3NvZnQtZWRnZS9wbGF0Zm9ybS9pc3N1ZXMvMTA5OTg3ODgvXG4gICAgaWYgKCFhY3RpdmUgfHwgIWFjdGl2ZS5ub2RlVHlwZSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBpc1NoYWR5Um9vdCA9ICEhKHV0aWxzLmlzU2hhZHlSb290KHRoaXMpKTtcbiAgICBpZiAodGhpcyAhPT0gZG9jdW1lbnQpIHtcbiAgICAgIC8vIElmIHRoaXMgbm9kZSBpc24ndCBhIGRvY3VtZW50IG9yIHNoYWR5IHJvb3QsIHRoZW4gaXQgZG9lc24ndCBoYXZlXG4gICAgICAvLyBhbiBhY3RpdmUgZWxlbWVudC5cbiAgICAgIGlmICghaXNTaGFkeVJvb3QpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICAvLyBJZiB0aGlzIHNoYWR5IHJvb3QncyBob3N0IGlzIHRoZSBhY3RpdmUgZWxlbWVudCBvciB0aGUgYWN0aXZlXG4gICAgICAvLyBlbGVtZW50IGlzIG5vdCBhIGRlc2NlbmRhbnQgb2YgdGhlIGhvc3QgKGluIHRoZSBjb21wb3NlZCB0cmVlKSxcbiAgICAgIC8vIHRoZW4gaXQgZG9lc24ndCBoYXZlIGFuIGFjdGl2ZSBlbGVtZW50LlxuICAgICAgaWYgKHRoaXMuaG9zdCA9PT0gYWN0aXZlIHx8XG4gICAgICAgICAgIXRoaXMuaG9zdFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2NvbnRhaW5zJ10oYWN0aXZlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBub2RlIGlzIGVpdGhlciB0aGUgZG9jdW1lbnQgb3IgYSBzaGFkeSByb290IG9mIHdoaWNoIHRoZSBhY3RpdmVcbiAgICAvLyBlbGVtZW50IGlzIGEgKGNvbXBvc2VkKSBkZXNjZW5kYW50IG9mIGl0cyBob3N0OyBpdGVyYXRlIHVwd2FyZHMgdG9cbiAgICAvLyBmaW5kIHRoZSBhY3RpdmUgZWxlbWVudCdzIG1vc3Qgc2hhbGxvdyBob3N0IHdpdGhpbiBpdC5cbiAgICBsZXQgYWN0aXZlUm9vdCA9IG93bmVyU2hhZHlSb290Rm9yTm9kZShhY3RpdmUpO1xuICAgIHdoaWxlIChhY3RpdmVSb290ICYmIGFjdGl2ZVJvb3QgIT09IHRoaXMpIHtcbiAgICAgIGFjdGl2ZSA9IGFjdGl2ZVJvb3QuaG9zdDtcbiAgICAgIGFjdGl2ZVJvb3QgPSBvd25lclNoYWR5Um9vdEZvck5vZGUoYWN0aXZlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMgPT09IGRvY3VtZW50KSB7XG4gICAgICAvLyBUaGlzIG5vZGUgaXMgdGhlIGRvY3VtZW50LCBzbyBhY3RpdmVSb290IHNob3VsZCBiZSBudWxsLlxuICAgICAgcmV0dXJuIGFjdGl2ZVJvb3QgPyBudWxsIDogYWN0aXZlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIG5vZGUgaXMgYSBub24tZG9jdW1lbnQgc2hhZHkgcm9vdCwgYW5kIGl0IHNob3VsZCBiZVxuICAgICAgLy8gYWN0aXZlUm9vdC5cbiAgICAgIHJldHVybiBhY3RpdmVSb290ID09PSB0aGlzID8gYWN0aXZlIDogbnVsbDtcbiAgICB9XG4gIH1cbn0pO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtnZXRJbm5lckhUTUx9IGZyb20gJy4uL2lubmVySFRNTC5qcyc7XG5pbXBvcnQge2NsZWFyTm9kZX0gZnJvbSAnLi9Ob2RlLmpzJztcblxuLyoqIEB0eXBlIHshRG9jdW1lbnR9ICovXG5jb25zdCBpbmVydERvYyA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCgnaW5lcnQnKTtcblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgaW5uZXJIVE1MKCkge1xuICAgIGlmICh1dGlscy5pc1RyYWNraW5nTG9naWNhbENoaWxkTm9kZXModGhpcykpIHtcbiAgICAgIGNvbnN0IGNvbnRlbnQgPSB0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJyA/XG4gICAgICAvKiogQHR5cGUge0hUTUxUZW1wbGF0ZUVsZW1lbnR9ICovKHRoaXMpLmNvbnRlbnQgOiB0aGlzO1xuICAgICAgcmV0dXJuIGdldElubmVySFRNTChjb250ZW50LCB1dGlscy5jaGlsZE5vZGVzQXJyYXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2lubmVySFRNTCddO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0VsZW1lbnR9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0IGlubmVySFRNTCh2YWx1ZSkge1xuICAgIGlmICh0aGlzLmxvY2FsTmFtZSA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2lubmVySFRNTCddID0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsZWFyTm9kZSh0aGlzKTtcbiAgICAgIGNvbnN0IGNvbnRhaW5lck5hbWUgPSB0aGlzLmxvY2FsTmFtZSB8fCAnZGl2JztcbiAgICAgIGxldCBodG1sQ29udGFpbmVyO1xuICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZVVSSSB8fCB0aGlzLm5hbWVzcGFjZVVSSSA9PT0gaW5lcnREb2MubmFtZXNwYWNlVVJJKSB7XG4gICAgICAgIGh0bWxDb250YWluZXIgPSBpbmVydERvYy5jcmVhdGVFbGVtZW50KGNvbnRhaW5lck5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaHRtbENvbnRhaW5lciA9IGluZXJ0RG9jLmNyZWF0ZUVsZW1lbnROUyh0aGlzLm5hbWVzcGFjZVVSSSwgY29udGFpbmVyTmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMpIHtcbiAgICAgICAgaHRtbENvbnRhaW5lclt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2lubmVySFRNTCddID0gdmFsdWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBodG1sQ29udGFpbmVyLmlubmVySFRNTCA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgbGV0IGZpcnN0Q2hpbGQ7XG4gICAgICB3aGlsZSAoKGZpcnN0Q2hpbGQgPSBodG1sQ29udGFpbmVyW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ10pKSB7XG4gICAgICAgIHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2luc2VydEJlZm9yZSddKGZpcnN0Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcblxuZXhwb3J0IGNvbnN0IFNoYWRvd1Jvb3RQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtTaGFkb3dSb290fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdHxib29sZWFuPX0gb3B0aW9uc09yQ2FwdHVyZVxuICAgKi9cbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9uc09yQ2FwdHVyZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FwdHVyZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnNPckNhcHR1cmUgPSB7XG4gICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90ZSwgYF9fc2hhZHlUYXJnZXRgIG1heSBhbHJlYWR5IGJlIHNldCBpZiBhbiBldmVudCB3YXMgYWRkZWQgb24gYSA8c2xvdD4gY2hpbGRcbiAgICBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgPSBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgfHwgdGhpcztcbiAgICB0aGlzLmhvc3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXSh0eXBlLCBmbiwgb3B0aW9uc09yQ2FwdHVyZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtTaGFkb3dSb290fVxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICAgKiBAcGFyYW0ge09iamVjdHxib29sZWFuPX0gb3B0aW9uc09yQ2FwdHVyZVxuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBmbiwgb3B0aW9uc09yQ2FwdHVyZSkge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FwdHVyZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIG9wdGlvbnNPckNhcHR1cmUgPSB7XG4gICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZSlcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gTm90ZSwgYF9fc2hhZHlUYXJnZXRgIG1heSBhbHJlYWR5IGJlIHNldCBpZiBhbiBldmVudCB3YXMgYWRkZWQgb24gYSA8c2xvdD4gY2hpbGRcbiAgICBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgPSBvcHRpb25zT3JDYXB0dXJlLl9fc2hhZHlUYXJnZXQgfHwgdGhpcztcbiAgICB0aGlzLmhvc3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3JlbW92ZUV2ZW50TGlzdGVuZXInXSh0eXBlLCBmbiwgb3B0aW9uc09yQ2FwdHVyZSk7XG4gIH1cblxufSk7XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7Tm9kZVBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Ob2RlLmpzJztcbmltcG9ydCB7T3V0c2lkZURlc2NyaXB0b3JzLCBJbnNpZGVEZXNjcmlwdG9ycywgVGV4dENvbnRlbnRJbm5lckhUTUxEZXNjcmlwdG9yc30gZnJvbSAnLi9wYXRjaC1pbnN0YW5jZXMuanMnO1xuaW1wb3J0IHtQYXJlbnROb2RlUGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL1BhcmVudE5vZGUuanMnO1xuaW1wb3J0IHtEb2N1bWVudE9yRnJhZ21lbnRQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRG9jdW1lbnRPckZyYWdtZW50LmpzJztcbmltcG9ydCB7RG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRG9jdW1lbnRPclNoYWRvd1Jvb3QuanMnO1xuaW1wb3J0IHtFbGVtZW50T3JTaGFkb3dSb290UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL0VsZW1lbnRPclNoYWRvd1Jvb3QuanMnO1xuaW1wb3J0IHtTaGFkb3dSb290UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL1NoYWRvd1Jvb3QuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IU9iamVjdH0gcHJvdG9cbiAqIEBwYXJhbSB7c3RyaW5nPX0gcHJlZml4XG4gKi9cbmNvbnN0IHBhdGNoU2hhZHlBY2Nlc3NvcnMgPSAocHJvdG8sIHByZWZpeCkgPT4ge1xuICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIFNoYWRvd1Jvb3RQYXRjaGVzLCBwcmVmaXgpO1xuICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIERvY3VtZW50T3JTaGFkb3dSb290UGF0Y2hlcywgcHJlZml4KTtcbiAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKHByb3RvLCBFbGVtZW50T3JTaGFkb3dSb290UGF0Y2hlcywgcHJlZml4KTtcbiAgLy8gV2UgZW5zdXJlIFBhcmVudE5vZGUgYWNjZXNzb3JzIHNpbmNlIHRoZXNlIGRvIG5vdCBleGlzdCBpbiBFZGdlL0lFIG9uIERvY3VtZW50RnJhZ21lbnRzLlxuICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIFBhcmVudE5vZGVQYXRjaGVzLCBwcmVmaXgpO1xuICAvLyBFbnN1cmUgYHNoYWRvd1Jvb3RgIGhhcyBiYXNpYyBkZXNjcmlwdG9ycyB3aGVuIHdlIGNhbm5vdCByZWx5XG4gIC8vIG9uIHRoZW0gY29taW5nIGZyb20gRG9jdW1lbnRGcmFnbWVudC5cbiAgLy9cbiAgLy8gQ2FzZSAxLCBub1BhdGNoaW5nOiBCZWNhdXNlIHdlIHdhbnQgbm9QYXRjaCBTaGFkeVJvb3RzIHRvIGhhdmUgbmF0aXZlIHByb3BlcnR5XG4gIC8vIG5hbWVzIHNvIHRoYXQgdGhleSBkbyBub3QgaGF2ZSB0byBiZSB3cmFwcGVkLi4uXG4gIC8vIFdoZW4gd2UgZG8gKm5vdCogcGF0Y2ggTm9kZS9Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZVxuICAvLyB3ZSBtdXN0IG1hbnVhbGx5IGluc3RhbGwgdGhvc2UgcHJvcGVydGllcyBvbiBTaGFkeVJvb3QncyBwcm90b3R5cGUuXG4gIC8vIE5vdGUsIGl0J3MgaW1wb3J0YW50IHRvIG9ubHkgaW5zdGFsbCB0aGVzZSBpbiB0aGlzIG1vZGUgc28gYXMgbm90IHRvIHN0b21wXG4gIC8vIG92ZXIgQ3VzdG9tRWxlbWVudHMgcG9seWZpbGwncyBwYXRjaGVzIG9uIE5vZGUvRG9jdW1lbnRGcmFnbWVudCBtZXRob2RzLlxuICBpZiAodXRpbHMuc2V0dGluZ3Mubm9QYXRjaCAmJiAhcHJlZml4KSB7XG4gICAgdXRpbHMucGF0Y2hQcm9wZXJ0aWVzKHByb3RvLCBOb2RlUGF0Y2hlcywgcHJlZml4KTtcbiAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIERvY3VtZW50T3JGcmFnbWVudFBhdGNoZXMsIHByZWZpeCk7XG4gIC8vIENhc2UgMiwgYmFkIGRlc2NyaXB0b3JzOiBFbnN1cmUgYWNjZXNzb3JzIGFyZSBvbiBTaGFkb3dSb290LlxuICAvLyBUaGVzZSBkZXNjcmlwdG9ycyBhcmUgbm9ybWFsbHkgdXNlZCBmb3IgaW5zdGFuY2UgcGF0Y2hpbmcgYnV0IGJlY2F1c2VcbiAgLy8gU2hhZHlSb290IGNhbiBhbHdheXMgYmUgcGF0Y2hlZCwganVzdCBkbyBpdCB0byB0aGUgcHJvdG90eXBlLlxuICB9IGVsc2UgaWYgKCF1dGlscy5zZXR0aW5ncy5oYXNEZXNjcmlwdG9ycykge1xuICAgIHV0aWxzLnBhdGNoUHJvcGVydGllcyhwcm90bywgT3V0c2lkZURlc2NyaXB0b3JzKTtcbiAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIEluc2lkZURlc2NyaXB0b3JzKTtcbiAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIFRleHRDb250ZW50SW5uZXJIVE1MRGVzY3JpcHRvcnMpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwYXRjaFNoYWR5Um9vdCA9IChwcm90bykgPT4ge1xuICBwcm90by5fX3Byb3RvX18gPSBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZTtcblxuICAvLyBwYXRjaCBib3RoIHByZWZpeGVkIGFuZCBub3QsIGV2ZW4gd2hlbiBub1BhdGNoID09IHRydWUuXG4gIHBhdGNoU2hhZHlBY2Nlc3NvcnMocHJvdG8sIHV0aWxzLlNIQURZX1BSRUZJWCk7XG4gIHBhdGNoU2hhZHlBY2Nlc3NvcnMocHJvdG8pO1xuXG4gIC8vIEVuc3VyZSBuYXRpdmUgcHJvcGVydGllcyBhcmUgYWxsIHNhZmVseSB3cmFwcGVkIHNpbmNlIFNoYWRvd1Jvb3QgaXMgbm90IGFuXG4gIC8vIGFjdHVhbCBEb2N1bWVudEZyYWdtZW50IGluc3RhbmNlLlxuICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhwcm90bywge1xuICAgIG5vZGVUeXBlOiB7XG4gICAgICB2YWx1ZTogTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBub2RlTmFtZToge1xuICAgICAgdmFsdWU6ICcjZG9jdW1lbnQtZnJhZ21lbnQnLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSxcbiAgICBub2RlVmFsdWU6IHtcbiAgICAgIHZhbHVlOiBudWxsLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcblxuICAvLyBtYWtlIHVuZGVmaW5lZFxuICBbXG4gICAgJ2xvY2FsTmFtZScsXG4gICAgJ25hbWVzcGFjZVVSSScsXG4gICAgJ3ByZWZpeCdcbiAgXS5mb3JFYWNoKChwcm9wKSA9PiB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCBwcm9wLCB7XG4gICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0pO1xuXG4gIC8vIGRlZmVyIHByb3BlcnRpZXMgdG8gaG9zdFxuICBbXG4gICAgJ293bmVyRG9jdW1lbnQnLFxuICAgICdiYXNlVVJJJyxcbiAgICAnaXNDb25uZWN0ZWQnXG4gIF0uZm9yRWFjaCgocHJvcCkgPT4ge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgcHJvcCwge1xuICAgICAgLyoqIEB0aGlzIHtTaGFkb3dSb290fSAqL1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ob3N0W3Byb3BdO1xuICAgICAgfSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9KTtcbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCB7Y2FsY3VsYXRlU3BsaWNlc30gZnJvbSAnLi9hcnJheS1zcGxpY2UuanMnO1xuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge2VucXVldWV9IGZyb20gJy4vZmx1c2guanMnO1xuaW1wb3J0IHtlbnN1cmVTaGFkeURhdGFGb3JOb2RlLCBzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuL3NoYWR5LWRhdGEuanMnO1xuaW1wb3J0IHtyZWNvcmRDaGlsZE5vZGVzfSBmcm9tICcuL2xpbmstbm9kZXMuanMnO1xuaW1wb3J0IHtwYXRjaFNoYWR5Um9vdH0gZnJvbSAnLi9wYXRjaC1zaGFkeVJvb3QuanMnO1xuXG4vLyBEbyBub3QgZXhwb3J0IHRoaXMgb2JqZWN0LiBJdCBtdXN0IGJlIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4vLyBTaGFkeVJvb3QgY29uc3RydWN0b3IgaW4gYGF0dGFjaFNoYWRvd2AgdG8gcHJldmVudCB0aGUgY29uc3RydWN0b3IgZnJvbVxuLy8gdGhyb3dpbmcuIFRoaXMgcHJldmVudHMgdGhlIHVzZXIgZnJvbSBiZWluZyBhYmxlIHRvIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG4vLyBTaGFkeVJvb3QgKGkuZS4gYG5ldyBTaGFkb3dSb290KClgKS5cbmNvbnN0IFNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuID0ge307XG5cbmNvbnN0IENBVENIQUxMX05BTUUgPSAnX19jYXRjaGFsbCc7XG5jb25zdCBTSEFEWVJPT1RfTkFNRSA9ICdTaGFkeVJvb3QnO1xuXG5jb25zdCBNT0RFX0NMT1NFRCA9ICdjbG9zZWQnO1xuXG5sZXQgaXNSZW5kZXJpbmcgPSB1dGlscy5zZXR0aW5nc1snZGVmZXJDb25uZWN0aW9uQ2FsbGJhY2tzJ10gJiYgZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnO1xubGV0IHJvb3RSZW5kZXJlZDtcblxuZnVuY3Rpb24gYW5jZXN0b3JMaXN0KG5vZGUpIHtcbiAgbGV0IGFuY2VzdG9ycyA9IFtdO1xuICBkbyB7XG4gICAgYW5jZXN0b3JzLnVuc2hpZnQobm9kZSk7XG4gIH0gd2hpbGUgKChub2RlID0gbm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddKSk7XG4gIHJldHVybiBhbmNlc3RvcnM7XG59XG5cbi8qKlxuICogQGV4dGVuZHMge1NoYWRvd1Jvb3R9XG4gKi9cbmNsYXNzIFNoYWR5Um9vdCB7XG5cbiAgY29uc3RydWN0b3IodG9rZW4sIGhvc3QsIG9wdGlvbnMpIHtcbiAgICBpZiAodG9rZW4gIT09IFNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbGxlZ2FsIGNvbnN0cnVjdG9yJyk7XG4gICAgfVxuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLl9yZW5kZXJQZW5kaW5nO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLl9oYXNSZW5kZXJlZDtcbiAgICAvKiogQHR5cGUgez9BcnJheTxIVE1MU2xvdEVsZW1lbnQ+fSAqL1xuICAgIHRoaXMuX3Nsb3RMaXN0ID0gbnVsbDtcbiAgICAvKiogQHR5cGUgez9PYmplY3Q8c3RyaW5nLCBBcnJheTxIVE1MU2xvdEVsZW1lbnQ+Pn0gKi9cbiAgICB0aGlzLl9zbG90TWFwO1xuICAgIC8qKiBAdHlwZSB7P0FycmF5PEhUTUxTbG90RWxlbWVudD59ICovXG4gICAgdGhpcy5fcGVuZGluZ1Nsb3RzO1xuICAgIHRoaXMuX2luaXQoaG9zdCwgb3B0aW9ucyk7XG4gIH1cblxuICBfaW5pdChob3N0LCBvcHRpb25zKSB7XG4gICAgLy8gTk9URTogc2V0IGEgZmFrZSBsb2NhbCBuYW1lIHNvIHRoaXMgZWxlbWVudCBjYW4gYmVcbiAgICAvLyBkaXN0aW5ndWlzaGVkIGZyb20gYSBEb2N1bWVudEZyYWdtZW50IHdoZW4gcGF0Y2hpbmcuXG4gICAgLy8gRkYgZG9lc24ndCBhbGxvdyB0aGlzIHRvIGJlIGBsb2NhbE5hbWVgXG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5fbG9jYWxOYW1lID0gU0hBRFlST09UX05BTUU7XG4gICAgLy8gcm9vdCA8PT4gaG9zdFxuICAgIHRoaXMuaG9zdCA9IGhvc3Q7XG4gICAgLyoqIEB0eXBlIHshc3RyaW5nfHVuZGVmaW5lZH0gKi9cbiAgICB0aGlzLm1vZGUgPSBvcHRpb25zICYmIG9wdGlvbnMubW9kZTtcbiAgICByZWNvcmRDaGlsZE5vZGVzKHRoaXMuaG9zdCk7XG4gICAgY29uc3QgaG9zdERhdGEgPSBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKHRoaXMuaG9zdCk7XG4gICAgLyoqIEB0eXBlIHshU2hhZHlSb290fSAqL1xuICAgIGhvc3REYXRhLnJvb3QgPSB0aGlzO1xuICAgIGhvc3REYXRhLnB1YmxpY1Jvb3QgPSB0aGlzLm1vZGUgIT09IE1PREVfQ0xPU0VEID8gdGhpcyA6IG51bGw7XG4gICAgLy8gc2V0dXAgcm9vdFxuICAgIGNvbnN0IHJvb3REYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICByb290RGF0YS5maXJzdENoaWxkID0gcm9vdERhdGEubGFzdENoaWxkID1cbiAgICAgICAgcm9vdERhdGEucGFyZW50Tm9kZSA9IHJvb3REYXRhLm5leHRTaWJsaW5nID1cbiAgICAgICAgcm9vdERhdGEucHJldmlvdXNTaWJsaW5nID0gbnVsbDtcbiAgICAvLyBOT1RFOiBvcHRpbWl6YXRpb24gZmxhZywgb25seSByZXF1aXJlIGFuIGFzeW5jaHJvbm91cyByZW5kZXJcbiAgICAvLyB0byByZWNvcmQgcGFyc2VkIGNoaWxkcmVuIGlmIGZsYWcgaXMgbm90IHNldC5cbiAgICBpZiAodXRpbHMuc2V0dGluZ3NbJ3ByZWZlclBlcmZvcm1hbmNlJ10pIHtcbiAgICAgIGxldCBuO1xuICAgICAgd2hpbGUgKChuID0gdGhpcy5ob3N0W3V0aWxzLk5BVElWRV9QUkVGSVggKyAnZmlyc3RDaGlsZCddKSkge1xuICAgICAgICB0aGlzLmhvc3RbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG4pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hc3luY1JlbmRlcigpO1xuICAgIH1cbiAgfVxuXG4gIF9hc3luY1JlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuX3JlbmRlclBlbmRpbmcpIHtcbiAgICAgIHRoaXMuX3JlbmRlclBlbmRpbmcgPSB0cnVlO1xuICAgICAgZW5xdWV1ZSgoKSA9PiB0aGlzLl9yZW5kZXIoKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmV0dXJucyB0aGUgb2xkZXN0IHJlbmRlclBlbmRpbmcgYW5jZXN0b3Igcm9vdC5cbiAgX2dldFBlbmRpbmdEaXN0cmlidXRpb25Sb290KCkge1xuICAgIGxldCByZW5kZXJSb290O1xuICAgIGxldCByb290ID0gdGhpcztcbiAgICB3aGlsZSAocm9vdCkge1xuICAgICAgaWYgKHJvb3QuX3JlbmRlclBlbmRpbmcpIHtcbiAgICAgICAgcmVuZGVyUm9vdCA9IHJvb3Q7XG4gICAgICB9XG4gICAgICByb290ID0gcm9vdC5fZ2V0RGlzdHJpYnV0aW9uUGFyZW50KCk7XG4gICAgfVxuICAgIHJldHVybiByZW5kZXJSb290O1xuICB9XG5cbiAgLy8gUmV0dXJucyB0aGUgc2hhZHlSb290IGB0aGlzLmhvc3RgIGlmIGB0aGlzLmhvc3RgXG4gIC8vIGhhcyBjaGlsZHJlbiB0aGF0IHJlcXVpcmUgZGlzdHJpYnV0aW9uLlxuICBfZ2V0RGlzdHJpYnV0aW9uUGFyZW50KCkge1xuICAgIGxldCByb290ID0gdGhpcy5ob3N0W3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCk7XG4gICAgaWYgKCF1dGlscy5pc1NoYWR5Um9vdChyb290KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcy5ob3N0KTtcbiAgICBpZiAobm9kZURhdGEgJiYgbm9kZURhdGEuX19jaGlsZFNsb3RDb3VudCA+IDApIHtcbiAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgfVxuXG4gIC8vIFJlbmRlcnMgdGhlIHRvcCBtb3N0IHJlbmRlciBwZW5kaW5nIHNoYWRvd1Jvb3QgaW4gdGhlIGRpc3RyaWJ1dGlvbiB0cmVlLlxuICAvLyBUaGlzIGlzIHNhZmUgYmVjYXVzZSB3aGVuIGEgZGlzdHJpYnV0aW9uIHBhcmVudCByZW5kZXJzLCBhbGwgY2hpbGRyZW4gcmVuZGVyLlxuICBfcmVuZGVyKCkge1xuICAgIC8vIElmIHRoaXMgcm9vdCBpcyBub3QgcGVuZGluZywgaXQgbmVlZHMgbm8gcmVuZGVyaW5nIHdvcmsuIEFueSBwZW5kaW5nXG4gICAgLy8gcGFyZW50IHRoYXQgbmVlZHMgdG8gcmVuZGVyIHdsbCBjYXVzZSB0aGlzIHJvb3QgdG8gcmVuZGVyLlxuICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yZW5kZXJQZW5kaW5nICYmIHRoaXMuX2dldFBlbmRpbmdEaXN0cmlidXRpb25Sb290KCk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJvb3QuX3JlbmRlclNlbGYoKTtcbiAgICB9XG4gIH1cblxuICBfZmx1c2hJbml0aWFsKCkge1xuICAgIGlmICghdGhpcy5faGFzUmVuZGVyZWQgJiYgdGhpcy5fcmVuZGVyUGVuZGluZykge1xuICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqIEBvdmVycmlkZSAqL1xuICBfcmVuZGVyU2VsZigpIHtcbiAgICAvLyB0cmFjayByZW5kZXJpbmcgc3RhdGUuXG4gICAgY29uc3Qgd2FzUmVuZGVyaW5nID0gaXNSZW5kZXJpbmc7XG4gICAgaXNSZW5kZXJpbmcgPSB0cnVlO1xuICAgIHRoaXMuX3JlbmRlclBlbmRpbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fc2xvdExpc3QpIHtcbiAgICAgIHRoaXMuX2Rpc3RyaWJ1dGUoKTtcbiAgICAgIHRoaXMuX2NvbXBvc2UoKTtcbiAgICB9XG4gICAgLy8gTk9URTogb3B0aW1pemF0aW9uIGZsYWcsIG9ubHkgcHJvY2VzcyBwYXJzZWQgY2hpbGRyZW5cbiAgICAvLyBpZiBvcHRpbWl6YXRpb24gZmxhZyBpcyBub3Qgc2V0LlxuICAgIC8vIG9uIGluaXRpYWwgcmVuZGVyIHJlbW92ZSBhbnkgdW5kaXN0cmlidXRlZCBjaGlsZHJlbi5cbiAgICBpZiAoIXV0aWxzLnNldHRpbmdzWydwcmVmZXJQZXJmb3JtYW5jZSddICYmICF0aGlzLl9oYXNSZW5kZXJlZCkge1xuICAgICAgZm9yIChsZXQgbj10aGlzLmhvc3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXTsgbjsgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IHNoYWR5RGF0YUZvck5vZGUobik7XG4gICAgICAgIGlmIChuW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddID09PSB0aGlzLmhvc3QgJiZcbiAgICAgICAgICAgIChuLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnIHx8ICFkYXRhLmFzc2lnbmVkU2xvdCkpIHtcbiAgICAgICAgICB0aGlzLmhvc3RbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2hhc1JlbmRlcmVkID0gdHJ1ZTtcbiAgICBpc1JlbmRlcmluZyA9IHdhc1JlbmRlcmluZztcbiAgICBpZiAocm9vdFJlbmRlcmVkKSB7XG4gICAgICByb290UmVuZGVyZWQoKTtcbiAgICB9XG4gIH1cblxuICBfZGlzdHJpYnV0ZSgpIHtcbiAgICB0aGlzLl92YWxpZGF0ZVNsb3RzKCk7XG4gICAgLy8gY2FwdHVyZSAjIG9mIHByZXZpb3VzbHkgYXNzaWduZWQgbm9kZXMgdG8gaGVscCBkZXRlcm1pbmUgaWYgZGlydHkuXG4gICAgZm9yIChsZXQgaT0wLCBzbG90OyBpIDwgdGhpcy5fc2xvdExpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNsb3QgPSB0aGlzLl9zbG90TGlzdFtpXTtcbiAgICAgIHRoaXMuX2NsZWFyU2xvdEFzc2lnbmVkTm9kZXMoc2xvdCk7XG4gICAgfVxuICAgIC8vIGRpc3RyaWJ1dGUgaG9zdCBjaGlsZHJlbi5cbiAgICBmb3IgKGxldCBuPXRoaXMuaG9zdFt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuPW5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgIHRoaXMuX2Rpc3RyaWJ1dGVOb2RlVG9TbG90KG4pO1xuICAgIH1cbiAgICAvLyBmYWxsYmFjayBjb250ZW50LCBzbG90Y2hhbmdlLCBhbmQgZGlydHkgcm9vdHNcbiAgICBmb3IgKGxldCBpPTA7IGkgPCB0aGlzLl9zbG90TGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc2xvdCA9IHRoaXMuX3Nsb3RMaXN0W2ldO1xuICAgICAgY29uc3Qgc2xvdERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3QpO1xuICAgICAgLy8gZGlzdHJpYnV0ZSBmYWxsYmFjayBjb250ZW50XG4gICAgICBpZiAoIXNsb3REYXRhLmFzc2lnbmVkTm9kZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IG49c2xvdFt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddOyBuOyBuPW5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ10pIHtcbiAgICAgICAgICB0aGlzLl9kaXN0cmlidXRlTm9kZVRvU2xvdChuLCBzbG90KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc2xvdFBhcmVudERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3RbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXSk7XG4gICAgICBjb25zdCBzbG90UGFyZW50Um9vdCA9IHNsb3RQYXJlbnREYXRhICYmIHNsb3RQYXJlbnREYXRhLnJvb3Q7XG4gICAgICBpZiAoc2xvdFBhcmVudFJvb3QgJiYgKHNsb3RQYXJlbnRSb290Ll9oYXNJbnNlcnRpb25Qb2ludCgpIHx8IHNsb3RQYXJlbnRSb290Ll9yZW5kZXJQZW5kaW5nKSkge1xuICAgICAgICBzbG90UGFyZW50Um9vdC5fcmVuZGVyU2VsZigpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWRkQXNzaWduZWRUb0ZsYXR0ZW5lZE5vZGVzKHNsb3REYXRhLmZsYXR0ZW5lZE5vZGVzLFxuICAgICAgICBzbG90RGF0YS5hc3NpZ25lZE5vZGVzKTtcbiAgICAgIGxldCBwcmV2QXNzaWduZWROb2RlcyA9IHNsb3REYXRhLl9wcmV2aW91c2x5QXNzaWduZWROb2RlcztcbiAgICAgIGlmIChwcmV2QXNzaWduZWROb2Rlcykge1xuICAgICAgICBmb3IgKGxldCBpPTA7IGkgPCBwcmV2QXNzaWduZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIHNoYWR5RGF0YUZvck5vZGUocHJldkFzc2lnbmVkTm9kZXNbaV0pLl9wcmV2QXNzaWduZWRTbG90ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzbG90RGF0YS5fcHJldmlvdXNseUFzc2lnbmVkTm9kZXMgPSBudWxsO1xuICAgICAgICAvLyBkaXJ0eSBpZiBwcmV2aW91c2x5IGxlc3MgYXNzaWduZWQgbm9kZXMgdGhhbiBwcmV2aW91c2x5IGFzc2lnbmVkLlxuICAgICAgICBpZiAocHJldkFzc2lnbmVkTm9kZXMubGVuZ3RoID4gc2xvdERhdGEuYXNzaWduZWROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICBzbG90RGF0YS5kaXJ0eSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qIE5vdGU6IEEgc2xvdCBpcyBtYXJrZWQgZGlydHkgd2hlbmV2ZXIgYSBub2RlIGlzIG5ld2x5IGFzc2lnbmVkIHRvIGl0XG4gICAgICBvciBhIG5vZGUgaXMgYXNzaWduZWQgdG8gYSBkaWZmZXJlbnQgc2xvdCAoZG9uZSBpbiBgX2Rpc3RyaWJ1dGVOb2RlVG9TbG90YClcbiAgICAgIG9yIGlmIHRoZSBudW1iZXIgb2Ygbm9kZXMgYXNzaWduZWQgdG8gdGhlIHNsb3QgaGFzIGRlY3JlYXNlZCAoZG9uZSBhYm92ZSk7XG4gICAgICAqL1xuICAgICAgaWYgKHNsb3REYXRhLmRpcnR5KSB7XG4gICAgICAgIHNsb3REYXRhLmRpcnR5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2ZpcmVTbG90Q2hhbmdlKHNsb3QpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEaXN0cmlidXRlcyBnaXZlbiBgbm9kZWAgdG8gdGhlIGFwcHJvcHJpYXRlIHNsb3QgYmFzZWQgb24gaXRzIGBzbG90YFxuICAgKiBhdHRyaWJ1dGUuIElmIGBmb3JjZWRTbG90YCBpcyBnaXZlbiwgdGhlbiB0aGUgbm9kZSBpcyBkaXN0cmlidXRlZCB0byB0aGVcbiAgICogYGZvcmNlZFNsb3RgLlxuICAgKiBOb3RlOiBzbG90IHRvIHdoaWNoIHRoZSBub2RlIGlzIGFzc2lnbmVkIHdpbGwgYmUgbWFya2VkIGRpcnR5IGZvciBmaXJpbmdcbiAgICogYHNsb3RjaGFuZ2VgLlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtOb2RlPX0gZm9yY2VkU2xvdFxuICAgKlxuICAgKi9cbiAgX2Rpc3RyaWJ1dGVOb2RlVG9TbG90KG5vZGUsIGZvcmNlZFNsb3QpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IGVuc3VyZVNoYWR5RGF0YUZvck5vZGUobm9kZSk7XG4gICAgbGV0IG9sZFNsb3QgPSBub2RlRGF0YS5fcHJldkFzc2lnbmVkU2xvdDtcbiAgICBub2RlRGF0YS5fcHJldkFzc2lnbmVkU2xvdCA9IG51bGw7XG4gICAgbGV0IHNsb3QgPSBmb3JjZWRTbG90O1xuICAgIGlmICghc2xvdCkge1xuICAgICAgbGV0IG5hbWUgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdzbG90J10gfHwgQ0FUQ0hBTExfTkFNRTtcbiAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLl9zbG90TWFwW25hbWVdO1xuICAgICAgc2xvdCA9IGxpc3QgJiYgbGlzdFswXTtcbiAgICB9XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGNvbnN0IHNsb3REYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZShzbG90KTtcbiAgICAgIHNsb3REYXRhLmFzc2lnbmVkTm9kZXMucHVzaChub2RlKTtcbiAgICAgIG5vZGVEYXRhLmFzc2lnbmVkU2xvdCA9IHNsb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGVEYXRhLmFzc2lnbmVkU2xvdCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKG9sZFNsb3QgIT09IG5vZGVEYXRhLmFzc2lnbmVkU2xvdCkge1xuICAgICAgaWYgKG5vZGVEYXRhLmFzc2lnbmVkU2xvdCkge1xuICAgICAgICBlbnN1cmVTaGFkeURhdGFGb3JOb2RlKG5vZGVEYXRhLmFzc2lnbmVkU2xvdCkuZGlydHkgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgdGhlIGFzc2lnbmVkTm9kZXMgdHJhY2tpbmcgZGF0YSBmb3IgYSBnaXZlbiBgc2xvdGAuIE5vdGUsIHRoZSBjdXJyZW50XG4gICAqIGFzc2lnbmVkIG5vZGUgZGF0YSBpcyB0cmFja2VkICh2aWEgX3ByZXZpb3VzbHlBc3NpZ25lZE5vZGVzIGFuZFxuICAgKiBfcHJldkFzc2lnbmVkU2xvdCkgdG8gc2VlIGlmIGBzbG90Y2hhbmdlYCBzaG91bGQgZmlyZS4gVGhpcyBkYXRhIG1heSBiZSBvdXRcbiAgICogIG9mIGRhdGUgYXQgdGhpcyB0aW1lIGJlY2F1c2UgdGhlIGFzc2lnbmVkIG5vZGVzIG1heSBoYXZlIGFscmVhZHkgYmVlblxuICAgKiBkaXN0cmlidXRlZCB0byBhbm90aGVyIHJvb3QuIFRoaXMgaXMgb2sgc2luY2UgdGhpcyBkYXRhIGlzIG9ubHkgdXNlZCB0b1xuICAgKiB0cmFjayBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge0hUTUxTbG90RWxlbWVudH0gc2xvdFxuICAgKi9cbiAgX2NsZWFyU2xvdEFzc2lnbmVkTm9kZXMoc2xvdCkge1xuICAgIGNvbnN0IHNsb3REYXRhID0gc2hhZHlEYXRhRm9yTm9kZShzbG90KTtcbiAgICBsZXQgbiQgPSBzbG90RGF0YS5hc3NpZ25lZE5vZGVzO1xuICAgIHNsb3REYXRhLmFzc2lnbmVkTm9kZXMgPSBbXTtcbiAgICBzbG90RGF0YS5mbGF0dGVuZWROb2RlcyA9IFtdO1xuICAgIHNsb3REYXRhLl9wcmV2aW91c2x5QXNzaWduZWROb2RlcyA9IG4kO1xuICAgIGlmIChuJCkge1xuICAgICAgZm9yIChsZXQgaT0wOyBpIDwgbiQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IG4gPSBzaGFkeURhdGFGb3JOb2RlKG4kW2ldKTtcbiAgICAgICAgbi5fcHJldkFzc2lnbmVkU2xvdCA9IG4uYXNzaWduZWRTbG90O1xuICAgICAgICAvLyBvbmx5IGNsZWFyIGlmIGl0IHdhcyBwcmV2aW91c2x5IHNldCB0byB0aGlzIHNsb3Q7XG4gICAgICAgIC8vIHRoaXMgaGVscHMgZW5zdXJlIHRoYXQgaWYgdGhlIG5vZGUgaGFzIG90aGVyd2lzZSBiZWVuIGRpc3RyaWJ1dGVkXG4gICAgICAgIC8vIGlnbm9yZSBpdC5cbiAgICAgICAgaWYgKG4uYXNzaWduZWRTbG90ID09PSBzbG90KSB7XG4gICAgICAgICAgbi5hc3NpZ25lZFNsb3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2FkZEFzc2lnbmVkVG9GbGF0dGVuZWROb2RlcyhmbGF0dGVuZWQsIGFzc2lnbmVkKSB7XG4gICAgZm9yIChsZXQgaT0wLCBuOyAoaTxhc3NpZ25lZC5sZW5ndGgpICYmIChuPWFzc2lnbmVkW2ldKTsgaSsrKSB7XG4gICAgICBpZiAobi5sb2NhbE5hbWUgPT0gJ3Nsb3QnKSB7XG4gICAgICAgIGNvbnN0IG5lc3RlZEFzc2lnbmVkID0gc2hhZHlEYXRhRm9yTm9kZShuKS5hc3NpZ25lZE5vZGVzO1xuICAgICAgICBpZiAobmVzdGVkQXNzaWduZWQgJiYgbmVzdGVkQXNzaWduZWQubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fYWRkQXNzaWduZWRUb0ZsYXR0ZW5lZE5vZGVzKGZsYXR0ZW5lZCwgbmVzdGVkQXNzaWduZWQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbGF0dGVuZWQucHVzaChhc3NpZ25lZFtpXSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgX2ZpcmVTbG90Q2hhbmdlKHNsb3QpIHtcbiAgICAvLyBOT1RFOiBjYW5ub3QgYnViYmxlIGNvcnJlY3RseSBoZXJlIHNvIG5vdCBzZXR0aW5nIGJ1YmJsZXM6IHRydWVcbiAgICAvLyBTYWZhcmkgdGVjaCBwcmV2aWV3IGRvZXMgbm90IGJ1YmJsZSBidXQgY2hyb21lIGRvZXNcbiAgICAvLyBTcGVjIHNheXMgaXQgYnViYmxlcyAoaHR0cHM6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNtdXRhdGlvbi1vYnNlcnZlcnMpXG4gICAgc2xvdFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ2Rpc3BhdGNoRXZlbnQnXShuZXcgRXZlbnQoJ3Nsb3RjaGFuZ2UnKSk7XG4gICAgY29uc3Qgc2xvdERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3QpO1xuICAgIGlmIChzbG90RGF0YS5hc3NpZ25lZFNsb3QpIHtcbiAgICAgIHRoaXMuX2ZpcmVTbG90Q2hhbmdlKHNsb3REYXRhLmFzc2lnbmVkU2xvdCk7XG4gICAgfVxuICB9XG5cbiAgLy8gUmVpZnkgZG9tIHN1Y2ggdGhhdCBpdCBpcyBhdCBpdHMgY29ycmVjdCByZW5kZXJpbmcgcG9zaXRpb25cbiAgLy8gYmFzZWQgb24gbG9naWNhbCBkaXN0cmlidXRpb24uXG4gIC8vIE5PVEU6IGhlcmUgd2Ugb25seSBjb21wb3NlIHBhcmVudHMgb2YgPHNsb3Q+IGVsZW1lbnRzIGFuZCBub3QgdGhlXG4gIC8vIHNoYWRvd1Jvb3QgaW50byB0aGUgaG9zdC4gVGhlIGxhdHRlciBpcyBwZXJmb3JtZW5kIHZpYSBhIGZhc3QgcGF0aFxuICAvLyBpbiB0aGUgYGxvZ2ljYWwtbXV0YXRpb25gLmluc2VydEJlZm9yZS5cbiAgX2NvbXBvc2UoKSB7XG4gICAgY29uc3Qgc2xvdHMgPSB0aGlzLl9zbG90TGlzdDtcbiAgICBsZXQgY29tcG9zZUxpc3QgPSBbXTtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgcGFyZW50ID0gc2xvdHNbaV1bdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICAgIC8qIGNvbXBvc2Ugbm9kZSBvbmx5IGlmOlxuICAgICAgICAoMSkgcGFyZW50IGRvZXMgbm90IGhhdmUgYSBzaGFkb3dSb290IHNpbmNlIHNoYWRvd1Jvb3QgaGFzIGFscmVhZHlcbiAgICAgICAgY29tcG9zZWQgaW50byB0aGUgaG9zdFxuICAgICAgICAoMikgd2UncmUgbm90IGFscmVhZHkgY29tcG9zaW5nIGl0XG4gICAgICAgIFtjb25zaWRlciAobl4yKSBidXQgcmFyZSBiZXR0ZXIgdGhhbiBTZXRdXG4gICAgICAqL1xuICAgICAgY29uc3QgcGFyZW50RGF0YSA9IHNoYWR5RGF0YUZvck5vZGUocGFyZW50KTtcbiAgICAgIGlmICghKHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5yb290KSAmJlxuICAgICAgICBjb21wb3NlTGlzdC5pbmRleE9mKHBhcmVudCkgPCAwKSB7XG4gICAgICAgIGNvbXBvc2VMaXN0LnB1c2gocGFyZW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChsZXQgaT0wOyBpIDwgY29tcG9zZUxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IG5vZGUgPSBjb21wb3NlTGlzdFtpXTtcbiAgICAgIGNvbnN0IHRhcmdldE5vZGUgPSBub2RlID09PSB0aGlzID8gdGhpcy5ob3N0IDogbm9kZTtcbiAgICAgIHRoaXMuX3VwZGF0ZUNoaWxkTm9kZXModGFyZ2V0Tm9kZSwgdGhpcy5fY29tcG9zZU5vZGUobm9kZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGxpc3Qgb2Ygbm9kZXMgd2hpY2ggc2hvdWxkIGJlIHJlbmRlcmVkIGluc2lkZSBgbm9kZWAuXG4gIF9jb21wb3NlTm9kZShub2RlKSB7XG4gICAgbGV0IGNoaWxkcmVuID0gW107XG4gICAgZm9yIChsZXQgbj1ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdENoaWxkJ107IG47IG4gPSBuW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICAvLyBOb3RlOiBpZiB3ZSBzZWUgYSBzbG90IGhlcmUsIHRoZSBub2RlcyBhcmUgZ3VhcmFudGVlZCB0byBuZWVkIHRvIGJlXG4gICAgICAvLyBjb21wb3NlZCBoZXJlLiBUaGlzIGlzIGJlY2F1c2UgaWYgdGhlcmUgaXMgcmVkaXN0cmlidXRpb24sIGl0IGhhc1xuICAgICAgLy8gYWxyZWFkeSBiZWVuIGhhbmRsZWQgYnkgdGhpcyBwb2ludC5cbiAgICAgIGlmICh0aGlzLl9pc0luc2VydGlvblBvaW50KG4pKSB7XG4gICAgICAgIGxldCBmbGF0dGVuZWROb2RlcyA9IHNoYWR5RGF0YUZvck5vZGUobikuZmxhdHRlbmVkTm9kZXM7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgZmxhdHRlbmVkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICBsZXQgZGlzdHJpYnV0ZWROb2RlID0gZmxhdHRlbmVkTm9kZXNbal07XG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGRpc3RyaWJ1dGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNoaWxkcmVuLnB1c2gobik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGlsZHJlbjtcbiAgfVxuXG4gIF9pc0luc2VydGlvblBvaW50KG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlLmxvY2FsTmFtZSA9PSAnc2xvdCc7XG4gICAgfVxuXG4gIC8vIEVuc3VyZXMgdGhhdCB0aGUgcmVuZGVyZWQgbm9kZSBsaXN0IGluc2lkZSBgY29udGFpbmVyYCBpcyBgY2hpbGRyZW5gLlxuICBfdXBkYXRlQ2hpbGROb2Rlcyhjb250YWluZXIsIGNoaWxkcmVuKSB7XG4gICAgbGV0IGNvbXBvc2VkID0gdXRpbHMubmF0aXZlQ2hpbGROb2Rlc0FycmF5KGNvbnRhaW5lcik7XG4gICAgbGV0IHNwbGljZXMgPSBjYWxjdWxhdGVTcGxpY2VzKGNoaWxkcmVuLCBjb21wb3NlZCk7XG4gICAgLy8gcHJvY2VzcyByZW1vdmFsc1xuICAgIGZvciAobGV0IGk9MCwgZD0wLCBzOyAoaTxzcGxpY2VzLmxlbmd0aCkgJiYgKHM9c3BsaWNlc1tpXSk7IGkrKykge1xuICAgICAgZm9yIChsZXQgaj0wLCBuOyAoaiA8IHMucmVtb3ZlZC5sZW5ndGgpICYmIChuPXMucmVtb3ZlZFtqXSk7IGorKykge1xuICAgICAgICAvLyBjaGVjayBpZiB0aGUgbm9kZSBpcyBzdGlsbCB3aGVyZSB3ZSBleHBlY3QgaXQgaXMgYmVmb3JlIHRyeWluZ1xuICAgICAgICAvLyB0byByZW1vdmUgaXQ7IHRoaXMgY2FuIGhhcHBlbiBpZiB3ZSBtb3ZlIGEgbm9kZSBhbmRcbiAgICAgICAgLy8gdGhlbiBzY2hlZHVsZSBpdHMgcHJldmlvdXMgaG9zdCBmb3IgZGlzdHJpYnV0aW9uIHJlc3VsdGluZyBpblxuICAgICAgICAvLyB0aGUgbm9kZSBiZWluZyByZW1vdmVkIGhlcmUuXG4gICAgICAgIGlmIChuW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncGFyZW50Tm9kZSddID09PSBjb250YWluZXIpIHtcbiAgICAgICAgICBjb250YWluZXJbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVDaGlsZCddKG4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oc29ydmVsbCk6IGF2b2lkIHRoZSBuZWVkIGZvciBzcGxpY2luZyBoZXJlLlxuICAgICAgICBjb21wb3NlZC5zcGxpY2Uocy5pbmRleCArIGQsIDEpO1xuICAgICAgfVxuICAgICAgZCAtPSBzLmFkZGVkQ291bnQ7XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgYWRkc1xuICAgIGZvciAobGV0IGk9MCwgcywgbmV4dDsgKGk8c3BsaWNlcy5sZW5ndGgpICYmIChzPXNwbGljZXNbaV0pOyBpKyspIHsgLy9lc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlZGVjbGFyZVxuICAgICAgbmV4dCA9IGNvbXBvc2VkW3MuaW5kZXhdO1xuICAgICAgZm9yIChsZXQgaj1zLmluZGV4LCBuOyBqIDwgcy5pbmRleCArIHMuYWRkZWRDb3VudDsgaisrKSB7XG4gICAgICAgIG4gPSBjaGlsZHJlbltqXTtcbiAgICAgICAgY29udGFpbmVyW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10obiwgbmV4dCk7XG4gICAgICAgIGNvbXBvc2VkLnNwbGljZShqLCAwLCBuKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBfZW5zdXJlU2xvdERhdGEoKSB7XG4gICAgdGhpcy5fcGVuZGluZ1Nsb3RzID0gdGhpcy5fcGVuZGluZ1Nsb3RzIHx8IFtdO1xuICAgIHRoaXMuX3Nsb3RMaXN0ID0gdGhpcy5fc2xvdExpc3QgfHwgW107XG4gICAgdGhpcy5fc2xvdE1hcCA9IHRoaXMuX3Nsb3RNYXAgfHwge307XG4gIH1cblxuICBfYWRkU2xvdHMoc2xvdHMpIHtcbiAgICB0aGlzLl9lbnN1cmVTbG90RGF0YSgpO1xuICAgIHRoaXMuX3BlbmRpbmdTbG90cy5wdXNoKC4uLnNsb3RzKTtcbiAgfVxuXG4gIF92YWxpZGF0ZVNsb3RzKCkge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nU2xvdHMgJiYgdGhpcy5fcGVuZGluZ1Nsb3RzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbWFwU2xvdHModGhpcy5fcGVuZGluZ1Nsb3RzKTtcbiAgICAgIHRoaXMuX3BlbmRpbmdTbG90cyA9IFtdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIHRoZSBnaXZlbiBzbG90cy4gU2xvdHMgYXJlIG1haW50YWluZWQgaW4gYW4gZG9tLW9yZGVyZWQgbGlzdC5cbiAgICogSW4gYWRkaXRpb24gYSBtYXAgb2YgbmFtZSB0byBzbG90IGlzIHVwZGF0ZWQuXG4gICAqL1xuICBfbWFwU2xvdHMoc2xvdHMpIHtcbiAgICBsZXQgc2xvdE5hbWVzVG9Tb3J0O1xuICAgIGZvciAobGV0IGk9MDsgaSA8IHNsb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBzbG90ID0gc2xvdHNbaV07XG4gICAgICAvLyBlbnN1cmUgaW5zZXJ0aW9uUG9pbnRzJ3MgYW5kIHRoZWlyIHBhcmVudHMgaGF2ZSBsb2dpY2FsIGRvbSBpbmZvLlxuICAgICAgLy8gc2F2ZSBsb2dpY2FsIHRyZWUgaW5mb1xuICAgICAgLy8gYS4gZm9yIHNoYWR5Um9vdFxuICAgICAgLy8gYi4gZm9yIGluc2VydGlvbiBwb2ludHMgKGZhbGxiYWNrKVxuICAgICAgLy8gYy4gZm9yIHBhcmVudHMgb2YgaW5zZXJ0aW9uIHBvaW50c1xuICAgICAgcmVjb3JkQ2hpbGROb2RlcyhzbG90KTtcbiAgICAgIGNvbnN0IHNsb3RQYXJlbnQgPSBzbG90W3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ107XG4gICAgICByZWNvcmRDaGlsZE5vZGVzKHNsb3RQYXJlbnQpO1xuICAgICAgY29uc3Qgc2xvdFBhcmVudERhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHNsb3RQYXJlbnQpO1xuICAgICAgc2xvdFBhcmVudERhdGEuX19jaGlsZFNsb3RDb3VudCA9IChzbG90UGFyZW50RGF0YS5fX2NoaWxkU2xvdENvdW50IHx8IDApICsgMTtcbiAgICAgIGxldCBuYW1lID0gdGhpcy5fbmFtZUZvclNsb3Qoc2xvdCk7XG4gICAgICBpZiAodGhpcy5fc2xvdE1hcFtuYW1lXSkge1xuICAgICAgICBzbG90TmFtZXNUb1NvcnQgPSBzbG90TmFtZXNUb1NvcnQgfHwge307XG4gICAgICAgIHNsb3ROYW1lc1RvU29ydFtuYW1lXSA9IHRydWU7XG4gICAgICAgIHRoaXMuX3Nsb3RNYXBbbmFtZV0ucHVzaChzbG90KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3Nsb3RNYXBbbmFtZV0gPSBbc2xvdF07XG4gICAgICB9XG4gICAgICB0aGlzLl9zbG90TGlzdC5wdXNoKHNsb3QpO1xuICAgIH1cbiAgICBpZiAoc2xvdE5hbWVzVG9Tb3J0KSB7XG4gICAgICBmb3IgKGxldCBuIGluIHNsb3ROYW1lc1RvU29ydCkge1xuICAgICAgICB0aGlzLl9zbG90TWFwW25dID0gdGhpcy5fc29ydFNsb3RzKHRoaXMuX3Nsb3RNYXBbbl0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIF9uYW1lRm9yU2xvdChzbG90KSB7XG4gICAgY29uc3QgbmFtZSA9IHNsb3RbJ25hbWUnXSB8fCBzbG90LmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8IENBVENIQUxMX05BTUU7XG4gICAgc2xvdC5fX3Nsb3ROYW1lID0gbmFtZTtcbiAgICByZXR1cm4gbmFtZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTbG90cyBhcmUga2VwdCBpbiBhbiBvcmRlcmVkIGxpc3QuIFNsb3RzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgKiBhcmUgc29ydGVkIGhlcmUgYnkgdHJlZSBvcmRlci5cbiAgICovXG4gIF9zb3J0U2xvdHMoc2xvdHMpIHtcbiAgICAvLyBOT1RFOiBDYW5ub3QgdXNlIGBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbmAgYmVjYXVzZSBpdCdzIG5vdCBwb2x5ZmlsbGVkLFxuICAgIC8vIGJ1dCB0aGUgY29kZSBoZXJlIGNvdWxkIGJlIHVzZWQgdG8gcG9seWZpbGwgdGhlIHByZWNlZWRpbmcvZm9sbG93aW5nIGluZm9cbiAgICAvLyBpbiBgY29tcGFyZURvY3VtZW50UG9zaXRpb25gLlxuICAgIHJldHVybiBzbG90cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBsZXQgbGlzdEEgPSBhbmNlc3Rvckxpc3QoYSk7XG4gICAgICBsZXQgbGlzdEIgPSBhbmNlc3Rvckxpc3QoYik7XG4gICAgICBmb3IgKHZhciBpPTA7IGkgPCBsaXN0QS5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbkEgPSBsaXN0QVtpXTtcbiAgICAgICAgbGV0IG5CID0gbGlzdEJbaV07XG4gICAgICAgIGlmIChuQSAhPT0gbkIpIHtcbiAgICAgICAgICBsZXQgYyQgPSB1dGlscy5jaGlsZE5vZGVzQXJyYXkobkFbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudE5vZGUnXSk7XG4gICAgICAgICAgcmV0dXJuIGMkLmluZGV4T2YobkEpIC0gYyQuaW5kZXhPZihuQik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGZyb20gdHJhY2tlZCBzbG90IGRhdGEgYW55IHNsb3RzIGNvbnRhaW5lZCB3aXRoaW4gYGNvbnRhaW5lcmAgYW5kXG4gICAqIHRoZW4gdXBkYXRlcyB0aGUgdHJhY2tlZCBkYXRhIChfc2xvdExpc3QgYW5kIF9zbG90TWFwKS5cbiAgICogQW55IHJlbW92ZWQgc2xvdHMgYWxzbyBoYXZlIHRoZWlyIGBhc3NpZ25lZE5vZGVzYCByZW1vdmVkIGZyb20gY29tb3BzZWQgZG9tLlxuICAgKi9cbiAgX3JlbW92ZUNvbnRhaW5lZFNsb3RzKGNvbnRhaW5lcikge1xuICAgIGlmICghdGhpcy5fc2xvdExpc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fdmFsaWRhdGVTbG90cygpO1xuICAgIGxldCBkaWRSZW1vdmU7XG4gICAgY29uc3QgbWFwID0gdGhpcy5fc2xvdE1hcDtcbiAgICBmb3IgKGxldCBuIGluIG1hcCkge1xuICAgICAgY29uc3Qgc2xvdHMgPSBtYXBbbl07XG4gICAgICBmb3IgKGxldCBpPTA7IGkgPCBzbG90cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBzbG90ID0gc2xvdHNbaV07XG4gICAgICAgIGlmICh1dGlscy5jb250YWlucyhjb250YWluZXIsIHNsb3QpKSB7XG4gICAgICAgICAgc2xvdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgIGNvbnN0IHggPSB0aGlzLl9zbG90TGlzdC5pbmRleE9mKHNsb3QpO1xuICAgICAgICAgIGlmICh4ID49IDApIHtcbiAgICAgICAgICAgIHRoaXMuX3Nsb3RMaXN0LnNwbGljZSh4LCAxKTtcbiAgICAgICAgICAgIGNvbnN0IHNsb3RQYXJlbnREYXRhID0gc2hhZHlEYXRhRm9yTm9kZShzbG90W3V0aWxzLlNIQURZX1BSRUZJWCArICdwYXJlbnROb2RlJ10pO1xuICAgICAgICAgICAgaWYgKHNsb3RQYXJlbnREYXRhICYmIHNsb3RQYXJlbnREYXRhLl9fY2hpbGRTbG90Q291bnQpIHtcbiAgICAgICAgICAgICAgc2xvdFBhcmVudERhdGEuX19jaGlsZFNsb3RDb3VudC0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpLS07XG4gICAgICAgICAgdGhpcy5fcmVtb3ZlRmxhdHRlbmVkTm9kZXMoc2xvdCk7XG4gICAgICAgICAgZGlkUmVtb3ZlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGlkUmVtb3ZlO1xuICB9XG5cbiAgX3VwZGF0ZVNsb3ROYW1lKHNsb3QpIHtcbiAgICBpZiAoIXRoaXMuX3Nsb3RMaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG1ha2Ugc3VyZSBzbG90TWFwIGlzIGluaXRpYWxpemVkIHdpdGggdGhpcyBzbG90XG4gICAgdGhpcy5fdmFsaWRhdGVTbG90cygpO1xuICAgIGNvbnN0IG9sZE5hbWUgPSBzbG90Ll9fc2xvdE5hbWU7XG4gICAgY29uc3QgbmFtZSA9IHRoaXMuX25hbWVGb3JTbG90KHNsb3QpO1xuICAgIGlmIChuYW1lID09PSBvbGROYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJlbW92ZSBmcm9tIGV4aXN0aW5nIHRyYWNraW5nXG4gICAgbGV0IHNsb3RzID0gdGhpcy5fc2xvdE1hcFtvbGROYW1lXTtcbiAgICBjb25zdCBpID0gc2xvdHMuaW5kZXhPZihzbG90KTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICBzbG90cy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIC8vIGFkZCB0byBuZXcgbG9jYXRpb24gYW5kIHNvcnQgaWYgbmVkZXNzYXJ5XG4gICAgbGV0IGxpc3QgPSB0aGlzLl9zbG90TWFwW25hbWVdIHx8ICh0aGlzLl9zbG90TWFwW25hbWVdID0gW10pO1xuICAgIGxpc3QucHVzaChzbG90KTtcbiAgICBpZiAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICB0aGlzLl9zbG90TWFwW25hbWVdID0gdGhpcy5fc29ydFNsb3RzKGxpc3QpO1xuICAgIH1cbiAgfVxuXG4gIF9yZW1vdmVGbGF0dGVuZWROb2RlcyhzbG90KSB7XG4gICAgY29uc3QgZGF0YSA9IHNoYWR5RGF0YUZvck5vZGUoc2xvdCk7XG4gICAgbGV0IG4kID0gZGF0YS5mbGF0dGVuZWROb2RlcztcbiAgICBpZiAobiQpIHtcbiAgICAgIGZvciAobGV0IGk9MDsgaTxuJC5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgbm9kZSA9IG4kW2ldO1xuICAgICAgICBsZXQgcGFyZW50ID0gbm9kZVt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3BhcmVudE5vZGUnXTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIHBhcmVudFt1dGlscy5OQVRJVkVfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZGF0YS5mbGF0dGVuZWROb2RlcyA9IFtdO1xuICAgIGRhdGEuYXNzaWduZWROb2RlcyA9IFtdO1xuICB9XG5cbiAgX2hhc0luc2VydGlvblBvaW50KCkge1xuICAgIHRoaXMuX3ZhbGlkYXRlU2xvdHMoKTtcbiAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9zbG90TGlzdCAmJiB0aGlzLl9zbG90TGlzdC5sZW5ndGgpO1xuICB9XG59XG5cbnBhdGNoU2hhZHlSb290KFNoYWR5Um9vdC5wcm90b3R5cGUpO1xuZXhwb3J0IHtTaGFkeVJvb3R9O1xuXG4vKipcbiAgSW1wbGVtZW50cyBhIHBhcmVkIGRvd24gdmVyc2lvbiBvZiBTaGFkb3dET00ncyBzY29waW5nLCB3aGljaCBpcyBlYXN5IHRvXG4gIHBvbHlmaWxsIGFjcm9zcyBicm93c2Vycy5cbiovXG5leHBvcnQgY29uc3QgYXR0YWNoU2hhZG93ID0gKGhvc3QsIG9wdGlvbnMpID0+IHtcbiAgaWYgKCFob3N0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IHByb3ZpZGUgYSBob3N0LicpO1xuICB9XG4gIGlmICghb3B0aW9ucykge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGVub3VnaCBhcmd1bWVudHMuJyk7XG4gIH1cbiAgbGV0IHJvb3Q7XG4gIC8vIE9wdGltaXphdGlvbiBmb3IgYm9vdGluZyB1cCBhIHNoYWRvd1Jvb3QgZnJvbSBhIGZyYWdtZW50IHJhdGhlciB0aGFuXG4gIC8vIGNyZWF0aW5nIG9uZS5cbiAgaWYgKG9wdGlvbnNbJ3NoYWR5VXBncmFkZUZyYWdtZW50J10gJiYgdXRpbHMuY2FuVXBncmFkZSgpKSB7XG4gICAgcm9vdCA9IG9wdGlvbnNbJ3NoYWR5VXBncmFkZUZyYWdtZW50J107XG4gICAgcm9vdC5fX3Byb3RvX18gPSBTaGFkb3dSb290LnByb3RvdHlwZTtcbiAgICByb290Ll9pbml0KGhvc3QsIG9wdGlvbnMpO1xuICAgIHJlY29yZENoaWxkTm9kZXMocm9vdCwgcm9vdCk7XG4gICAgLy8gTm90ZTogcXNhIGlzIG5hdGl2ZSB3aGVuIHVzZWQgd2l0aCBub1BhdGNoLlxuICAgIC8qKiBAdHlwZSB7P05vZGVMaXN0PEVsZW1lbnQ+fSAqL1xuICAgIGNvbnN0IHNsb3RzQWRkZWQgPSByb290WydfX25vSW5zZXJ0aW9uUG9pbnQnXSA/IG51bGwgOiByb290LnF1ZXJ5U2VsZWN0b3JBbGwoJ3Nsb3QnKTtcbiAgICAvLyBSZXNldCBzY29waW5nIGluZm9ybWF0aW9uIHNvIG5vcm1hbCBzY29pbmcgcnVsZXMgYXBwbHkgYWZ0ZXIgdGhpcy5cbiAgICByb290WydfX25vSW5zZXJ0aW9uUG9pbnQnXSA9IHVuZGVmaW5lZDtcbiAgICAvLyBpZiBhIHNsb3QgaXMgYWRkZWQsIG11c3QgcmVuZGVyIGNvbnRhaW5pbmcgcm9vdC5cbiAgICBpZiAoc2xvdHNBZGRlZCAmJiBzbG90c0FkZGVkLmxlbmd0aCkge1xuICAgICAgcm9vdC5fYWRkU2xvdHMoc2xvdHNBZGRlZCk7XG4gICAgICByb290Ll9hc3luY1JlbmRlcigpO1xuICAgIH1cbiAgICAvKiogQHR5cGUge1NoYWRvd1Jvb3R9ICovKHJvb3QpLmhvc3RbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdhcHBlbmRDaGlsZCddKHJvb3QpO1xuICB9IGVsc2Uge1xuICAgIHJvb3QgPSBuZXcgU2hhZHlSb290KFNoYWR5Um9vdENvbnN0cnVjdGlvblRva2VuLCBob3N0LCBvcHRpb25zKTtcbiAgfVxuICByZXR1cm4gcm9vdDtcbn1cblxuLy8gTWl0aWdhdGUgY29ubmVjdC9kaXNjb25uZWN0IHNwYW0gYnkgd3JhcHBpbmcgY3VzdG9tIGVsZW1lbnQgY2xhc3Nlcy5cbmlmICh3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ10gJiYgdXRpbHMuc2V0dGluZ3MuaW5Vc2UgJiYgIXV0aWxzLnNldHRpbmdzWydwcmVmZXJQZXJmb3JtYW5jZSddKSB7XG5cbiAgLy8gcHJvY2VzcyBjb25uZWN0L2Rpc2Nvbm5lY3QgYWZ0ZXIgcm9vdHMgaGF2ZSByZW5kZXJlZCB0byBhdm9pZFxuICAvLyBpc3N1ZXMgd2l0aCByZWFjdGlvbiBzdGFjay5cbiAgbGV0IGNvbm5lY3RNYXAgPSBuZXcgTWFwKCk7XG4gIHJvb3RSZW5kZXJlZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIGFsbG93IGVsZW1lbnRzIHRvIGNvbm5lY3RcbiAgICAvLyBzYXZlIG1hcCBzdGF0ZSAod2l0aG91dCBuZWVkaW5nIHBvbHlmaWxscyBvbiBJRTExKVxuICAgIGNvbnN0IHIgPSBbXTtcbiAgICBjb25uZWN0TWFwLmZvckVhY2goKHYsIGspID0+IHtcbiAgICAgIHIucHVzaChbaywgdl0pO1xuICAgIH0pO1xuICAgIGNvbm5lY3RNYXAuY2xlYXIoKTtcbiAgICBmb3IgKGxldCBpPTA7IGkgPCByLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlID0gcltpXVswXSwgdmFsdWUgPSByW2ldWzFdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGVbJ19fc2hhZHlkb21fY29ubmVjdGVkQ2FsbGJhY2snXSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZVsnX19zaGFkeWRvbV9kaXNjb25uZWN0ZWRDYWxsYmFjayddKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gRG9jdW1lbnQgaXMgaW4gbG9hZGluZyBzdGF0ZSBhbmQgZmxhZyBpcyBzZXQgKGRlZmVyQ29ubmVjdGlvbkNhbGxiYWNrcylcbiAgLy8gc28gcHJvY2VzcyBjb25uZWN0aW9uIHN0YWNrIHdoZW4gYHJlYWR5c3RhdGVjaGFuZ2VgIGZpcmVzLlxuICBpZiAoaXNSZW5kZXJpbmcpIHtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgICAgIHJvb3RSZW5kZXJlZCgpO1xuICAgIH0sIHtvbmNlOiB0cnVlfSk7XG4gIH1cblxuICAvKlxuICAgKiAoMSkgZWxlbWVudHMgY2FuIG9ubHkgYmUgY29ubmVjdGVkL2Rpc2Nvbm5lY3RlZCBpZiB0aGV5IGFyZSBpbiB0aGUgZXhwZWN0ZWRcbiAgICogc3RhdGUuXG4gICAqICgyKSBuZXZlciBydW4gY29ubmVjdC9kaXNjb25uZWN0IGR1cmluZyByZW5kZXJpbmcgdG8gYXZvaWQgcmVhY3Rpb24gc3RhY2sgaXNzdWVzLlxuICAgKi9cbiAgY29uc3QgTWFuYWdlQ29ubmVjdCA9IChiYXNlLCBjb25uZWN0ZWQsIGRpc2Nvbm5lY3RlZCkgPT4ge1xuICAgIGxldCBjb3VudGVyID0gMDtcbiAgICBjb25zdCBjb25uZWN0RmxhZyA9IGBfX2lzQ29ubmVjdGVkJHtjb3VudGVyKyt9YDtcbiAgICBpZiAoY29ubmVjdGVkIHx8IGRpc2Nvbm5lY3RlZCkge1xuXG4gICAgICAvKiogQHRoaXMgeyFIVE1MRWxlbWVudH0gKi9cbiAgICAgIGJhc2UucHJvdG90eXBlLmNvbm5lY3RlZENhbGxiYWNrID0gYmFzZS5wcm90b3R5cGVbJ19fc2hhZHlkb21fY29ubmVjdGVkQ2FsbGJhY2snXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBpZiByZW5kZXJpbmcgZGVmZXIgY29ubmVjdGVkXG4gICAgICAgIC8vIG90aGVyd2lzZSBjb25uZWN0IG9ubHkgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5XG4gICAgICAgIGlmIChpc1JlbmRlcmluZykge1xuICAgICAgICAgIGNvbm5lY3RNYXAuc2V0KHRoaXMsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKCF0aGlzW2Nvbm5lY3RGbGFnXSkge1xuICAgICAgICAgIHRoaXNbY29ubmVjdEZsYWddID0gdHJ1ZTtcbiAgICAgICAgICBpZiAoY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25uZWN0ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLyoqIEB0aGlzIHshSFRNTEVsZW1lbnR9ICovXG4gICAgICBiYXNlLnByb3RvdHlwZS5kaXNjb25uZWN0ZWRDYWxsYmFjayA9IGJhc2UucHJvdG90eXBlWydfX3NoYWR5ZG9tX2Rpc2Nvbm5lY3RlZENhbGxiYWNrJ10gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gaWYgcmVuZGVyaW5nLCBjYW5jZWwgYSBwZW5kaW5nIGNvbm5lY3Rpb24gYW5kIHF1ZXVlIGRpc2Nvbm5lY3QsXG4gICAgICAgIC8vIG90aGVyd2lzZSBkaXNjb25uZWN0IG9ubHkgaWYgYSBjb25uZWN0aW9uIGhhcyBiZWVuIGFsbG93ZWRcbiAgICAgICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBuZWNlc3Nhcnkgb25seSBiZWNhdXNlIGNhbGxpbmcgcmVtb3ZlQ2hpbGRcbiAgICAgICAgICAvLyBvbiBhIG5vZGUgdGhhdCByZXF1aXJlcyBkaXN0cmlidXRpb24gbGVhdmVzIGl0IGluIHRoZSBET00gdHJlZVxuICAgICAgICAgIC8vIHVudGlsIGRpc3RyaWJ1dGlvbi5cbiAgICAgICAgICAvLyBOT1RFOiByZW1lbWJlciB0aGlzIGlzIGNoZWNraW5nIHRoZSBwYXRjaGVkIGlzQ29ubmVjdGVkIHRvIGRldGVybWluZVxuICAgICAgICAgIC8vIGlmIHRoZSBub2RlIGlzIGluIHRoZSBsb2dpY2FsIHRyZWUuXG4gICAgICAgICAgaWYgKCF0aGlzLmlzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICBjb25uZWN0TWFwLnNldCh0aGlzLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKHRoaXNbY29ubmVjdEZsYWddKSB7XG4gICAgICAgICAgdGhpc1tjb25uZWN0RmxhZ10gPSBmYWxzZTtcbiAgICAgICAgICBpZiAoZGlzY29ubmVjdGVkKSB7XG4gICAgICAgICAgICBkaXNjb25uZWN0ZWQuY2FsbCh0aGlzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxuXG4gIGNvbnN0IG9yaWdpbmFsRGVmaW5lID0gd2luZG93WydjdXN0b21FbGVtZW50cyddWydkZWZpbmUnXTtcbiAgY29uc3QgZGVmaW5lID0gZnVuY3Rpb24obmFtZSwgY29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBjb25uZWN0ZWQgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgY29uc3QgZGlzY29ubmVjdGVkID0gY29uc3RydWN0b3IucHJvdG90eXBlLmRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIG9yaWdpbmFsRGVmaW5lLmNhbGwod2luZG93WydjdXN0b21FbGVtZW50cyddLCBuYW1lLFxuICAgICAgICBNYW5hZ2VDb25uZWN0KGNvbnN0cnVjdG9yLCBjb25uZWN0ZWQsIGRpc2Nvbm5lY3RlZCkpO1xuICAgIC8vIHVucGF0Y2ggY29ubmVjdGVkL2Rpc2Nvbm5lY3RlZCBvbiBjbGFzczsgY3VzdG9tIGVsZW1lbnRzIHRlYXJzIHRoaXMgb2ZmXG4gICAgLy8gc28gdGhlIHBhdGNoIGlzIG1haW50YWluZWQsIGJ1dCBpZiB0aGUgdXNlciBjYWxscyB0aGVzZSBtZXRob2RzIGZvclxuICAgIC8vIGUuZy4gdGVzdGluZywgdGhleSB3aWxsIGJlIGFzIGV4cGVjdGVkLlxuICAgIGNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25uZWN0ZWRDYWxsYmFjayA9IGNvbm5lY3RlZDtcbiAgICBjb25zdHJ1Y3Rvci5wcm90b3R5cGUuZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBkaXNjb25uZWN0ZWQ7XG4gIH1cbiAgLy8gTm90ZSwgaXQgd291bGQgYmUgYmV0dGVyIHRvIG9ubHkgcGF0Y2ggdGhlIEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUsXG4gIC8vIGJ1dCBTaGFkeUNTUyBwYXRjaGVzIGRlZmluZSBkaXJlY3RseS5cbiAgd2luZG93LmN1c3RvbUVsZW1lbnRzLmRlZmluZSA9IGRlZmluZTtcbiAgLy8gU3RpbGwgcGF0Y2ggdGhlIHJlZ2lzdHJ5IGRpcmVjdGx5IHNpbmNlIFNhZmFyaSAxMCBsb3NlcyB0aGUgcGF0Y2hcbiAgLy8gdW5sZXNzIHRoaXMgaXMgZG9uZS5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvd1snQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5J10ucHJvdG90eXBlLCAnZGVmaW5lJywge1xuICAgIHZhbHVlOiBkZWZpbmUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKiogQHJldHVybiB7IVNoYWR5Um9vdHx1bmRlZmluZWR9ICovXG5leHBvcnQgY29uc3Qgb3duZXJTaGFkeVJvb3RGb3JOb2RlID0gKG5vZGUpID0+IHtcbiAgbGV0IHJvb3QgPSBub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdnZXRSb290Tm9kZSddKCk7XG4gIGlmICh1dGlscy5pc1NoYWR5Um9vdChyb290KSkge1xuICAgIHJldHVybiByb290O1xuICB9XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7ZXZlbnRQcm9wZXJ0eU5hbWVzfSBmcm9tICcuL3BhdGNoLWV2ZW50cy5qcyc7XG5cbi8qKiBAaW1wbGVtZW50cyB7SVdyYXBwZXJ9ICovXG5jbGFzcyBXcmFwcGVyIHtcblxuICAvKiogQHBhcmFtIHshTm9kZX0gbm9kZSAqL1xuICBjb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgfVxuXG4gIC8vIG5vZGVcbiAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmbiwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2FkZEV2ZW50TGlzdGVuZXInXShuYW1lLCBmbiwgb3B0aW9ucyk7XG4gIH1cblxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGZuLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlRXZlbnRMaXN0ZW5lciddKG5hbWUsIGZuLCBvcHRpb25zKTtcbiAgfVxuXG4gIGFwcGVuZENoaWxkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdhcHBlbmRDaGlsZCddKG5vZGUpO1xuICB9XG5cbiAgaW5zZXJ0QmVmb3JlKG5vZGUsIHJlZl9ub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5zZXJ0QmVmb3JlJ10obm9kZSwgcmVmX25vZGUpO1xuICB9XG5cbiAgcmVtb3ZlQ2hpbGQobm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3JlbW92ZUNoaWxkJ10obm9kZSk7XG4gIH1cblxuICByZXBsYWNlQ2hpbGQobm9kZSwgcmVmX25vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZXBsYWNlQ2hpbGQnXShub2RlLCByZWZfbm9kZSk7XG4gIH1cblxuICBjbG9uZU5vZGUoZGVlcCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Nsb25lTm9kZSddKGRlZXApO1xuICB9XG5cbiAgZ2V0Um9vdE5vZGUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2dldFJvb3ROb2RlJ10ob3B0aW9ucyk7XG4gIH1cblxuICBjb250YWlucyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnY29udGFpbnMnXShub2RlKTtcbiAgfVxuXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdkaXNwYXRjaEV2ZW50J10oZXZlbnQpO1xuICB9XG5cbiAgLy8gZWxlbWVudFxuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3NldEF0dHJpYnV0ZSddKG5hbWUsIHZhbHVlKTtcbiAgfVxuXG4gIC8vIE5PVEU6IG5vdCBuZWVkZWQsIGp1c3QgaGVyZSBmb3IgYmFsYW5jZVxuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdnZXRBdHRyaWJ1dGUnXShuYW1lKTtcbiAgfVxuXG4gIC8vIE5PVEU6IG5vdCBuZWVkZWQsIGp1c3QgaGVyZSBmb3IgYmFsYW5jZVxuICBoYXNBdHRyaWJ1dGUobmFtZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdoYXNBdHRyaWJ1dGUnXShuYW1lKTtcbiAgfVxuXG4gIHJlbW92ZUF0dHJpYnV0ZShuYW1lKSB7XG4gICAgdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdyZW1vdmVBdHRyaWJ1dGUnXShuYW1lKTtcbiAgfVxuXG4gIGF0dGFjaFNoYWRvdyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnYXR0YWNoU2hhZG93J10ob3B0aW9ucyk7XG4gIH1cblxuICAvKiogQHJldHVybiB7IU5vZGV8dW5kZWZpbmVkfSAqL1xuICBnZXQgYWN0aXZlRWxlbWVudCgpIHtcbiAgICBpZiAodXRpbHMuaXNTaGFkeVJvb3QodGhpcy5ub2RlKSB8fCB0aGlzLm5vZGUubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgY29uc3QgZSA9IHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnYWN0aXZlRWxlbWVudCddO1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbGxlZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIGJyb3dzZXJzIChvbGRlciBDaHJvbWUvU2FmYXJpKSB0aGF0IGRvXG4gICAqIG5vdCBoYXZlIGEgY29uZmlndXJhYmxlIGBhY3RpdmVFbGVtZW50YCBhY2Nlc3Nvci4gRW5hYmxlcyBub1BhdGNoIGFuZFxuICAgKiBwYXRjaCBtb2RlIGJvdGggdG8gY29uc2lzdGVudGx5IHVzZSBTaGFkeURPTS53cmFwKGRvY3VtZW50KS5fYWN0aXZlRWxlbWVudC5cbiAgICogQG92ZXJyaWRlXG4gICAqIEByZXR1cm4geyFOb2RlfHVuZGVmaW5lZH1cbiAgICovXG4gIGdldCBfYWN0aXZlRWxlbWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5hY3RpdmVFbGVtZW50O1xuICB9XG5cbiAgLy8gTk9URTogbm90IG5lZWRlZCwganVzdCBoZXJlIGZvciBiYWxhbmNlXG4gIC8qKiBAb3ZlcnJpZGUgKi9cbiAgZm9jdXMoKSB7XG4gICAgdGhpcy5ub2RlW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnZm9jdXMnXSgpO1xuICB9XG5cbiAgYmx1cigpIHtcbiAgICB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2JsdXInXSgpO1xuICB9XG5cbiAgLy8gZG9jdW1lbnRcbiAgaW1wb3J0Tm9kZShub2RlLCBkZWVwKSB7XG4gICAgaWYgKHRoaXMubm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5ET0NVTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdpbXBvcnROb2RlJ10obm9kZSwgZGVlcCk7XG4gICAgfVxuICB9XG5cbiAgZ2V0RWxlbWVudEJ5SWQoaWQpIHtcbiAgICBpZiAodGhpcy5ub2RlLm5vZGVUeXBlID09PSBOb2RlLkRPQ1VNRU5UX05PREUpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2dldEVsZW1lbnRCeUlkJ10oaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHF1ZXJ5XG4gIHF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdxdWVyeVNlbGVjdG9yJ10oc2VsZWN0b3IpO1xuICB9XG5cbiAgcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvciwgdXNlTmF0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncXVlcnlTZWxlY3RvckFsbCddKHNlbGVjdG9yLCB1c2VOYXRpdmUpO1xuICB9XG5cbiAgLy8gc2xvdFxuICBhc3NpZ25lZE5vZGVzKG9wdGlvbnMpIHtcbiAgICBpZiAodGhpcy5ub2RlLmxvY2FsTmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdhc3NpZ25lZE5vZGVzJ10ob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgZ2V0IGhvc3QoKSB7XG4gICAgaWYgKHV0aWxzLmlzU2hhZHlSb290KHRoaXMubm9kZSkpIHtcbiAgICAgIHJldHVybiAvKiogQHR5cGUgeyFTaGFkb3dSb290fSAqLyh0aGlzLm5vZGUpLmhvc3Q7XG4gICAgfVxuICB9XG5cbiAgZ2V0IHBhcmVudE5vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICB9XG5cbiAgZ2V0IGZpcnN0Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZCddO1xuICB9XG5cbiAgZ2V0IGxhc3RDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdsYXN0Q2hpbGQnXTtcbiAgfVxuXG4gIGdldCBuZXh0U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddO1xuICB9XG5cbiAgZ2V0IHByZXZpb3VzU2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgfVxuXG4gIGdldCBjaGlsZE5vZGVzKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkTm9kZXMnXTtcbiAgfVxuXG4gIGdldCBwYXJlbnRFbGVtZW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3BhcmVudEVsZW1lbnQnXTtcbiAgfVxuXG4gIGdldCBmaXJzdEVsZW1lbnRDaGlsZCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdmaXJzdEVsZW1lbnRDaGlsZCddO1xuICB9XG5cbiAgZ2V0IGxhc3RFbGVtZW50Q2hpbGQoKSB7XG4gICAgcmV0dXJuIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnbGFzdEVsZW1lbnRDaGlsZCddO1xuICB9XG5cbiAgZ2V0IG5leHRFbGVtZW50U2libGluZygpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0RWxlbWVudFNpYmxpbmcnXTtcbiAgfVxuXG4gIGdldCBwcmV2aW91c0VsZW1lbnRTaWJsaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzRWxlbWVudFNpYmxpbmcnXTtcbiAgfVxuXG4gIGdldCBjaGlsZHJlbigpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdjaGlsZHJlbiddO1xuICB9XG5cbiAgZ2V0IGNoaWxkRWxlbWVudENvdW50KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NoaWxkRWxlbWVudENvdW50J107XG4gIH1cblxuICBnZXQgc2hhZG93Um9vdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdzaGFkb3dSb290J107XG4gIH1cblxuICBnZXQgYXNzaWduZWRTbG90KCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2Fzc2lnbmVkU2xvdCddO1xuICB9XG5cbiAgZ2V0IGlzQ29ubmVjdGVkKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2lzQ29ubmVjdGVkJ107XG4gIH1cblxuICBnZXQgaW5uZXJIVE1MKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2lubmVySFRNTCddO1xuICB9XG5cbiAgc2V0IGlubmVySFRNTCh2YWx1ZSkge1xuICAgIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnaW5uZXJIVE1MJ10gPSB2YWx1ZTtcbiAgfVxuXG4gIGdldCB0ZXh0Q29udGVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICd0ZXh0Q29udGVudCddO1xuICB9XG5cbiAgc2V0IHRleHRDb250ZW50KHZhbHVlKSB7XG4gICAgdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICd0ZXh0Q29udGVudCddID0gdmFsdWU7XG4gIH1cblxuICBnZXQgc2xvdCgpIHtcbiAgICByZXR1cm4gdGhpcy5ub2RlW3V0aWxzLlNIQURZX1BSRUZJWCArICdzbG90J107XG4gIH1cblxuICBzZXQgc2xvdCh2YWx1ZSkge1xuICAgIHRoaXMubm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAnc2xvdCddID0gdmFsdWU7XG4gIH1cblxuICBnZXQgY2xhc3NOYW1lKCkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NsYXNzTmFtZSddO1xuICB9XG5cbiAgc2V0IGNsYXNzTmFtZSh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2NsYXNzTmFtZSddID0gdmFsdWU7XG4gIH1cblxufVxuXG5ldmVudFByb3BlcnR5TmFtZXMuZm9yRWFjaChuYW1lID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyYXBwZXIucHJvdG90eXBlLCBuYW1lLCB7XG4gICAgLyoqIEB0aGlzIHtXcmFwcGVyfSAqL1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgbmFtZV07XG4gICAgfSxcbiAgICAvKiogQHRoaXMge1dyYXBwZXJ9ICovXG4gICAgc2V0KHZhbHVlKSB7XG4gICAgICB0aGlzLm5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgbmFtZV0gPSB2YWx1ZTtcbiAgICB9LFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcblxufSk7XG5cbmV4cG9ydCB7V3JhcHBlcn07XG5cbmNvbnN0IHdyYXBwZXJNYXAgPSBuZXcgV2Vha01hcCgpO1xuXG5leHBvcnQgZnVuY3Rpb24gd3JhcChvYmopIHtcbiAgaWYgKHV0aWxzLmlzU2hhZHlSb290KG9iaikgfHwgb2JqIGluc3RhbmNlb2YgV3JhcHBlcikge1xuICAgIHJldHVybiBvYmo7XG4gIH1cbiAgbGV0IHdyYXBwZXIgPSB3cmFwcGVyTWFwLmdldChvYmopXG4gIGlmICghd3JhcHBlcikge1xuICAgIHdyYXBwZXIgPSBuZXcgV3JhcHBlcihvYmopO1xuICAgIHdyYXBwZXJNYXAuc2V0KG9iaiwgd3JhcHBlcik7XG4gIH1cbiAgcmV0dXJuIHdyYXBwZXI7XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5pbXBvcnQge2ZsdXNofSBmcm9tICcuLi9mbHVzaC5qcyc7XG5pbXBvcnQge2FkZEV2ZW50TGlzdGVuZXIsIHJlbW92ZUV2ZW50TGlzdGVuZXJ9IGZyb20gJy4uL3BhdGNoLWV2ZW50cy5qcyc7XG5cbmV4cG9ydCBjb25zdCBFdmVudFRhcmdldFBhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvKiogQHRoaXMge05vZGV9ICovXG4gIGRpc3BhdGNoRXZlbnQoZXZlbnQpIHtcbiAgICBmbHVzaCgpO1xuICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnZGlzcGF0Y2hFdmVudCddKGV2ZW50KTtcbiAgfSxcblxuICBhZGRFdmVudExpc3RlbmVyLFxuXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXJcblxufSk7IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuLi9zaGFkeS1kYXRhLmpzJztcblxuZXhwb3J0IGNvbnN0IFNsb3RhYmxlUGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7Tm9kZX0gKi9cbiAgZ2V0IGFzc2lnbmVkU2xvdCgpIHtcbiAgICAvLyBGb3JjZSBhbnkgcGFyZW50J3Mgc2hhZG93Um9vdCB0byBmbHVzaCBzbyB0aGF0IGRpc3RyaWJ1dGlvbiBvY2N1cnNcbiAgICAvLyBhbmQgdGhpcyBub2RlIGhhcyBhbiBhc3NpZ25lZFNsb3QuXG4gICAgY29uc3QgcGFyZW50ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgIGNvbnN0IG93bmVyUm9vdCA9IHBhcmVudCAmJiBwYXJlbnRbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3NoYWRvd1Jvb3QnXTtcbiAgICBpZiAob3duZXJSb290KSB7XG4gICAgICBvd25lclJvb3QuX3JlbmRlcigpO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgcmV0dXJuIG5vZGVEYXRhICYmIG5vZGVEYXRhLmFzc2lnbmVkU2xvdCB8fCBudWxsO1xuICB9XG5cbn0pO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtzY29wZUNsYXNzQXR0cmlidXRlfSBmcm9tICcuLi9zdHlsZS1zY29waW5nLmpzJztcbmltcG9ydCB7c2hhZHlEYXRhRm9yTm9kZX0gZnJvbSAnLi4vc2hhZHktZGF0YS5qcyc7XG5pbXBvcnQge2F0dGFjaFNoYWRvdywgb3duZXJTaGFkeVJvb3RGb3JOb2RlfSBmcm9tICcuLi9hdHRhY2gtc2hhZG93LmpzJztcblxuY29uc3QgZG9jID0gd2luZG93LmRvY3VtZW50O1xuXG4vKipcbiAqIFNob3VsZCBiZSBjYWxsZWQgd2hlbmV2ZXIgYW4gYXR0cmlidXRlIGNoYW5nZXMuIElmIHRoZSBgc2xvdGAgYXR0cmlidXRlXG4gKiBjaGFuZ2VzLCBwcm92b2tlcyByZW5kZXJpbmcgaWYgbmVjZXNzYXJ5LiBJZiBhIGA8c2xvdD5gIGVsZW1lbnQncyBgbmFtZWBcbiAqIGF0dHJpYnV0ZSBjaGFuZ2VzLCB1cGRhdGVzIHRoZSByb290J3Mgc2xvdCBtYXAgYW5kIHJlbmRlcnMuXG4gKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKi9cbmZ1bmN0aW9uIGRpc3RyaWJ1dGVBdHRyaWJ1dGVDaGFuZ2Uobm9kZSwgbmFtZSkge1xuICBpZiAobmFtZSA9PT0gJ3Nsb3QnKSB7XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZVt1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgIGlmICh1dGlscy5oYXNTaGFkb3dSb290V2l0aFNsb3QocGFyZW50KSkge1xuICAgICAgc2hhZHlEYXRhRm9yTm9kZShwYXJlbnQpLnJvb3QuX2FzeW5jUmVuZGVyKCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKG5vZGUubG9jYWxOYW1lID09PSAnc2xvdCcgJiYgbmFtZSA9PT0gJ25hbWUnKSB7XG4gICAgbGV0IHJvb3QgPSBvd25lclNoYWR5Um9vdEZvck5vZGUobm9kZSk7XG4gICAgaWYgKHJvb3QpIHtcbiAgICAgIHJvb3QuX3VwZGF0ZVNsb3ROYW1lKG5vZGUpO1xuICAgICAgcm9vdC5fYXN5bmNSZW5kZXIoKTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IEVsZW1lbnRQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgcHJldmlvdXNFbGVtZW50U2libGluZygpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgaWYgKG5vZGVEYXRhICYmIG5vZGVEYXRhLnByZXZpb3VzU2libGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbiA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzU2libGluZyddO1xuICAgICAgd2hpbGUgKG4gJiYgbi5ub2RlVHlwZSAhPT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgbiA9IG5bdXRpbHMuU0hBRFlfUFJFRklYICsgJ3ByZXZpb3VzU2libGluZyddO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG47XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAncHJldmlvdXNFbGVtZW50U2libGluZyddO1xuICAgIH1cbiAgfSxcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBuZXh0RWxlbWVudFNpYmxpbmcoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGlmIChub2RlRGF0YSAmJiBub2RlRGF0YS5uZXh0U2libGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgbiA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ25leHRTaWJsaW5nJ107XG4gICAgICB3aGlsZSAobiAmJiBuLm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICBuID0gblt1dGlscy5TSEFEWV9QUkVGSVggKyAnbmV4dFNpYmxpbmcnXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ25leHRFbGVtZW50U2libGluZyddO1xuICAgIH1cbiAgfSxcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBzbG90KCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnc2xvdCcpO1xuICB9LFxuXG4gIC8qKiBAdGhpcyB7RWxlbWVudH0gKi9cbiAgc2V0IHNsb3QodmFsdWUpIHtcbiAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdzZXRBdHRyaWJ1dGUnXSgnc2xvdCcsIHZhbHVlKTtcbiAgfSxcblxuICAvLyBOb3RlOiBDYW4gYmUgcGF0Y2hlZCBvbiBlbGVtZW50IHByb3RvdHlwZSBvbiBhbGwgYnJvd3NlcnMuXG4gIC8vIE11c3QgYmUgcGF0Y2hlZCBvbiBpbnN0YW5jZSBvbiBicm93c2VycyB0aGF0IHN1cHBvcnQgbmF0aXZlIFNoYWRvdyBET01cbiAgLy8gYnV0IGRvIG5vdCBoYXZlIGJ1aWx0aW4gYWNjZXNzb3JzIChvbGQgQ2hyb21lKS5cbiAgLyoqIEB0aGlzIHtFbGVtZW50fSAqL1xuICBnZXQgc2hhZG93Um9vdCgpIHtcbiAgICBjb25zdCBub2RlRGF0YSA9IHNoYWR5RGF0YUZvck5vZGUodGhpcyk7XG4gICAgcmV0dXJuIG5vZGVEYXRhICYmIG5vZGVEYXRhLnB1YmxpY1Jvb3QgfHwgbnVsbDtcbiAgfSxcblxuICAvKiogQHRoaXMge0VsZW1lbnR9ICovXG4gIGdldCBjbGFzc05hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXQgY2xhc3NOYW1lKHZhbHVlKSB7XG4gICAgdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnc2V0QXR0cmlidXRlJ10oJ2NsYXNzJywgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHtzdHJpbmd9IGF0dHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUoYXR0ciwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5vd25lckRvY3VtZW50ICE9PSBkb2MpIHtcbiAgICAgIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdzZXRBdHRyaWJ1dGUnXShhdHRyLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmICghc2NvcGVDbGFzc0F0dHJpYnV0ZSh0aGlzLCBhdHRyLCB2YWx1ZSkpIHtcbiAgICAgIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdzZXRBdHRyaWJ1dGUnXShhdHRyLCB2YWx1ZSk7XG4gICAgICBkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlKHRoaXMsIGF0dHIpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHRoaXMge0VsZW1lbnR9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyXG4gICAqL1xuICByZW1vdmVBdHRyaWJ1dGUoYXR0cikge1xuICAgIHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdyZW1vdmVBdHRyaWJ1dGUnXShhdHRyKTtcbiAgICBkaXN0cmlidXRlQXR0cmlidXRlQ2hhbmdlKHRoaXMsIGF0dHIpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICogQHBhcmFtIHshe21vZGU6IHN0cmluZ319IG9wdGlvbnNcbiAgICovXG4gIGF0dGFjaFNoYWRvdyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIGF0dGFjaFNoYWRvdyh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7ZXZlbnRQcm9wZXJ0eU5hbWVzfSBmcm9tICcuLi9wYXRjaC1ldmVudHMuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlLCBlbnN1cmVTaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuLi9zaGFkeS1kYXRhLmpzJztcblxuZXhwb3J0IGNvbnN0IEhUTUxFbGVtZW50UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8qKiBAdGhpcyB7SFRNTEVsZW1lbnR9ICovXG4gIGJsdXIoKSB7XG4gICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgIGxldCByb290ID0gbm9kZURhdGEgJiYgbm9kZURhdGEucm9vdDtcbiAgICBsZXQgc2hhZG93QWN0aXZlID0gcm9vdCAmJiByb290LmFjdGl2ZUVsZW1lbnQ7XG4gICAgaWYgKHNoYWRvd0FjdGl2ZSkge1xuICAgICAgc2hhZG93QWN0aXZlW3V0aWxzLlNIQURZX1BSRUZJWCArICdibHVyJ10oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1t1dGlscy5OQVRJVkVfUFJFRklYICsgJ2JsdXInXSgpO1xuICAgIH1cbiAgfVxuXG59KTtcblxuZXZlbnRQcm9wZXJ0eU5hbWVzLmZvckVhY2gocHJvcGVydHkgPT4ge1xuICBIVE1MRWxlbWVudFBhdGNoZXNbcHJvcGVydHldID0ge1xuICAgIC8qKiBAdGhpcyB7SFRNTEVsZW1lbnR9ICovXG4gICAgc2V0OiBmdW5jdGlvbihmbikge1xuICAgICAgY29uc3Qgc2hhZHlEYXRhID0gZW5zdXJlU2hhZHlEYXRhRm9yTm9kZSh0aGlzKTtcbiAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IHByb3BlcnR5LnN1YnN0cmluZygyKTtcbiAgICAgIGlmICghc2hhZHlEYXRhLl9fb25DYWxsYmFja0xpc3RlbmVycykge1xuICAgICAgICBzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzID0ge307XG4gICAgICB9XG4gICAgICBzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzW3Byb3BlcnR5XSAmJiB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzW3Byb3BlcnR5XSk7XG4gICAgICB0aGlzW3V0aWxzLlNIQURZX1BSRUZJWCArICdhZGRFdmVudExpc3RlbmVyJ10oZXZlbnROYW1lLCBmbik7XG4gICAgICBzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzW3Byb3BlcnR5XSA9IGZuO1xuICAgIH0sXG4gICAgLyoqIEB0aGlzIHtIVE1MRWxlbWVudH0gKi9cbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBzaGFkeURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgICAgcmV0dXJuIHNoYWR5RGF0YSAmJiBzaGFkeURhdGEuX19vbkNhbGxiYWNrTGlzdGVuZXJzICYmIHNoYWR5RGF0YS5fX29uQ2FsbGJhY2tMaXN0ZW5lcnNbcHJvcGVydHldO1xuICAgIH0sXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH07XG59KTtcblxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi4vdXRpbHMuanMnO1xuaW1wb3J0IHtzaGFkeURhdGFGb3JOb2RlfSBmcm9tICcuLi9zaGFkeS1kYXRhLmpzJztcbmltcG9ydCB7YWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lcn0gZnJvbSAnLi4vcGF0Y2gtZXZlbnRzLmpzJztcblxuZXhwb3J0IGNvbnN0IFNsb3RQYXRjaGVzID0gdXRpbHMuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyh7XG5cbiAgLyoqXG4gICAqIEB0aGlzIHtIVE1MU2xvdEVsZW1lbnR9XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKi9cbiAgYXNzaWduZWROb2RlcyhvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMubG9jYWxOYW1lID09PSAnc2xvdCcpIHtcbiAgICAgIC8vIEZvcmNlIGFueSBjb250YWluaW5nIHNoYWRvd1Jvb3QgdG8gZmx1c2ggc28gdGhhdCBkaXN0cmlidXRpb24gb2NjdXJzXG4gICAgICAvLyBhbmQgdGhpcyBub2RlIGhhcyBhc3NpZ25lZE5vZGVzLlxuICAgICAgY29uc3Qgcm9vdCA9IHRoaXNbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2dldFJvb3ROb2RlJ10oKTtcbiAgICAgIGlmIChyb290ICYmIHV0aWxzLmlzU2hhZHlSb290KHJvb3QpKSB7XG4gICAgICAgIHJvb3QuX3JlbmRlcigpO1xuICAgICAgfVxuICAgICAgY29uc3Qgbm9kZURhdGEgPSBzaGFkeURhdGFGb3JOb2RlKHRoaXMpO1xuICAgICAgcmV0dXJuIG5vZGVEYXRhID9cbiAgICAgICAgKChvcHRpb25zICYmIG9wdGlvbnMuZmxhdHRlbiA/IG5vZGVEYXRhLmZsYXR0ZW5lZE5vZGVzIDpcbiAgICAgICAgICBub2RlRGF0YS5hc3NpZ25lZE5vZGVzKSB8fCBbXSkgOlxuICAgICAgICBbXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtIVE1MU2xvdEVsZW1lbnR9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSBvcHRpb25zT3JDYXB0dXJlXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gICAgLy8gTk9URSwgY2hlY2sgaWYgdGhpcyBpcyBhIGBzbG90YCBiZWNhdXNlIHRoZXNlIHBhdGNoZXMgYXJlIGluc3RhbGxlZCBvblxuICAgIC8vIEVsZW1lbnQgd2hlcmUgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBgPHNsb3Q+YFxuICAgIGlmICh0aGlzLmxvY2FsTmFtZSAhPT0gJ3Nsb3QnIHx8IHR5cGUgPT09ICdzbG90Y2hhbmdlJykge1xuICAgICAgYWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYXB0dXJlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zT3JDYXB0dXJlID0ge1xuICAgICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkeURPTSBjYW5ub3QgYXR0YWNoIGV2ZW50IHRvIHNsb3QgdW5sZXNzIGl0IGhhcyBhIGBwYXJlbnROb2RlYCcpO1xuICAgICAgfVxuICAgICAgb3B0aW9uc09yQ2FwdHVyZS5fX3NoYWR5VGFyZ2V0ID0gdGhpcztcbiAgICAgIHBhcmVudFt1dGlscy5TSEFEWV9QUkVGSVggKyAnYWRkRXZlbnRMaXN0ZW5lciddKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEB0aGlzIHtIVE1MU2xvdEVsZW1lbnR9XG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gICAqIEBwYXJhbSB7T2JqZWN0fGJvb2xlYW49fSBvcHRpb25zT3JDYXB0dXJlXG4gICAqL1xuICByZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKSB7XG4gICAgLy8gTk9URSwgY2hlY2sgaWYgdGhpcyBpcyBhIGBzbG90YCBiZWNhdXNlIHRoZXNlIHBhdGNoZXMgYXJlIGluc3RhbGxlZCBvblxuICAgIC8vIEVsZW1lbnQgd2hlcmUgYnJvd3NlcnMgZG9uJ3QgaGF2ZSBgPHNsb3Q+YFxuICAgIGlmICh0aGlzLmxvY2FsTmFtZSAhPT0gJ3Nsb3QnIHx8IHR5cGUgPT09ICdzbG90Y2hhbmdlJykge1xuICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lci5jYWxsKHRoaXMsIHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDYXB0dXJlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zT3JDYXB0dXJlID0ge1xuICAgICAgICAgIGNhcHR1cmU6IEJvb2xlYW4ob3B0aW9uc09yQ2FwdHVyZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAncGFyZW50Tm9kZSddO1xuICAgICAgaWYgKCFwYXJlbnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGFkeURPTSBjYW5ub3QgYXR0YWNoIGV2ZW50IHRvIHNsb3QgdW5sZXNzIGl0IGhhcyBhIGBwYXJlbnROb2RlYCcpO1xuICAgICAgfVxuICAgICAgb3B0aW9uc09yQ2FwdHVyZS5fX3NoYWR5VGFyZ2V0ID0gdGhpcztcbiAgICAgIHBhcmVudFt1dGlscy5TSEFEWV9QUkVGSVggKyAncmVtb3ZlRXZlbnRMaXN0ZW5lciddKHR5cGUsIGZuLCBvcHRpb25zT3JDYXB0dXJlKTtcbiAgICB9XG4gIH1cblxufSk7XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuLi91dGlscy5qcyc7XG5cbmNvbnN0IGRvYyA9IHdpbmRvdy5kb2N1bWVudDtcblxuZXhwb3J0IGNvbnN0IERvY3VtZW50UGF0Y2hlcyA9IHV0aWxzLmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoe1xuXG4gIC8vIG5vdGU6IFRob3VnaCBub3QgdGVjaG5pY2FsbHkgY29ycmVjdCwgd2UgZmFzdCBwYXRoIGBpbXBvcnROb2RlYFxuICAvLyB3aGVuIGNhbGxlZCBvbiBhIG5vZGUgbm90IG93bmVkIGJ5IHRoZSBtYWluIGRvY3VtZW50LlxuICAvLyBUaGlzIGFsbG93cywgZm9yIGV4YW1wbGUsIGVsZW1lbnRzIHRoYXQgY2Fubm90XG4gIC8vIGNvbnRhaW4gY3VzdG9tIGVsZW1lbnRzIGFuZCBhcmUgdGhlcmVmb3JlIG5vdCBsaWtlbHkgdG8gY29udGFpbiBzaGFkb3dSb290c1xuICAvLyB0byBjbG9uZWQgbmF0aXZlbHkuIFRoaXMgaXMgYSBmYWlybHkgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2Ugd2luLlxuICAvKipcbiAgICogQHRoaXMge0RvY3VtZW50fVxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtib29sZWFufSBkZWVwXG4gICAqL1xuICBpbXBvcnROb2RlKG5vZGUsIGRlZXApIHtcbiAgICAvLyBBIHRlbXBsYXRlIGVsZW1lbnQgbm9ybWFsbHkgaGFzIG5vIGNoaWxkcmVuIHdpdGggc2hhZG93Um9vdHMsIHNvIG1ha2VcbiAgICAvLyBzdXJlIHdlIGFsd2F5cyBtYWtlIGEgZGVlcCBjb3B5IHRvIGNvcnJlY3RseSBjb25zdHJ1Y3QgdGhlIHRlbXBsYXRlLmNvbnRlbnRcbiAgICBpZiAobm9kZS5vd25lckRvY3VtZW50ICE9PSBkb2MgfHwgbm9kZS5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHJldHVybiB0aGlzW3V0aWxzLk5BVElWRV9QUkVGSVggKyAnaW1wb3J0Tm9kZSddKG5vZGUsIGRlZXApO1xuICAgIH1cbiAgICBsZXQgbiA9IHRoaXNbdXRpbHMuTkFUSVZFX1BSRUZJWCArICdpbXBvcnROb2RlJ10obm9kZSwgZmFsc2UpO1xuICAgIGlmIChkZWVwKSB7XG4gICAgICBmb3IgKGxldCBjPW5vZGVbdXRpbHMuU0hBRFlfUFJFRklYICsgJ2ZpcnN0Q2hpbGQnXSwgbmM7IGM7IGMgPSBjW3V0aWxzLlNIQURZX1BSRUZJWCArICduZXh0U2libGluZyddKSB7XG4gICAgICAgIG5jID0gdGhpc1t1dGlscy5TSEFEWV9QUkVGSVggKyAnaW1wb3J0Tm9kZSddKGMsIHRydWUpO1xuICAgICAgICBuW3V0aWxzLlNIQURZX1BSRUZJWCArICdhcHBlbmRDaGlsZCddKG5jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG47XG4gIH1cblxufSk7IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4uL3V0aWxzLmpzJztcbmltcG9ydCB7YWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lcn0gZnJvbSAnLi4vcGF0Y2gtZXZlbnRzLmpzJztcblxuZXhwb3J0IGNvbnN0IFdpbmRvd1BhdGNoZXMgPSB1dGlscy5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHtcblxuICAvLyBOT1RFOiBlbnN1cmUgdGhlc2UgbWV0aG9kcyBhcmUgYm91bmQgdG8gYHdpbmRvd2Agc28gdGhhdCBgdGhpc2AgaXMgY29ycmVjdFxuICAvLyB3aGVuIGNhbGxlZCBkaXJlY3RseSBmcm9tIGdsb2JhbCBjb250ZXh0IHdpdGhvdXQgYSByZWNlaXZlcjsgZS5nLlxuICAvLyBgYWRkRXZlbnRMaXN0ZW5lciguLi4pYC5cbiAgYWRkRXZlbnRMaXN0ZW5lcjogYWRkRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdyksXG5cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogcmVtb3ZlRXZlbnRMaXN0ZW5lci5iaW5kKHdpbmRvdylcblxufSk7IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuaW1wb3J0ICogYXMgdXRpbHMgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQge0V2ZW50VGFyZ2V0UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL0V2ZW50VGFyZ2V0LmpzJztcbmltcG9ydCB7Tm9kZVBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Ob2RlLmpzJztcbmltcG9ydCB7U2xvdGFibGVQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvU2xvdGFibGUuanMnO1xuaW1wb3J0IHtQYXJlbnROb2RlUGF0Y2hlcywgUGFyZW50Tm9kZURvY3VtZW50T3JGcmFnbWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9QYXJlbnROb2RlLmpzJztcbmltcG9ydCB7RWxlbWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9FbGVtZW50LmpzJztcbmltcG9ydCB7RWxlbWVudE9yU2hhZG93Um9vdFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9FbGVtZW50T3JTaGFkb3dSb290LmpzJztcbmltcG9ydCB7SFRNTEVsZW1lbnRQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvSFRNTEVsZW1lbnQuanMnO1xuaW1wb3J0IHtTbG90UGF0Y2hlc30gZnJvbSAnLi9wYXRjaGVzL1Nsb3QuanMnO1xuaW1wb3J0IHtEb2N1bWVudE9yRnJhZ21lbnRQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRG9jdW1lbnRPckZyYWdtZW50LmpzJztcbmltcG9ydCB7RG9jdW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzfSBmcm9tICcuL3BhdGNoZXMvRG9jdW1lbnRPclNoYWRvd1Jvb3QuanMnO1xuaW1wb3J0IHtEb2N1bWVudFBhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9Eb2N1bWVudC5qcyc7XG5pbXBvcnQge1dpbmRvd1BhdGNoZXN9IGZyb20gJy4vcGF0Y2hlcy9XaW5kb3cuanMnO1xuXG4vLyBTb21lIGJyb3dzZXJzIChJRS9FZGdlKSBoYXZlIG5vbi1zdGFuZGFyZCBIVE1MRWxlbWVudCBhY2Nlc3NvcnMuXG5jb25zdCBOb25TdGFuZGFyZEhUTUxFbGVtZW50ID0ge307XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ3BhcmVudEVsZW1lbnQnKSkge1xuICBOb25TdGFuZGFyZEhUTUxFbGVtZW50LnBhcmVudEVsZW1lbnQgPSBOb2RlUGF0Y2hlcy5wYXJlbnRFbGVtZW50O1xufVxuXG5pZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsICdjb250YWlucycpKSB7XG4gIE5vblN0YW5kYXJkSFRNTEVsZW1lbnQuY29udGFpbnMgPSBOb2RlUGF0Y2hlcy5jb250YWlucztcbn1cblxuaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoSFRNTEVsZW1lbnQucHJvdG90eXBlLCAnY2hpbGRyZW4nKSkge1xuICBOb25TdGFuZGFyZEhUTUxFbGVtZW50LmNoaWxkcmVuID0gUGFyZW50Tm9kZVBhdGNoZXMuY2hpbGRyZW47XG59XG5cbmlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2lubmVySFRNTCcpKSB7XG4gIE5vblN0YW5kYXJkSFRNTEVsZW1lbnQuaW5uZXJIVE1MID0gRWxlbWVudE9yU2hhZG93Um9vdFBhdGNoZXMuaW5uZXJIVE1MO1xufVxuXG5pZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihIVE1MRWxlbWVudC5wcm90b3R5cGUsICdjbGFzc05hbWUnKSkge1xuICBOb25TdGFuZGFyZEhUTUxFbGVtZW50LmNsYXNzTmFtZSA9IEVsZW1lbnRQYXRjaGVzLmNsYXNzTmFtZTtcbn1cblxuLy8gQXZvaWQgcGF0Y2hpbmcgYGlubmVySFRNTGAgaWYgaXQgZG9lcyBub3QgZXhpc3Qgb24gRWxlbWVudCAoSUUpXG4vLyBhbmQgd2UgY2FuIHBhdGNoIGFjY2Vzc29ycyAoaGFzRGVzY3JpcHRvcnMpLlxuY29uc3QgRWxlbWVudFNob3VsZEhhdmVJbm5lckhUTUwgPSAhdXRpbHMuc2V0dGluZ3MuaGFzRGVzY3JpcHRvcnMgfHwgJ2lubmVySFRNTCcgaW4gRWxlbWVudC5wcm90b3R5cGU7XG5cbi8vIHNldHVwIHBhdGNoaW5nXG5jb25zdCBwYXRjaE1hcCA9IHtcbiAgRXZlbnRUYXJnZXQ6IFtFdmVudFRhcmdldFBhdGNoZXNdLFxuICBOb2RlOiBbTm9kZVBhdGNoZXMsICF3aW5kb3cuRXZlbnRUYXJnZXQgPyBFdmVudFRhcmdldFBhdGNoZXMgOiBudWxsXSxcbiAgVGV4dDogW1Nsb3RhYmxlUGF0Y2hlc10sXG4gIEVsZW1lbnQ6IFtFbGVtZW50UGF0Y2hlcywgUGFyZW50Tm9kZVBhdGNoZXMsIFNsb3RhYmxlUGF0Y2hlcyxcbiAgICBFbGVtZW50U2hvdWxkSGF2ZUlubmVySFRNTCA/IEVsZW1lbnRPclNoYWRvd1Jvb3RQYXRjaGVzIDogbnVsbCxcbiAgICAhd2luZG93LkhUTUxTbG90RWxlbWVudCA/IFNsb3RQYXRjaGVzIDogbnVsbF0sXG4gIEhUTUxFbGVtZW50OiBbSFRNTEVsZW1lbnRQYXRjaGVzLCBOb25TdGFuZGFyZEhUTUxFbGVtZW50XSxcbiAgSFRNTFNsb3RFbGVtZW50OiBbU2xvdFBhdGNoZXNdLFxuICBEb2N1bWVudEZyYWdtZW50OiBbUGFyZW50Tm9kZURvY3VtZW50T3JGcmFnbWVudFBhdGNoZXMsIERvY3VtZW50T3JGcmFnbWVudFBhdGNoZXNdLFxuICBEb2N1bWVudDogW0RvY3VtZW50UGF0Y2hlcywgUGFyZW50Tm9kZURvY3VtZW50T3JGcmFnbWVudFBhdGNoZXMsIERvY3VtZW50T3JGcmFnbWVudFBhdGNoZXMsIERvY3VtZW50T3JTaGFkb3dSb290UGF0Y2hlc10sXG4gIFdpbmRvdzogW1dpbmRvd1BhdGNoZXNdXG59XG5cbmNvbnN0IGdldFBhdGNoUHJvdG90eXBlID0gKG5hbWUpID0+IHdpbmRvd1tuYW1lXSAmJiB3aW5kb3dbbmFtZV0ucHJvdG90eXBlO1xuXG4vLyBOb3RlLCBtdXN0IGF2b2lkIHBhdGNoaW5nIGFjY2Vzc29ycyBvbiBwcm90b3R5cGVzIHdoZW4gZGVzY3JpcHRvcnMgYXJlIG5vdCBjb3JyZWN0XG4vLyBiZWNhdXNlIHRoZSBDdXN0b21FbGVtZW50cyBwb2x5ZmlsbCBjaGVja3MgaWYgdGhlc2UgZXhpc3QgYmVmb3JlIHBhdGNoaW5nIGluc3RhbmNlcy5cbi8vIEN1c3RvbUVsZW1lbnRzIHBvbHlmaWxsICpvbmx5KiBjYXJlcyBhYm91dCB0aGVzZSBhY2Nlc3NvcnMuXG5jb25zdCBkaXNhbGxvd2VkTmF0aXZlUGF0Y2hlcyA9IHV0aWxzLnNldHRpbmdzLmhhc0Rlc2NyaXB0b3JzID8gbnVsbCA6IFsnaW5uZXJIVE1MJywgJ3RleHRDb250ZW50J107XG5cbi8qKiBAcGFyYW0ge3N0cmluZz19IHByZWZpeCAqL1xuZXhwb3J0IGNvbnN0IGFwcGx5UGF0Y2hlcyA9IChwcmVmaXgpID0+IHtcbiAgY29uc3QgZGlzYWxsb3dlZCA9IHByZWZpeCA/IG51bGwgOiBkaXNhbGxvd2VkTmF0aXZlUGF0Y2hlcztcbiAgZm9yIChsZXQgcCBpbiBwYXRjaE1hcCkge1xuICAgIGNvbnN0IHByb3RvID0gZ2V0UGF0Y2hQcm90b3R5cGUocCk7XG4gICAgcGF0Y2hNYXBbcF0uZm9yRWFjaChwYXRjaCA9PiBwcm90byAmJiBwYXRjaCAmJlxuICAgICAgICB1dGlscy5wYXRjaFByb3BlcnRpZXMocHJvdG8sIHBhdGNoLCBwcmVmaXgsIGRpc2FsbG93ZWQpKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgYWRkU2hhZHlQcmVmaXhlZFByb3BlcnRpZXMgPSAoKSA9PiB7XG4gIC8vIHBlcmZvcm0gc2hhZHkgcGF0Y2hlc1xuICBhcHBseVBhdGNoZXModXRpbHMuU0hBRFlfUFJFRklYKTtcblxuICAvLyBpbnN0YWxsIGBfYWN0aXZlRWxlbWVudGAgYmVjYXVzZSBzb21lIGJyb3dzZXJzIChvbGRlciBDaHJvbWUvU2FmYXJpKSBkbyBub3QgaGF2ZVxuICAvLyBhICdjb25maWd1cmFibGUnIGBhY3RpdmVFbGVtZW50YCBhY2Nlc3Nzb3IuXG4gIGNvbnN0IGRlc2NyaXB0b3IgPSBEb2N1bWVudE9yU2hhZG93Um9vdFBhdGNoZXMuYWN0aXZlRWxlbWVudDtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAnX2FjdGl2ZUVsZW1lbnQnLCBkZXNjcmlwdG9yKTtcblxuICAvLyBPbiBXaW5kb3csIHdlJ3JlIHBhdGNoaW5nIGBhZGRFdmVudExpc3RlbmVyYCB3aGljaCBpcyBhIHdlaXJkIGF1dG8tYm91bmRcbiAgLy8gcHJvcGVydHkgdGhhdCBpcyBub3QgZGlyZWN0bHkgb24gdGhlIFdpbmRvdyBwcm90b3R5cGUuXG4gIHV0aWxzLnBhdGNoUHJvcGVydGllcyhXaW5kb3cucHJvdG90eXBlLCBXaW5kb3dQYXRjaGVzLCB1dGlscy5TSEFEWV9QUkVGSVgpO1xufTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qKlxuICogUGF0Y2hlcyBlbGVtZW50cyB0aGF0IGludGVyYWN0cyB3aXRoIFNoYWR5RE9NXG4gKiBzdWNoIHRoYXQgdHJlZSB0cmF2ZXJzYWwgYW5kIG11dGF0aW9uIGFwaXMgYWN0IGxpa2UgdGhleSB3b3VsZCB1bmRlclxuICogU2hhZG93RE9NLlxuICpcbiAqIFRoaXMgaW1wb3J0IGVuYWJsZXMgc2VlbWxlc3MgaW50ZXJhY3Rpb24gd2l0aCBTaGFkeURPTSBwb3dlcmVkXG4gKiBjdXN0b20gZWxlbWVudHMsIGVuYWJsaW5nIGJldHRlciBpbnRlcm9wZXJhdGlvbiB3aXRoIDNyZCBwYXJ0eSBjb2RlLFxuICogbGlicmFyaWVzLCBhbmQgZnJhbWV3b3JrcyB0aGF0IHVzZSBET00gdHJlZSBtYW5pcHVsYXRpb24gYXBpcy5cbiAqL1xuXG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7Zmx1c2gsIGVucXVldWV9IGZyb20gJy4vZmx1c2guanMnO1xuaW1wb3J0IHtvYnNlcnZlQ2hpbGRyZW4sIHVub2JzZXJ2ZUNoaWxkcmVuLCBmaWx0ZXJNdXRhdGlvbnN9IGZyb20gJy4vb2JzZXJ2ZS1jaGFuZ2VzLmpzJztcbmltcG9ydCB7YWRkTmF0aXZlUHJlZml4ZWRQcm9wZXJ0aWVzLCBuYXRpdmVNZXRob2RzLCBuYXRpdmVUcmVlfSBmcm9tICcuL3BhdGNoLW5hdGl2ZS5qcyc7XG5pbXBvcnQge3BhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycywgcGF0Y2hPdXRzaWRlRWxlbWVudEFjY2Vzc29yc30gZnJvbSAnLi9wYXRjaC1pbnN0YW5jZXMuanMnO1xuaW1wb3J0IHtwYXRjaEV2ZW50cywgcGF0Y2hDbGljaywgY29tcG9zZWRQYXRofSBmcm9tICcuL3BhdGNoLWV2ZW50cy5qcyc7XG5pbXBvcnQge1NoYWR5Um9vdH0gZnJvbSAnLi9hdHRhY2gtc2hhZG93LmpzJztcbmltcG9ydCB7d3JhcCwgV3JhcHBlcn0gZnJvbSAnLi93cmFwcGVyLmpzJztcbmltcG9ydCB7YWRkU2hhZHlQcmVmaXhlZFByb3BlcnRpZXMsIGFwcGx5UGF0Y2hlc30gZnJvbSAnLi9wYXRjaC1wcm90b3R5cGVzLmpzJztcblxuXG5pZiAodXRpbHMuc2V0dGluZ3MuaW5Vc2UpIHtcblxuICBsZXQgU2hhZHlET00gPSB7XG4gICAgLy8gVE9ETyhzb3J2ZWxsKTogcmVtb3ZlIHdoZW4gUG9seW1lciBkb2VzIG5vdCBkZXBlbmQgb24gdGhpcy5cbiAgICAnaW5Vc2UnOiB1dGlscy5zZXR0aW5ncy5pblVzZSxcbiAgICAvLyBOT1RFOiBvbGQgYnJvd3NlcnMgd2l0aG91dCBwcm90b3R5cGUgYWNjZXNzb3JzICh2ZXJ5IG9sZCBDaHJvbWVcbiAgICAvLyBhbmQgU2FmYXJpKSBuZWVkIG1hbnVhbGx5IHBhdGNoZWQgYWNjZXNzb3JzIHRvIHByb3Blcmx5IHNldFxuICAgIC8vIGBpbm5lckhUTUxgIGFuZCBgdGV4dENvbnRlbnRgIHdoZW4gYW4gZWxlbWVudCBpczpcbiAgICAvLyAoMSkgaW5zaWRlIGEgc2hhZG93Um9vdFxuICAgIC8vICgyKSBkb2VzIG5vdCBoYXZlIHNwZWNpYWwgKHNsb3QpIGNoaWxkcmVuIGl0c2VsZlxuICAgIC8vICgzKSBhbmQgc2V0dGluZyB0aGUgcHJvcGVydHkgbmVlZHMgdG8gcHJvdm9rZSBkaXN0cmlidXRpb24gKGJlY2F1c2VcbiAgICAvLyBhIG5lc3RlZCBzbG90IGlzIGFkZGVkL3JlbW92ZWQpXG4gICAgJ3BhdGNoJzogKG5vZGUpID0+IHtcbiAgICAgIHBhdGNoSW5zaWRlRWxlbWVudEFjY2Vzc29ycyhub2RlKTtcbiAgICAgIHBhdGNoT3V0c2lkZUVsZW1lbnRBY2Nlc3NvcnMobm9kZSk7XG4gICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuICAgICdpc1NoYWR5Um9vdCc6IHV0aWxzLmlzU2hhZHlSb290LFxuICAgICdlbnF1ZXVlJzogZW5xdWV1ZSxcbiAgICAnZmx1c2gnOiBmbHVzaCxcbiAgICAnZmx1c2hJbml0aWFsJzogKHJvb3QpID0+IHtcbiAgICAgIHJvb3QuX2ZsdXNoSW5pdGlhbCgpO1xuICAgIH0sXG4gICAgJ3NldHRpbmdzJzogdXRpbHMuc2V0dGluZ3MsXG4gICAgJ2ZpbHRlck11dGF0aW9ucyc6IGZpbHRlck11dGF0aW9ucyxcbiAgICAnb2JzZXJ2ZUNoaWxkcmVuJzogb2JzZXJ2ZUNoaWxkcmVuLFxuICAgICd1bm9ic2VydmVDaGlsZHJlbic6IHVub2JzZXJ2ZUNoaWxkcmVuLFxuICAgIC8vIFNldCB0byB0cnVlIHRvIGRlZmVyIG5hdGl2ZSBjdXN0b20gZWxlbWVudHMgY29ubmVjdGlvbiB1bnRpbCB0aGVcbiAgICAvLyBkb2N1bWVudCBoYXMgZnVsbHkgcGFyc2VkLiBUaGlzIGVuYWJsZXMgY3VzdG9tIGVsZW1lbnRzIHRoYXQgY3JlYXRlXG4gICAgLy8gc2hhZG93Um9vdHMgdG8gYmUgZGVmaW5lZCB3aGlsZSB0aGUgZG9jdW1lbnQgaXMgbG9hZGluZy4gRWxlbWVudHNcbiAgICAvLyBjdXN0b21pemVkIGFzIHRoZXkgYXJlIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciB3aWxsIHN1Y2Nlc3NmdWxseVxuICAgIC8vIHJlbmRlciB3aXRoIHRoaXMgZmxhZyBvbi5cbiAgICAnZGVmZXJDb25uZWN0aW9uQ2FsbGJhY2tzJzogdXRpbHMuc2V0dGluZ3NbJ2RlZmVyQ29ubmVjdGlvbkNhbGxiYWNrcyddLFxuICAgIC8vIFNldCB0byB0cnVlIHRvIHNwZWVkIHVwIHRoZSBwb2x5ZmlsbCBzbGlnaHRseSBhdCB0aGUgY29zdCBvZiBjb3JyZWN0bmVzc1xuICAgIC8vICogZG9lcyBub3QgcGF0Y2ggcXVlcnlTZWxlY3Rvci9BbGwgb24gRG9jdW1lbnQgb3IgRG9jdW1lbnRGcmFnbWVudFxuICAgIC8vICogZG9lcyBub3Qgd3JhcCBjb25uZWN0ZWQvZGlzY29ubmVjdGVkIGNhbGxiYWNrcyB0byBkZS1kdXAgdGhlc2VcbiAgICAvLyB3aGVuIHVzaW5nIG5hdGl2ZSBjdXN0b21FbGVtZW50c1xuICAgIC8vICogZG9lcyBub3Qgd2FpdCB0byBwcm9jZXNzIGNoaWxkcmVuIG9mIGVsZW1lbnRzIHdpdGggc2hhZG93Um9vdHNcbiAgICAvLyBtZWFuaW5nIHNoYWRvd1Jvb3RzIHNob3VsZCBub3QgYmUgY3JlYXRlZCB3aGlsZSBhbiBlbGVtZW50IGlzIHBhcnNpbmdcbiAgICAvLyAoZS5nLiBpZiBhIGN1c3RvbSBlbGVtZW50IHRoYXQgY3JlYXRlcyBhIHNoYWRvd1Jvb3QgaXMgZGVmaW5lZCBiZWZvcmVcbiAgICAvLyBhIGNhbmRpZGF0ZSBlbGVtZW50IGluIHRoZSBkb2N1bWVudCBiZWxvdyBpdC5cbiAgICAncHJlZmVyUGVyZm9ybWFuY2UnOiB1dGlscy5zZXR0aW5nc1sncHJlZmVyUGVyZm9ybWFuY2UnXSxcbiAgICAvLyBJbnRlZ3JhdGlvbiBwb2ludCB3aXRoIFNoYWR5Q1NTIHRvIGRpc2FibGUgc3R5bGluZyBNdXRhdGlvbk9ic2VydmVyLFxuICAgIC8vIGFzIFNoYWR5RE9NIHdpbGwgbm93IGhhbmRsZSBkeW5hbWljIHNjb3BpbmcuXG4gICAgJ2hhbmRsZXNEeW5hbWljU2NvcGluZyc6IHRydWUsXG4gICAgJ3dyYXAnOiB1dGlscy5zZXR0aW5ncy5ub1BhdGNoID8gd3JhcCA6IChuKSA9PiBuLFxuICAgICdXcmFwcGVyJzogV3JhcHBlcixcbiAgICAnY29tcG9zZWRQYXRoJzogY29tcG9zZWRQYXRoLFxuICAgIC8vIFNldCB0byB0cnVlIHRvIGF2b2lkIHBhdGNoaW5nIHJlZ3VsYXIgcGxhdGZvcm0gcHJvcGVydHkgbmFtZXMuIFdoZW4gc2V0LFxuICAgIC8vIFNoYWRvdyBET00gY29tcGF0aWJsZSBiZWhhdmlvciBpcyBvbmx5IGF2YWlsYWJsZSB3aGVuIGFjY2Vzc2luZyBET01cbiAgICAvLyBBUEkgdXNpbmcgYFNoYWR5RE9NLndyYXBgLCBlLmcuIGBTaGFkeURPTS53cmFwKGVsZW1lbnQpLnNoYWRvd1Jvb3RgLlxuICAgIC8vIFRoaXMgc2V0dGluZyBwcm92aWRlcyBhIHNtYWxsIHBlcmZvcm1hbmNlIGJvb3N0LCBidXQgcmVxdWlyZXMgYWxsIERPTSBBUElcbiAgICAvLyBhY2Nlc3MgdGhhdCByZXF1aXJlcyBTaGFkb3cgRE9NIGJlaGF2aW9yIHRvIGJlIHByb3hpZWQgdmlhIGBTaGFkeURPTS53cmFwYC5cbiAgICAnbm9QYXRjaCc6IHV0aWxzLnNldHRpbmdzLm5vUGF0Y2gsXG4gICAgJ25hdGl2ZU1ldGhvZHMnOiBuYXRpdmVNZXRob2RzLFxuICAgICduYXRpdmVUcmVlJzogbmF0aXZlVHJlZVxuICB9O1xuXG4gIHdpbmRvd1snU2hhZHlET00nXSA9IFNoYWR5RE9NO1xuXG4gIC8vIE1vZGlmaWVzIG5hdGl2ZSBwcm90b3R5cGVzIGZvciBOb2RlLCBFbGVtZW50LCBldGMuIHRvXG4gIC8vIG1ha2UgbmF0aXZlIHBsYXRmb3JtIGJlaGF2aW9yIGF2YWlsYWJsZSBhdCBwcmVmaXhlZCBuYW1lcywgZS5nLlxuICAvLyBgdXRpbHMuTkFUSVZFX1BSRUZJWCArICdmaXJzdENoaWxkJ2Agb3IgYF9fc2hhZHlfbmF0aXZlX2ZpcnN0Q2hpbGRgLlxuICAvLyBUaGlzIGFsbG93cyB0aGUgc3RhbmRhcmQgbmFtZXMgdG8gYmUgc2FmZWx5IHBhdGNoZWQgd2hpbGUgcmV0YWluaW5nIHRoZVxuICAvLyBhYmlsaXR5IGZvciBuYXRpdmUgYmVoYXZpb3IgdG8gYmUgdXNlZC4gVGhpcyBwb2x5ZmlsbCBtYW5pcHVsYXRlcyBET01cbiAgLy8gYnkgdXNpbmcgdGhpcyBzYXZlZCBuYXRpdmUgYmVoYXZpb3IuXG4gIC8vIE5vdGUsIHNvbWUgYnJvd3NlcnMgZG8gbm90IGhhdmUgcHJvcGVyIGVsZW1lbnQgZGVzY3JpcHRvcnMgZm9yXG4gIC8vIGFjY2Vzc29yczsgaW4gdGhpcyBjYXNlLCBuYXRpdmUgYmVoYXZpb3IgZm9yIHRoZXNlIGFjY2Vzc29ycyBpcyBzaW11bGF0ZWRcbiAgLy8gdmlhIGEgVHJlZVdhbGtlci5cbiAgYWRkTmF0aXZlUHJlZml4ZWRQcm9wZXJ0aWVzKCk7XG5cbiAgLy8gTW9kaWZpZXMgbmF0aXZlIHByb3RvdHlwZXMgZm9yIE5vZGUsIEVsZW1lbnQsIGV0Yy4gdG8gbWFrZSBTaGFkb3dET01cbiAgLy8gYmVoYXZpb3IgYXZhaWxhYmxlIGF0IHByZWZpeGVkIG5hbWVzLCBlLmcuXG4gIC8vIGB1dGlscy5TSEFEWV9QUkVGSVggKyAnZmlyc3RDaGlsZGAgb3IgYF9fc2hhZHlfZmlyc3RDaGlsZGAuIFRoaXMgaXMgZG9uZVxuICAvLyBzbyB0aGlzIHBvbHlmaWxsIGNhbiBwZXJmb3JtIFNoYWRvdyBET00gc3R5bGUgRE9NIG1hbmlwdWxhdGlvbi5cbiAgLy8gQmVjYXVzZSBwYXRjaGluZyBub3JtYWwgcGxhdGZvcm0gcHJvcGVydHkgbmFtZXMgaXMgb3B0aW9uYWwsIHRoZXNlIHByZWZpeGVkXG4gIC8vIG5hbWVzIGFyZSB1c2VkIGludGVybmFsbHkuXG4gIGFkZFNoYWR5UHJlZml4ZWRQcm9wZXJ0aWVzKCk7XG5cbiAgLy8gTW9kaWZpZXMgbmF0aXZlIHByb3RvdHlwZXMgZm9yIE5vZGUsIEVsZW1lbnQsIGV0Yy4gdG8gcGF0Y2hcbiAgLy8gcmVndWxhciBwbGF0Zm9ybSBwcm9wZXJ0eSBuYW1lcyB0byBoYXZlIFNoYWRvdyBET00gY29tcGF0aWJsZSBBUEkgYmVoYXZpb3IuXG4gIC8vIFRoaXMgYXBwbGllcyB0aGUgdXRpbHMuU0hBRFlfUFJFRklYIGJlaGF2aW9yIHRvIG5vcm1hbCBuYW1lcy4gRm9yIGV4YW1wbGUsXG4gIC8vIGlmIGBub1BhdGNoYCBpcyBub3Qgc2V0LCB0aGVuIGBlbC5fX3NoYWR5X2ZpcnN0Q2hpbGRgIGlzIGVxdWl2YWxlbnQgdG9cbiAgLy8gYGVsLmZpcnN0Q2hpbGRgLlxuICAvLyBOT1RFLCBvbiBvbGRlciBicm93c2VycyAob2xkIENocm9tZS9TYWZhcmkpIG5hdGl2ZSBhY2Nlc3NvcnMgY2Fubm90IGJlXG4gIC8vIHBhdGNoZWQgb24gcHJvdG90eXBlcyAoZS5nLiBOb2RlLnByb3RvdHlwZS5maXJzdENoaWxkIGNhbm5vdCBiZSBtb2RpZmllZCkuXG4gIC8vIE9uIHRoZXNlIGJyb3dzZXJzLCBpbnN0YW5jZSBsZXZlbCBwYXRjaGluZyBpcyBwZXJmb3JtZWQgd2hlcmUgbmVlZGVkOyB0aGlzXG4gIC8vIGluc3RhbmNlIHBhdGNoaW5nIGlzIG9ubHkgZG9uZSB3aGVuIGBub1BhdGNoYCBpcyAqbm90KiBzZXQuXG4gIGlmICghdXRpbHMuc2V0dGluZ3Mubm9QYXRjaCkge1xuICAgIGFwcGx5UGF0Y2hlcygpO1xuICAgIC8vIFBhdGNoIGNsaWNrIGV2ZW50IGJlaGF2aW9yIG9ubHkgaWYgd2UncmUgcGF0Y2hpbmdcbiAgICBwYXRjaENsaWNrKClcbiAgfVxuXG4gIC8vIEZvciBzaW1wbGljaXR5LCBwYXRjaCBldmVudHMgdW5jb25kaXRpb25hbGx5LlxuICAvLyBQYXRjaGVzIHRoZSBldmVudCBzeXN0ZW0gdG8gaGF2ZSBTaGFkb3cgRE9NIGNvbXBhdGlibGUgYmVoYXZpb3IgKGUuZy5cbiAgLy8gZXZlbnQgcmV0YXJnZXRpbmcpLiBXaGVuIGBub1BhdGNoYCBpcyBzZXQsIHJldGFyZ2V0aW5nIGlzIG9ubHkgYXZhaWxhYmxlXG4gIC8vIHdoZW4gYWRkaW5nIGV2ZW50IGxpc3RlbmVycyBhbmQgZGlzcGF0Y2hpbmcgZXZlbnRzIHZpYSBgU2hhZHlET00ud3JhcGBcbiAgLy8gKGUuZy4gYFNoYWR5RE9NLndyYXAoZWxlbWVudCkuYWRkRXZlbnRMaXN0ZW5lciguLi4pYCkuXG4gIHBhdGNoRXZlbnRzKCk7XG5cbiAgd2luZG93LlNoYWRvd1Jvb3QgPSAvKiogQHR5cGUge2Z1bmN0aW9uKG5ldzpTaGFkb3dSb290KX0gKi8oU2hhZHlSb290KTtcbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbi8qXG5FeHRyZW1lbHkgc2ltcGxlIGNzcyBwYXJzZXIuIEludGVuZGVkIHRvIGJlIG5vdCBtb3JlIHRoYW4gd2hhdCB3ZSBuZWVkXG5hbmQgZGVmaW5pdGVseSBub3QgbmVjZXNzYXJpbHkgY29ycmVjdCA9KS5cbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB1bnJlc3RyaWN0ZWQgKi9cbmNsYXNzIFN0eWxlTm9kZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3N0YXJ0J10gPSAwO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ2VuZCddID0gMDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwcmV2aW91cyddID0gbnVsbDtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzWydwYXJlbnQnXSA9IG51bGw7XG4gICAgLyoqIEB0eXBlIHtBcnJheTxTdHlsZU5vZGU+fSAqL1xuICAgIHRoaXNbJ3J1bGVzJ10gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZENzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ2Nzc1RleHQnXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzWydhdFJ1bGUnXSA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqL1xuICAgIHRoaXNbJ3R5cGUnXSA9IDA7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1sna2V5ZnJhbWVzTmFtZSddID0gJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpc1snc2VsZWN0b3InXSA9ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXNbJ3BhcnNlZFNlbGVjdG9yJ10gPSAnJztcbiAgfVxufVxuXG5leHBvcnQge1N0eWxlTm9kZX1cblxuLy8gZ2l2ZW4gYSBzdHJpbmcgb2YgY3NzLCByZXR1cm4gYSBzaW1wbGUgcnVsZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gIHRleHQgPSBjbGVhbih0ZXh0KTtcbiAgcmV0dXJuIHBhcnNlQ3NzKGxleCh0ZXh0KSwgdGV4dCk7XG59XG5cbi8vIHJlbW92ZSBzdHVmZiB3ZSBkb24ndCBjYXJlIGFib3V0IHRoYXQgbWF5IGhpbmRlciBwYXJzaW5nXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNsZWFuKGNzc1RleHQpIHtcbiAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5jb21tZW50cywgJycpLnJlcGxhY2UoUlgucG9ydCwgJycpO1xufVxuXG4vLyBzdXBlciBzaW1wbGUgey4uLn0gbGV4ZXIgdGhhdCByZXR1cm5zIGEgbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gKiBAcmV0dXJuIHtTdHlsZU5vZGV9XG4gKi9cbmZ1bmN0aW9uIGxleCh0ZXh0KSB7XG4gIGxldCByb290ID0gbmV3IFN0eWxlTm9kZSgpO1xuICByb290WydzdGFydCddID0gMDtcbiAgcm9vdFsnZW5kJ10gPSB0ZXh0Lmxlbmd0aFxuICBsZXQgbiA9IHJvb3Q7XG4gIGZvciAobGV0IGkgPSAwLCBsID0gdGV4dC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAodGV4dFtpXSA9PT0gT1BFTl9CUkFDRSkge1xuICAgICAgaWYgKCFuWydydWxlcyddKSB7XG4gICAgICAgIG5bJ3J1bGVzJ10gPSBbXTtcbiAgICAgIH1cbiAgICAgIGxldCBwID0gbjtcbiAgICAgIGxldCBwcmV2aW91cyA9IHBbJ3J1bGVzJ11bcFsncnVsZXMnXS5sZW5ndGggLSAxXSB8fCBudWxsO1xuICAgICAgbiA9IG5ldyBTdHlsZU5vZGUoKTtcbiAgICAgIG5bJ3N0YXJ0J10gPSBpICsgMTtcbiAgICAgIG5bJ3BhcmVudCddID0gcDtcbiAgICAgIG5bJ3ByZXZpb3VzJ10gPSBwcmV2aW91cztcbiAgICAgIHBbJ3J1bGVzJ10ucHVzaChuKTtcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09IENMT1NFX0JSQUNFKSB7XG4gICAgICBuWydlbmQnXSA9IGkgKyAxO1xuICAgICAgbiA9IG5bJ3BhcmVudCddIHx8IHJvb3Q7XG4gICAgfVxuICB9XG4gIHJldHVybiByb290O1xufVxuXG4vLyBhZGQgc2VsZWN0b3JzL2Nzc1RleHQgdG8gbm9kZSB0cmVlXG4vKipcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHJldHVybiB7U3R5bGVOb2RlfVxuICovXG5mdW5jdGlvbiBwYXJzZUNzcyhub2RlLCB0ZXh0KSB7XG4gIGxldCB0ID0gdGV4dC5zdWJzdHJpbmcobm9kZVsnc3RhcnQnXSwgbm9kZVsnZW5kJ10gLSAxKTtcbiAgbm9kZVsncGFyc2VkQ3NzVGV4dCddID0gbm9kZVsnY3NzVGV4dCddID0gdC50cmltKCk7XG4gIGlmIChub2RlWydwYXJlbnQnXSkge1xuICAgIGxldCBzcyA9IG5vZGVbJ3ByZXZpb3VzJ10gPyBub2RlWydwcmV2aW91cyddWydlbmQnXSA6IG5vZGVbJ3BhcmVudCddWydzdGFydCddO1xuICAgIHQgPSB0ZXh0LnN1YnN0cmluZyhzcywgbm9kZVsnc3RhcnQnXSAtIDEpO1xuICAgIHQgPSBfZXhwYW5kVW5pY29kZUVzY2FwZXModCk7XG4gICAgdCA9IHQucmVwbGFjZShSWC5tdWx0aXBsZVNwYWNlcywgJyAnKTtcbiAgICAvLyBUT0RPKHNvcnZlbGwpOiBhZCBob2M7IG1ha2Ugc2VsZWN0b3IgaW5jbHVkZSBvbmx5IGFmdGVyIGxhc3QgO1xuICAgIC8vIGhlbHBzIHdpdGggbWl4aW4gc3ludGF4XG4gICAgdCA9IHQuc3Vic3RyaW5nKHQubGFzdEluZGV4T2YoJzsnKSArIDEpO1xuICAgIGxldCBzID0gbm9kZVsncGFyc2VkU2VsZWN0b3InXSA9IG5vZGVbJ3NlbGVjdG9yJ10gPSB0LnRyaW0oKTtcbiAgICBub2RlWydhdFJ1bGUnXSA9IChzLmluZGV4T2YoQVRfU1RBUlQpID09PSAwKTtcbiAgICAvLyBub3RlLCBzdXBwb3J0IGEgc3Vic2V0IG9mIHJ1bGUgdHlwZXMuLi5cbiAgICBpZiAobm9kZVsnYXRSdWxlJ10pIHtcbiAgICAgIGlmIChzLmluZGV4T2YoTUVESUFfU1RBUlQpID09PSAwKSB7XG4gICAgICAgIG5vZGVbJ3R5cGUnXSA9IHR5cGVzLk1FRElBX1JVTEU7XG4gICAgICB9IGVsc2UgaWYgKHMubWF0Y2goUlgua2V5ZnJhbWVzUnVsZSkpIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG4gICAgICAgIG5vZGVbJ2tleWZyYW1lc05hbWUnXSA9XG4gICAgICAgICAgbm9kZVsnc2VsZWN0b3InXS5zcGxpdChSWC5tdWx0aXBsZVNwYWNlcykucG9wKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChzLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMCkge1xuICAgICAgICBub2RlWyd0eXBlJ10gPSB0eXBlcy5NSVhJTl9SVUxFO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZVsndHlwZSddID0gdHlwZXMuU1RZTEVfUlVMRTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHIkID0gbm9kZVsncnVsZXMnXTtcbiAgaWYgKHIkKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGwgPSByJC5sZW5ndGgsIHI7XG4gICAgICAoaSA8IGwpICYmIChyID0gciRbaV0pOyBpKyspIHtcbiAgICAgIHBhcnNlQ3NzKHIsIHRleHQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBjb252ZXJzaW9uIG9mIHNvcnQgdW5pY29kZSBlc2NhcGVzIHdpdGggc3BhY2VzIGxpa2UgYFxcMzMgYCAoYW5kIGxvbmdlcikgaW50b1xuICogZXhwYW5kZWQgZm9ybSB0aGF0IGRvZXNuJ3QgcmVxdWlyZSB0cmFpbGluZyBzcGFjZSBgXFwwMDAwMzNgXG4gKiBAcGFyYW0ge3N0cmluZ30gc1xuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBfZXhwYW5kVW5pY29kZUVzY2FwZXMocykge1xuICByZXR1cm4gcy5yZXBsYWNlKC9cXFxcKFswLTlhLWZdezEsNn0pXFxzL2dpLCBmdW5jdGlvbigpIHtcbiAgICBsZXQgY29kZSA9IGFyZ3VtZW50c1sxXSxcbiAgICAgIHJlcGVhdCA9IDYgLSBjb2RlLmxlbmd0aDtcbiAgICB3aGlsZSAocmVwZWF0LS0pIHtcbiAgICAgIGNvZGUgPSAnMCcgKyBjb2RlO1xuICAgIH1cbiAgICByZXR1cm4gJ1xcXFwnICsgY29kZTtcbiAgfSk7XG59XG5cbi8qKlxuICogc3RyaW5naWZ5IHBhcnNlZCBjc3MuXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gbm9kZVxuICogQHBhcmFtIHtib29sZWFuPX0gcHJlc2VydmVQcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IHRleHRcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShub2RlLCBwcmVzZXJ2ZVByb3BlcnRpZXMsIHRleHQgPSAnJykge1xuICAvLyBjYWxjIHJ1bGUgY3NzVGV4dFxuICBsZXQgY3NzVGV4dCA9ICcnO1xuICBpZiAobm9kZVsnY3NzVGV4dCddIHx8IG5vZGVbJ3J1bGVzJ10pIHtcbiAgICBsZXQgciQgPSBub2RlWydydWxlcyddO1xuICAgIGlmIChyJCAmJiAhX2hhc01peGluUnVsZXMociQpKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbCA9IHIkLmxlbmd0aCwgcjtcbiAgICAgICAgKGkgPCBsKSAmJiAociA9IHIkW2ldKTsgaSsrKSB7XG4gICAgICAgIGNzc1RleHQgPSBzdHJpbmdpZnkociwgcHJlc2VydmVQcm9wZXJ0aWVzLCBjc3NUZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3NzVGV4dCA9IHByZXNlcnZlUHJvcGVydGllcyA/IG5vZGVbJ2Nzc1RleHQnXSA6XG4gICAgICAgIHJlbW92ZUN1c3RvbVByb3BzKG5vZGVbJ2Nzc1RleHQnXSk7XG4gICAgICBjc3NUZXh0ID0gY3NzVGV4dC50cmltKCk7XG4gICAgICBpZiAoY3NzVGV4dCkge1xuICAgICAgICBjc3NUZXh0ID0gJyAgJyArIGNzc1RleHQgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLy8gZW1pdCBydWxlIGlmIHRoZXJlIGlzIGNzc1RleHRcbiAgaWYgKGNzc1RleHQpIHtcbiAgICBpZiAobm9kZVsnc2VsZWN0b3InXSkge1xuICAgICAgdGV4dCArPSBub2RlWydzZWxlY3RvciddICsgJyAnICsgT1BFTl9CUkFDRSArICdcXG4nO1xuICAgIH1cbiAgICB0ZXh0ICs9IGNzc1RleHQ7XG4gICAgaWYgKG5vZGVbJ3NlbGVjdG9yJ10pIHtcbiAgICAgIHRleHQgKz0gQ0xPU0VfQlJBQ0UgKyAnXFxuXFxuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRleHQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxTdHlsZU5vZGU+fSBydWxlc1xuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gX2hhc01peGluUnVsZXMocnVsZXMpIHtcbiAgbGV0IHIgPSBydWxlc1swXTtcbiAgcmV0dXJuIEJvb2xlYW4ocikgJiYgQm9vbGVhbihyWydzZWxlY3RvciddKSAmJiByWydzZWxlY3RvciddLmluZGV4T2YoVkFSX1NUQVJUKSA9PT0gMDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiByZW1vdmVDdXN0b21Qcm9wcyhjc3NUZXh0KSB7XG4gIGNzc1RleHQgPSByZW1vdmVDdXN0b21Qcm9wQXNzaWdubWVudChjc3NUZXh0KTtcbiAgcmV0dXJuIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoY3NzVGV4dCkge1xuICByZXR1cm4gY3NzVGV4dFxuICAgIC5yZXBsYWNlKFJYLmN1c3RvbVByb3AsICcnKVxuICAgIC5yZXBsYWNlKFJYLm1peGluUHJvcCwgJycpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUN1c3RvbVByb3BBcHBseShjc3NUZXh0KSB7XG4gIHJldHVybiBjc3NUZXh0XG4gICAgLnJlcGxhY2UoUlgubWl4aW5BcHBseSwgJycpXG4gICAgLnJlcGxhY2UoUlgudmFyQXBwbHksICcnKTtcbn1cblxuLyoqIEBlbnVtIHtudW1iZXJ9ICovXG5leHBvcnQgY29uc3QgdHlwZXMgPSB7XG4gIFNUWUxFX1JVTEU6IDEsXG4gIEtFWUZSQU1FU19SVUxFOiA3LFxuICBNRURJQV9SVUxFOiA0LFxuICBNSVhJTl9SVUxFOiAxMDAwXG59XG5cbmNvbnN0IE9QRU5fQlJBQ0UgPSAneyc7XG5jb25zdCBDTE9TRV9CUkFDRSA9ICd9JztcblxuLy8gaGVscGVyIHJlZ2V4cCdzXG5jb25zdCBSWCA9IHtcbiAgY29tbWVudHM6IC9cXC9cXCpbXipdKlxcKisoW14vKl1bXipdKlxcKispKlxcLy9naW0sXG4gIHBvcnQ6IC9AaW1wb3J0W147XSo7L2dpbSxcbiAgY3VzdG9tUHJvcDogLyg/Ol5bXjtcXC1cXHN9XSspPy0tW147e31dKj86W157fTtdKj8oPzpbO1xcbl18JCkvZ2ltLFxuICBtaXhpblByb3A6IC8oPzpeW147XFwtXFxzfV0rKT8tLVteO3t9XSo/Oltee307XSo/e1tefV0qP30oPzpbO1xcbl18JCk/L2dpbSxcbiAgbWl4aW5BcHBseTogL0BhcHBseVxccypcXCg/W14pO10qXFwpP1xccyooPzpbO1xcbl18JCk/L2dpbSxcbiAgdmFyQXBwbHk6IC9bXjs6XSo/OlteO10qP3ZhclxcKFteO10qXFwpKD86WztcXG5dfCQpPy9naW0sXG4gIGtleWZyYW1lc1J1bGU6IC9eQFteXFxzXSprZXlmcmFtZXMvLFxuICBtdWx0aXBsZVNwYWNlczogL1xccysvZ1xufVxuXG5jb25zdCBWQVJfU1RBUlQgPSAnLS0nO1xuY29uc3QgTUVESUFfU1RBUlQgPSAnQG1lZGlhJztcbmNvbnN0IEFUX1NUQVJUID0gJ0AnO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnQgY29uc3QgbmF0aXZlU2hhZG93ID0gISh3aW5kb3dbJ1NoYWR5RE9NJ10gJiYgd2luZG93WydTaGFkeURPTSddWydpblVzZSddKTtcbmxldCBuYXRpdmVDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIEBwYXJhbSB7KFNoYWR5Q1NTT3B0aW9ucyB8IFNoYWR5Q1NTSW50ZXJmYWNlKT19IHNldHRpbmdzXG4gKi9cbmZ1bmN0aW9uIGNhbGNDc3NWYXJpYWJsZXMoc2V0dGluZ3MpIHtcbiAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzWydzaGltY3NzcHJvcGVydGllcyddKSB7XG4gICAgbmF0aXZlQ3NzVmFyaWFibGVzXyA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIGNocm9tZSA0OSBoYXMgc2VtaS13b3JraW5nIGNzcyB2YXJzLCBjaGVjayBpZiBib3gtc2hhZG93IHdvcmtzXG4gICAgLy8gc2FmYXJpIDkuMSBoYXMgYSByZWNhbGMgYnVnOiBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU1NzgyXG4gICAgLy8gSG93ZXZlciwgc2hpbSBjc3MgY3VzdG9tIHByb3BlcnRpZXMgYXJlIG9ubHkgc3VwcG9ydGVkIHdpdGggU2hhZHlET00gZW5hYmxlZCxcbiAgICAvLyBzbyBmYWxsIGJhY2sgb24gbmF0aXZlIGlmIHdlIGRvIG5vdCBkZXRlY3QgU2hhZHlET01cbiAgICAvLyBFZGdlIDE1OiBjdXN0b20gcHJvcGVydGllcyB1c2VkIGluIDo6YmVmb3JlIGFuZCA6OmFmdGVyIHdpbGwgYWxzbyBiZSB1c2VkIGluIHRoZSBwYXJlbnQgZWxlbWVudFxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzEyNDE0MjU3L1xuICAgIG5hdGl2ZUNzc1ZhcmlhYmxlc18gPSBuYXRpdmVTaGFkb3cgfHwgQm9vbGVhbighbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaCgvQXBwbGVXZWJLaXRcXC82MDF8RWRnZVxcLzE1LykgJiZcbiAgICAgIHdpbmRvdy5DU1MgJiYgQ1NTLnN1cHBvcnRzICYmIENTUy5zdXBwb3J0cygnYm94LXNoYWRvdycsICcwIDAgMCB2YXIoLS1mb28pJykpO1xuICB9XG59XG5cbi8qKiBAdHlwZSB7c3RyaW5nIHwgdW5kZWZpbmVkfSAqL1xuZXhwb3J0IGxldCBjc3NCdWlsZDtcbmlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLmNzc0J1aWxkICE9PSB1bmRlZmluZWQpIHtcbiAgY3NzQnVpbGQgPSB3aW5kb3cuU2hhZHlDU1MuY3NzQnVpbGQ7XG59XG5cbi8qKiBAdHlwZSB7Ym9vbGVhbn0gKi9cbmV4cG9ydCBjb25zdCBkaXNhYmxlUnVudGltZSA9IEJvb2xlYW4od2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5kaXNhYmxlUnVudGltZSk7XG5cbmlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLm5hdGl2ZUNzcyAhPT0gdW5kZWZpbmVkKSB7XG4gIG5hdGl2ZUNzc1ZhcmlhYmxlc18gPSB3aW5kb3cuU2hhZHlDU1MubmF0aXZlQ3NzO1xufSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MpIHtcbiAgY2FsY0Nzc1ZhcmlhYmxlcyh3aW5kb3cuU2hhZHlDU1MpO1xuICAvLyByZXNldCB3aW5kb3cgdmFyaWFibGUgdG8gbGV0IFNoYWR5Q1NTIEFQSSB0YWtlIGl0cyBwbGFjZVxuICB3aW5kb3cuU2hhZHlDU1MgPSB1bmRlZmluZWQ7XG59IGVsc2Uge1xuICBjYWxjQ3NzVmFyaWFibGVzKHdpbmRvd1snV2ViQ29tcG9uZW50cyddICYmIHdpbmRvd1snV2ViQ29tcG9uZW50cyddWydmbGFncyddKTtcbn1cblxuLy8gSGFjayBmb3IgdHlwZSBlcnJvciB1bmRlciBuZXcgdHlwZSBpbmZlcmVuY2Ugd2hpY2ggZG9lc24ndCBsaWtlIHRoYXRcbi8vIG5hdGl2ZUNzc1ZhcmlhYmxlcyBpcyB1cGRhdGVkIGluIGEgZnVuY3Rpb24gYW5kIGFzc2lnbnMgdGhlIHR5cGVcbi8vIGBmdW5jdGlvbigpOiA/YCBpbnN0ZWFkIG9mIGBib29sZWFuYC5cbmV4cG9ydCBjb25zdCBuYXRpdmVDc3NWYXJpYWJsZXMgPSAvKiogQHR5cGUge2Jvb2xlYW59ICovKG5hdGl2ZUNzc1ZhcmlhYmxlc18pOyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbmV4cG9ydCBjb25zdCBWQVJfQVNTSUdOID0gLyg/Ol58WztcXHN7XVxccyopKC0tW1xcdy1dKj8pXFxzKjpcXHMqKD86KCg/OicoPzpcXFxcJ3wuKSo/J3xcIig/OlxcXFxcInwuKSo/XCJ8XFwoW14pXSo/XFwpfFtefTt7XSkrKXxcXHsoW159XSopXFx9KD86KD89WztcXHN9XSl8JCkpL2dpO1xuZXhwb3J0IGNvbnN0IE1JWElOX01BVENIID0gLyg/Ol58XFxXKylAYXBwbHlcXHMqXFwoPyhbXik7XFxuXSopXFwpPy9naTtcbmV4cG9ydCBjb25zdCBWQVJfQ09OU1VNRUQgPSAvKC0tW1xcdy1dKylcXHMqKFs6LDspXXwkKS9naTtcbmV4cG9ydCBjb25zdCBBTklNQVRJT05fTUFUQ0ggPSAvKGFuaW1hdGlvblxccyo6KXwoYW5pbWF0aW9uLW5hbWVcXHMqOikvO1xuZXhwb3J0IGNvbnN0IE1FRElBX01BVENIID0gL0BtZWRpYVxccyguKikvO1xuZXhwb3J0IGNvbnN0IElTX1ZBUiA9IC9eLS0vO1xuZXhwb3J0IGNvbnN0IEJSQUNLRVRFRCA9IC9cXHtbXn1dKlxcfS9nO1xuZXhwb3J0IGNvbnN0IEhPU1RfUFJFRklYID0gJyg/Ol58W14uI1s6XSknO1xuZXhwb3J0IGNvbnN0IEhPU1RfU1VGRklYID0gJygkfFsuOltcXFxccz4rfl0pJztcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqIEB0eXBlIHshU2V0PHN0cmluZz59ICovXG5jb25zdCBzdHlsZVRleHRTZXQgPSBuZXcgU2V0KCk7XG5cbmV4cG9ydCBjb25zdCBzY29waW5nQXR0cmlidXRlID0gJ3NoYWR5LXVuc2NvcGVkJztcblxuLyoqXG4gKiBBZGQgYSBzcGVjaWZpY2FsbHktbWFya2VkIHN0eWxlIHRvIHRoZSBkb2N1bWVudCBkaXJlY3RseSwgYW5kIG9ubHkgb25lIGNvcHkgb2YgdGhhdCBzdHlsZS5cbiAqXG4gKiBAcGFyYW0geyFIVE1MU3R5bGVFbGVtZW50fSBzdHlsZVxuICogQHJldHVybiB7dW5kZWZpbmVkfVxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJvY2Vzc1Vuc2NvcGVkU3R5bGUoc3R5bGUpIHtcbiAgY29uc3QgdGV4dCA9IHN0eWxlLnRleHRDb250ZW50O1xuICBpZiAoIXN0eWxlVGV4dFNldC5oYXModGV4dCkpIHtcbiAgICBzdHlsZVRleHRTZXQuYWRkKHRleHQpO1xuICAgIGNvbnN0IG5ld1N0eWxlID0gc3R5bGUuY2xvbmVOb2RlKHRydWUpO1xuICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobmV3U3R5bGUpO1xuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHlsZSBpcyBzdXBwb3NlZCB0byBiZSB1bnNjb3BlZFxuICogQHBhcmFtIHshSFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge2Jvb2xlYW59IHRydWUgaWYgdGhlIHN0eWxlIGhhcyB0aGUgdW5zY29waW5nIGF0dHJpYnV0ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNVbnNjb3BlZFN0eWxlKHN0eWxlKSB7XG4gIHJldHVybiBzdHlsZS5oYXNBdHRyaWJ1dGUoc2NvcGluZ0F0dHJpYnV0ZSk7XG59IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge25hdGl2ZVNoYWRvdywgbmF0aXZlQ3NzVmFyaWFibGVzLCBjc3NCdWlsZH0gZnJvbSAnLi9zdHlsZS1zZXR0aW5ncy5qcyc7XG5pbXBvcnQge3BhcnNlLCBzdHJpbmdpZnksIHR5cGVzLCBTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtNRURJQV9NQVRDSH0gZnJvbSAnLi9jb21tb24tcmVnZXguanMnO1xuaW1wb3J0IHtwcm9jZXNzVW5zY29wZWRTdHlsZSwgaXNVbnNjb3BlZFN0eWxlfSBmcm9tICcuL3Vuc2NvcGVkLXN0eWxlLWhhbmRsZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfFN0eWxlTm9kZX0gcnVsZXNcbiAqIEBwYXJhbSB7ZnVuY3Rpb24oU3R5bGVOb2RlKT19IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0Nzc1RleHQgKHJ1bGVzLCBjYWxsYmFjaykge1xuICBpZiAoIXJ1bGVzKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIGlmICh0eXBlb2YgcnVsZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgcnVsZXMgPSBwYXJzZShydWxlcyk7XG4gIH1cbiAgaWYgKGNhbGxiYWNrKSB7XG4gICAgZm9yRWFjaFJ1bGUocnVsZXMsIGNhbGxiYWNrKTtcbiAgfVxuICByZXR1cm4gc3RyaW5naWZ5KHJ1bGVzLCBuYXRpdmVDc3NWYXJpYWJsZXMpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEByZXR1cm4ge1N0eWxlTm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJ1bGVzRm9yU3R5bGUoc3R5bGUpIHtcbiAgaWYgKCFzdHlsZVsnX19jc3NSdWxlcyddICYmIHN0eWxlLnRleHRDb250ZW50KSB7XG4gICAgc3R5bGVbJ19fY3NzUnVsZXMnXSA9IHBhcnNlKHN0eWxlLnRleHRDb250ZW50KTtcbiAgfVxuICByZXR1cm4gc3R5bGVbJ19fY3NzUnVsZXMnXSB8fCBudWxsO1xufVxuXG4vLyBUZXN0cyBpZiBhIHJ1bGUgaXMgYSBrZXlmcmFtZXMgc2VsZWN0b3IsIHdoaWNoIGxvb2tzIGFsbW9zdCBleGFjdGx5XG4vLyBsaWtlIGEgbm9ybWFsIHNlbGVjdG9yIGJ1dCBpcyBub3QgKGl0IGhhcyBub3RoaW5nIHRvIGRvIHdpdGggc2NvcGluZ1xuLy8gZm9yIGV4YW1wbGUpLlxuLyoqXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzS2V5ZnJhbWVzU2VsZWN0b3IocnVsZSkge1xuICByZXR1cm4gQm9vbGVhbihydWxlWydwYXJlbnQnXSkgJiZcbiAgcnVsZVsncGFyZW50J11bJ3R5cGUnXSA9PT0gdHlwZXMuS0VZRlJBTUVTX1JVTEU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7RnVuY3Rpb249fSBzdHlsZVJ1bGVDYWxsYmFja1xuICogQHBhcmFtIHtGdW5jdGlvbj19IGtleWZyYW1lc1J1bGVDYWxsYmFja1xuICogQHBhcmFtIHtib29sZWFuPX0gb25seUFjdGl2ZVJ1bGVzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmb3JFYWNoUnVsZShub2RlLCBzdHlsZVJ1bGVDYWxsYmFjaywga2V5ZnJhbWVzUnVsZUNhbGxiYWNrLCBvbmx5QWN0aXZlUnVsZXMpIHtcbiAgaWYgKCFub2RlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGxldCBza2lwUnVsZXMgPSBmYWxzZTtcbiAgbGV0IHR5cGUgPSBub2RlWyd0eXBlJ107XG4gIGlmIChvbmx5QWN0aXZlUnVsZXMpIHtcbiAgICBpZiAodHlwZSA9PT0gdHlwZXMuTUVESUFfUlVMRSkge1xuICAgICAgbGV0IG1hdGNoTWVkaWEgPSBub2RlWydzZWxlY3RvciddLm1hdGNoKE1FRElBX01BVENIKTtcbiAgICAgIGlmIChtYXRjaE1lZGlhKSB7XG4gICAgICAgIC8vIGlmIHJ1bGUgaXMgYSBub24gbWF0Y2hpbmcgQG1lZGlhIHJ1bGUsIHNraXAgc3VicnVsZXNcbiAgICAgICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShtYXRjaE1lZGlhWzFdKS5tYXRjaGVzKSB7XG4gICAgICAgICAgc2tpcFJ1bGVzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBpZiAodHlwZSA9PT0gdHlwZXMuU1RZTEVfUlVMRSkge1xuICAgIHN0eWxlUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKGtleWZyYW1lc1J1bGVDYWxsYmFjayAmJlxuICAgIHR5cGUgPT09IHR5cGVzLktFWUZSQU1FU19SVUxFKSB7XG4gICAga2V5ZnJhbWVzUnVsZUNhbGxiYWNrKG5vZGUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IHR5cGVzLk1JWElOX1JVTEUpIHtcbiAgICBza2lwUnVsZXMgPSB0cnVlO1xuICB9XG4gIGxldCByJCA9IG5vZGVbJ3J1bGVzJ107XG4gIGlmIChyJCAmJiAhc2tpcFJ1bGVzKSB7XG4gICAgZm9yIChsZXQgaT0wLCBsPXIkLmxlbmd0aCwgcjsgKGk8bCkgJiYgKHI9ciRbaV0pOyBpKyspIHtcbiAgICAgIGZvckVhY2hSdWxlKHIsIHN0eWxlUnVsZUNhbGxiYWNrLCBrZXlmcmFtZXNSdWxlQ2FsbGJhY2ssIG9ubHlBY3RpdmVSdWxlcyk7XG4gICAgfVxuICB9XG59XG5cbi8vIGFkZCBhIHN0cmluZyBvZiBjc3NUZXh0IHRvIHRoZSBkb2N1bWVudC5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGNzc1RleHRcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcGFyYW0ge05vZGV9IHRhcmdldFxuICogQHBhcmFtIHtOb2RlfSBjb250ZXh0Tm9kZVxuICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5Q3NzKGNzc1RleHQsIG1vbmlrZXIsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgbGV0IHN0eWxlID0gY3JlYXRlU2NvcGVTdHlsZShjc3NUZXh0LCBtb25pa2VyKTtcbiAgYXBwbHlTdHlsZShzdHlsZSwgdGFyZ2V0LCBjb250ZXh0Tm9kZSk7XG4gIHJldHVybiBzdHlsZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3NzVGV4dFxuICogQHBhcmFtIHtzdHJpbmd9IG1vbmlrZXJcbiAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTY29wZVN0eWxlKGNzc1RleHQsIG1vbmlrZXIpIHtcbiAgbGV0IHN0eWxlID0gLyoqIEB0eXBlIHtIVE1MU3R5bGVFbGVtZW50fSAqLyhkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpKTtcbiAgaWYgKG1vbmlrZXIpIHtcbiAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoJ3Njb3BlJywgbW9uaWtlcik7XG4gIH1cbiAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICByZXR1cm4gc3R5bGU7XG59XG5cbi8qKlxuICogVHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoZSBsYXN0IGFkZGVkIHN0eWxlIGZvciBwbGFjaW5nIHBsYWNlaG9sZGVyc1xuICogQHR5cGUge05vZGV9XG4gKi9cbmxldCBsYXN0SGVhZEFwcGx5Tm9kZSA9IG51bGw7XG5cbi8vIGluc2VydCBhIGNvbW1lbnQgbm9kZSBhcyBhIHN0eWxpbmcgcG9zaXRpb24gcGxhY2Vob2xkZXIuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb25pa2VyXG4gKiBAcmV0dXJuIHshQ29tbWVudH1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGVQbGFjZUhvbGRlcihtb25pa2VyKSB7XG4gIGxldCBwbGFjZUhvbGRlciA9IGRvY3VtZW50LmNyZWF0ZUNvbW1lbnQoJyBTaGFkeSBET00gc3R5bGVzIGZvciAnICtcbiAgICBtb25pa2VyICsgJyAnKTtcbiAgbGV0IGFmdGVyID0gbGFzdEhlYWRBcHBseU5vZGUgP1xuICAgIGxhc3RIZWFkQXBwbHlOb2RlWyduZXh0U2libGluZyddIDogbnVsbDtcbiAgbGV0IHNjb3BlID0gZG9jdW1lbnQuaGVhZDtcbiAgc2NvcGUuaW5zZXJ0QmVmb3JlKHBsYWNlSG9sZGVyLCBhZnRlciB8fCBzY29wZS5maXJzdENoaWxkKTtcbiAgbGFzdEhlYWRBcHBseU5vZGUgPSBwbGFjZUhvbGRlcjtcbiAgcmV0dXJuIHBsYWNlSG9sZGVyO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAqIEBwYXJhbSB7P05vZGV9IHRhcmdldFxuICogQHBhcmFtIHs/Tm9kZX0gY29udGV4dE5vZGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5U3R5bGUoc3R5bGUsIHRhcmdldCwgY29udGV4dE5vZGUpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IGRvY3VtZW50LmhlYWQ7XG4gIGxldCBhZnRlciA9IChjb250ZXh0Tm9kZSAmJiBjb250ZXh0Tm9kZS5uZXh0U2libGluZykgfHxcbiAgICB0YXJnZXQuZmlyc3RDaGlsZDtcbiAgdGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgYWZ0ZXIpO1xuICBpZiAoIWxhc3RIZWFkQXBwbHlOb2RlKSB7XG4gICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBvbmx5IHVwZGF0ZSBsYXN0SGVhZEFwcGx5Tm9kZSBpZiB0aGUgbmV3IHN0eWxlIGlzIGluc2VydGVkIGFmdGVyIHRoZSBvbGQgbGFzdEhlYWRBcHBseU5vZGVcbiAgICBsZXQgcG9zaXRpb24gPSBzdHlsZS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihsYXN0SGVhZEFwcGx5Tm9kZSk7XG4gICAgaWYgKHBvc2l0aW9uID09PSBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX1BSRUNFRElORykge1xuICAgICAgbGFzdEhlYWRBcHBseU5vZGUgPSBzdHlsZTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gYnVpbGRUeXBlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUYXJnZXRlZEJ1aWxkKGJ1aWxkVHlwZSkge1xuICByZXR1cm4gbmF0aXZlU2hhZG93ID8gYnVpbGRUeXBlID09PSAnc2hhZG93JyA6IGJ1aWxkVHlwZSA9PT0gJ3NoYWR5Jztcbn1cblxuLyoqXG4gKiBXYWxrIGZyb20gdGV4dFtzdGFydF0gbWF0Y2hpbmcgcGFyZW5zIGFuZFxuICogcmV0dXJucyBwb3NpdGlvbiBvZiB0aGUgb3V0ZXIgZW5kIHBhcmVuXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0XG4gKiBAcmV0dXJuIHtudW1iZXJ9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTWF0Y2hpbmdQYXJlbih0ZXh0LCBzdGFydCkge1xuICBsZXQgbGV2ZWwgPSAwO1xuICBmb3IgKGxldCBpPXN0YXJ0LCBsPXRleHQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHRleHRbaV0gPT09ICcoJykge1xuICAgICAgbGV2ZWwrKztcbiAgICB9IGVsc2UgaWYgKHRleHRbaV0gPT09ICcpJykge1xuICAgICAgaWYgKC0tbGV2ZWwgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiAtMTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgc3RyaW5nLCBzdHJpbmcsIHN0cmluZyl9IGNhbGxiYWNrXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIsIGNhbGxiYWNrKSB7XG4gIC8vIGZpbmQgJ3ZhcignXG4gIGxldCBzdGFydCA9IHN0ci5pbmRleE9mKCd2YXIoJyk7XG4gIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAvLyBubyB2YXI/LCBldmVyeXRoaW5nIGlzIHByZWZpeFxuICAgIHJldHVybiBjYWxsYmFjayhzdHIsICcnLCAnJywgJycpO1xuICB9XG4gIC8vJHtwcmVmaXh9dmFyKCR7aW5uZXJ9KSR7c3VmZml4fVxuICBsZXQgZW5kID0gZmluZE1hdGNoaW5nUGFyZW4oc3RyLCBzdGFydCArIDMpO1xuICBsZXQgaW5uZXIgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0ICsgNCwgZW5kKTtcbiAgbGV0IHByZWZpeCA9IHN0ci5zdWJzdHJpbmcoMCwgc3RhcnQpO1xuICAvLyBzdWZmaXggbWF5IGhhdmUgb3RoZXIgdmFyaWFibGVzXG4gIGxldCBzdWZmaXggPSBwcm9jZXNzVmFyaWFibGVBbmRGYWxsYmFjayhzdHIuc3Vic3RyaW5nKGVuZCArIDEpLCBjYWxsYmFjayk7XG4gIGxldCBjb21tYSA9IGlubmVyLmluZGV4T2YoJywnKTtcbiAgLy8gdmFsdWUgYW5kIGZhbGxiYWNrIGFyZ3Mgc2hvdWxkIGJlIHRyaW1tZWQgdG8gbWF0Y2ggaW4gcHJvcGVydHkgbG9va3VwXG4gIGlmIChjb21tYSA9PT0gLTEpIHtcbiAgICAvLyB2YXJpYWJsZSwgbm8gZmFsbGJhY2tcbiAgICByZXR1cm4gY2FsbGJhY2socHJlZml4LCBpbm5lci50cmltKCksICcnLCBzdWZmaXgpO1xuICB9XG4gIC8vIHZhcigke3ZhbHVlfSwke2ZhbGxiYWNrfSlcbiAgbGV0IHZhbHVlID0gaW5uZXIuc3Vic3RyaW5nKDAsIGNvbW1hKS50cmltKCk7XG4gIGxldCBmYWxsYmFjayA9IGlubmVyLnN1YnN0cmluZyhjb21tYSArIDEpLnRyaW0oKTtcbiAgcmV0dXJuIGNhbGxiYWNrKHByZWZpeCwgdmFsdWUsIGZhbGxiYWNrLCBzdWZmaXgpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgdmFsdWUpIHtcbiAgLy8gdXNlIG5hdGl2ZSBzZXRBdHRyaWJ1dGUgcHJvdmlkZWQgYnkgU2hhZHlET00gd2hlbiBzZXRBdHRyaWJ1dGUgaXMgcGF0Y2hlZFxuICBpZiAobmF0aXZlU2hhZG93KSB7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIHdpbmRvd1snU2hhZHlET00nXVsnbmF0aXZlTWV0aG9kcyddWydzZXRBdHRyaWJ1dGUnXS5jYWxsKGVsZW1lbnQsICdjbGFzcycsIHZhbHVlKTtcbiAgfVxufVxuXG4vKipcbiAqIEB0eXBlIHtmdW5jdGlvbigqKToqfVxuICovXG5leHBvcnQgY29uc3Qgd3JhcCA9IHdpbmRvd1snU2hhZHlET00nXSAmJiB3aW5kb3dbJ1NoYWR5RE9NJ11bJ3dyYXAnXSB8fCAoKG5vZGUpID0+IG5vZGUpO1xuXG4vKipcbiAqIEBwYXJhbSB7RWxlbWVudCB8IHtpczogc3RyaW5nLCBleHRlbmRzOiBzdHJpbmd9fSBlbGVtZW50XG4gKiBAcmV0dXJuIHt7aXM6IHN0cmluZywgdHlwZUV4dGVuc2lvbjogc3RyaW5nfX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldElzRXh0ZW5kcyhlbGVtZW50KSB7XG4gIGxldCBsb2NhbE5hbWUgPSBlbGVtZW50Wydsb2NhbE5hbWUnXTtcbiAgbGV0IGlzID0gJycsIHR5cGVFeHRlbnNpb24gPSAnJztcbiAgLypcbiAgTk9URTogdGVjaG5pY2FsbHksIHRoaXMgY2FuIGJlIHdyb25nIGZvciBjZXJ0YWluIHN2ZyBlbGVtZW50c1xuICB3aXRoIGAtYCBpbiB0aGUgbmFtZSBsaWtlIGA8Zm9udC1mYWNlPmBcbiAgKi9cbiAgaWYgKGxvY2FsTmFtZSkge1xuICAgIGlmIChsb2NhbE5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIGlzID0gbG9jYWxOYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICB0eXBlRXh0ZW5zaW9uID0gbG9jYWxOYW1lO1xuICAgICAgaXMgPSAoZWxlbWVudC5nZXRBdHRyaWJ1dGUgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2lzJykpIHx8ICcnO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpcyA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuaXM7XG4gICAgdHlwZUV4dGVuc2lvbiA9IC8qKiBAdHlwZSB7P30gKi8oZWxlbWVudCkuZXh0ZW5kcztcbiAgfVxuICByZXR1cm4ge2lzLCB0eXBlRXh0ZW5zaW9ufTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR8RG9jdW1lbnRGcmFnbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2F0aGVyU3R5bGVUZXh0KGVsZW1lbnQpIHtcbiAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgY29uc3Qgc3R5bGVUZXh0UGFydHMgPSBbXTtcbiAgY29uc3Qgc3R5bGVzID0gLyoqIEB0eXBlIHshTm9kZUxpc3Q8IUhUTUxTdHlsZUVsZW1lbnQ+fSAqLyhlbGVtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3N0eWxlJykpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHN0eWxlID0gc3R5bGVzW2ldO1xuICAgIGlmIChpc1Vuc2NvcGVkU3R5bGUoc3R5bGUpKSB7XG4gICAgICBpZiAoIW5hdGl2ZVNoYWRvdykge1xuICAgICAgICBwcm9jZXNzVW5zY29wZWRTdHlsZShzdHlsZSk7XG4gICAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZVRleHRQYXJ0cy5wdXNoKHN0eWxlLnRleHRDb250ZW50KTtcbiAgICAgIHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3R5bGVUZXh0UGFydHMuam9pbignJykudHJpbSgpO1xufVxuXG4vKipcbiAqIFNwbGl0IGEgc2VsZWN0b3Igc2VwYXJhdGVkIGJ5IGNvbW1hcyBpbnRvIGFuIGFycmF5IGluIGEgc21hcnQgd2F5XG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4geyFBcnJheTxzdHJpbmc+fVxuICovXG5leHBvcnQgZnVuY3Rpb24gc3BsaXRTZWxlY3Rvckxpc3Qoc2VsZWN0b3IpIHtcbiAgY29uc3QgcGFydHMgPSBbXTtcbiAgbGV0IHBhcnQgPSAnJztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPj0gMCAmJiBpIDwgc2VsZWN0b3IubGVuZ3RoOyBpKyspIHtcbiAgICAvLyBBIHNlbGVjdG9yIHdpdGggcGFyZW50aGVzZXMgd2lsbCBiZSBvbmUgY29tcGxldGUgcGFydFxuICAgIGlmIChzZWxlY3RvcltpXSA9PT0gJygnKSB7XG4gICAgICAvLyBmaW5kIHRoZSBtYXRjaGluZyBwYXJlblxuICAgICAgY29uc3QgZW5kID0gZmluZE1hdGNoaW5nUGFyZW4oc2VsZWN0b3IsIGkpO1xuICAgICAgLy8gcHVzaCB0aGUgcGFyZW4gYmxvY2sgaW50byB0aGUgcGFydFxuICAgICAgcGFydCArPSBzZWxlY3Rvci5zbGljZShpLCBlbmQgKyAxKTtcbiAgICAgIC8vIG1vdmUgdGhlIGluZGV4IHRvIGFmdGVyIHRoZSBwYXJlbiBibG9ja1xuICAgICAgaSA9IGVuZDtcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yW2ldID09PSAnLCcpIHtcbiAgICAgIHBhcnRzLnB1c2gocGFydCk7XG4gICAgICBwYXJ0ID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnQgKz0gc2VsZWN0b3JbaV07XG4gICAgfVxuICB9XG4gIC8vIGNhdGNoIGFueSBwaWVjZXMgYWZ0ZXIgdGhlIGxhc3QgY29tbWFcbiAgaWYgKHBhcnQpIHtcbiAgICBwYXJ0cy5wdXNoKHBhcnQpO1xuICB9XG4gIHJldHVybiBwYXJ0cztcbn1cblxuY29uc3QgQ1NTX0JVSUxEX0FUVFIgPSAnY3NzLWJ1aWxkJztcblxuLyoqXG4gKiBSZXR1cm4gdGhlIHBvbHltZXItY3NzLWJ1aWxkIFwiYnVpbGQgdHlwZVwiIGFwcGxpZWQgdG8gdGhpcyBlbGVtZW50XG4gKlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm4ge3N0cmluZ30gQ2FuIGJlIFwiXCIsIFwic2hhZHlcIiwgb3IgXCJzaGFkb3dcIlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3NzQnVpbGQoZWxlbWVudCkge1xuICBpZiAoY3NzQnVpbGQgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAvKiogQHR5cGUge3N0cmluZ30gKi8oY3NzQnVpbGQpO1xuICB9XG4gIGlmIChlbGVtZW50Ll9fY3NzQnVpbGQgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHRyeSBhdHRyaWJ1dGUgZmlyc3QsIGFzIGl0IGlzIHRoZSBjb21tb24gY2FzZVxuICAgIGNvbnN0IGF0dHJWYWx1ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKENTU19CVUlMRF9BVFRSKTtcbiAgICBpZiAoYXR0clZhbHVlKSB7XG4gICAgICBlbGVtZW50Ll9fY3NzQnVpbGQgPSBhdHRyVmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1aWxkQ29tbWVudCA9IGdldEJ1aWxkQ29tbWVudChlbGVtZW50KTtcbiAgICAgIGlmIChidWlsZENvbW1lbnQgIT09ICcnKSB7XG4gICAgICAgIC8vIHJlbW92ZSBidWlsZCBjb21tZW50IHNvIGl0IGlzIG5vdCBuZWVkbGVzc2x5IGNvcGllZCBpbnRvIGV2ZXJ5IGVsZW1lbnQgaW5zdGFuY2VcbiAgICAgICAgcmVtb3ZlQnVpbGRDb21tZW50KGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5fX2Nzc0J1aWxkID0gYnVpbGRDb21tZW50O1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWxlbWVudC5fX2Nzc0J1aWxkIHx8ICcnO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBnaXZlbiBlbGVtZW50LCBlaXRoZXIgYSA8dGVtcGxhdGU+IG9yIDxzdHlsZT4sIGhhcyBiZWVuIHByb2Nlc3NlZFxuICogYnkgcG9seW1lci1jc3MtYnVpbGQuXG4gKlxuICogSWYgc28sIHRoZW4gd2UgY2FuIG1ha2UgYSBudW1iZXIgb2Ygb3B0aW1pemF0aW9uczpcbiAqIC0gcG9seW1lci1jc3MtYnVpbGQgd2lsbCBkZWNvbXBvc2UgbWl4aW5zIGludG8gaW5kaXZpZHVhbCBDU1MgQ3VzdG9tIFByb3BlcnRpZXMsXG4gKiBzbyB0aGUgQXBwbHlTaGltIGNhbiBiZSBza2lwcGVkIGVudGlyZWx5LlxuICogLSBVbmRlciBuYXRpdmUgU2hhZG93RE9NLCB0aGUgc3R5bGUgdGV4dCBjYW4ganVzdCBiZSBjb3BpZWQgaW50byBlYWNoIGluc3RhbmNlXG4gKiB3aXRob3V0IG1vZGlmaWNhdGlvblxuICogLSBJZiB0aGUgYnVpbGQgaXMgXCJzaGFkeVwiIGFuZCBTaGFkeURPTSBpcyBpbiB1c2UsIHRoZSBzdHlsaW5nIGRvZXMgbm90IG5lZWRcbiAqIHNjb3BpbmcgYmV5b25kIHRoZSBzaGltbWluZyBvZiBDU1MgQ3VzdG9tIFByb3BlcnRpZXNcbiAqXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVsZW1lbnRIYXNCdWlsdENzcyhlbGVtZW50KSB7XG4gIHJldHVybiBnZXRDc3NCdWlsZChlbGVtZW50KSAhPT0gJyc7XG59XG5cbi8qKlxuICogRm9yIHRlbXBsYXRlcyBtYWRlIHdpdGggdGFnZ2VkIHRlbXBsYXRlIGxpdGVyYWxzLCBwb2x5bWVyLWNzcy1idWlsZCB3aWxsXG4gKiBpbnNlcnQgYSBjb21tZW50IG9mIHRoZSBmb3JtIGA8IS0tY3NzLWJ1aWxkOnNoYWRvdy0tPmBcbiAqXG4gKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0QnVpbGRDb21tZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgYnVpbGRDb21tZW50ID0gZWxlbWVudC5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgP1xuICAgICAgLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKGVsZW1lbnQpLmNvbnRlbnQuZmlyc3RDaGlsZCA6XG4gICAgICBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gIGlmIChidWlsZENvbW1lbnQgaW5zdGFuY2VvZiBDb21tZW50KSB7XG4gICAgY29uc3QgY29tbWVudFBhcnRzID0gYnVpbGRDb21tZW50LnRleHRDb250ZW50LnRyaW0oKS5zcGxpdCgnOicpO1xuICAgIGlmIChjb21tZW50UGFydHNbMF0gPT09IENTU19CVUlMRF9BVFRSKSB7XG4gICAgICByZXR1cm4gY29tbWVudFBhcnRzWzFdO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGNzcyBidWlsZCBzdGF0dXMgaXMgb3B0aW1hbCwgYW5kIGRvIG5vIHVubmVlZGVkIHdvcmsuXG4gKlxuICogQHBhcmFtIHtzdHJpbmc9fSBjc3NCdWlsZCBDU1MgYnVpbGQgc3RhdHVzXG4gKiBAcmV0dXJuIHtib29sZWFufSBjc3MgYnVpbGQgaXMgb3B0aW1hbCBvciBub3RcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT3B0aW1hbENzc0J1aWxkKGNzc0J1aWxkID0gJycpIHtcbiAgLy8gQ1NTIGN1c3RvbSBwcm9wZXJ0eSBzaGltIGFsd2F5cyByZXF1aXJlcyB3b3JrXG4gIGlmIChjc3NCdWlsZCA9PT0gJycgfHwgIW5hdGl2ZUNzc1ZhcmlhYmxlcykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gbmF0aXZlU2hhZG93ID8gY3NzQnVpbGQgPT09ICdzaGFkb3cnIDogY3NzQnVpbGQgPT09ICdzaGFkeSc7XG59XG5cbi8qKlxuICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQnVpbGRDb21tZW50KGVsZW1lbnQpIHtcbiAgY29uc3QgYnVpbGRDb21tZW50ID0gZWxlbWVudC5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScgP1xuICAgICAgLyoqIEB0eXBlIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gKi8gKGVsZW1lbnQpLmNvbnRlbnQuZmlyc3RDaGlsZCA6XG4gICAgICBlbGVtZW50LmZpcnN0Q2hpbGQ7XG4gIGJ1aWxkQ29tbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGJ1aWxkQ29tbWVudCk7XG59XG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcbmltcG9ydCAqIGFzIFN0eWxlVXRpbCBmcm9tICcuL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0IHtuYXRpdmVTaGFkb3d9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuXG4vKiBUcmFuc2Zvcm1zIFNoYWRvd0RPTSBzdHlsaW5nIGludG8gU2hhZHlET00gc3R5bGluZ1xuXG4qIHNjb3Bpbmc6XG5cbiAgKiBlbGVtZW50cyBpbiBzY29wZSBnZXQgc2NvcGluZyBzZWxlY3RvciBjbGFzcz1cIngtZm9vLXNjb3BlXCJcbiAgKiBzZWxlY3RvcnMgcmUtd3JpdHRlbiBhcyBmb2xsb3dzOlxuXG4gICAgZGl2IGJ1dHRvbiAtPiBkaXYueC1mb28tc2NvcGUgYnV0dG9uLngtZm9vLXNjb3BlXG5cbiogOmhvc3QgLT4gc2NvcGVOYW1lXG5cbiogOmhvc3QoLi4uKSAtPiBzY29wZU5hbWUuLi5cblxuKiA6OnNsb3R0ZWQoLi4uKSAtPiBzY29wZU5hbWUgPiAuLi5cblxuKiAuLi46ZGlyKGx0cnxydGwpIC0+IFtkaXI9XCJsdHJ8cnRsXCJdIC4uLiwgLi4uW2Rpcj1cImx0cnxydGxcIl1cblxuKiA6aG9zdCg6ZGlyW3J0bF0pIC0+IHNjb3BlTmFtZTpkaXIocnRsKSAtPiBbZGlyPVwicnRsXCJdIHNjb3BlTmFtZSwgc2NvcGVOYW1lW2Rpcj1cInJ0bFwiXVxuXG4qL1xuY29uc3QgU0NPUEVfTkFNRSA9ICdzdHlsZS1zY29wZSc7XG5cbmNsYXNzIFN0eWxlVHJhbnNmb3JtZXIge1xuICBnZXQgU0NPUEVfTkFNRSgpIHtcbiAgICByZXR1cm4gU0NPUEVfTkFNRTtcbiAgfVxuICAvKipcbiAgICogR2l2ZW4gYSBub2RlIGFuZCBzY29wZSBuYW1lLCBhZGQgYSBzY29waW5nIGNsYXNzIHRvIGVhY2ggbm9kZVxuICAgKiBpbiB0aGUgdHJlZS4gVGhpcyBmYWNpbGl0YXRlcyB0cmFuc2Zvcm1pbmcgY3NzIGludG8gc2NvcGVkIHJ1bGVzLlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuICAgKiBAcGFyYW0ge2Jvb2xlYW49fSBzaG91bGRSZW1vdmVTY29wZVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgZG9tKG5vZGUsIHNjb3BlLCBzaG91bGRSZW1vdmVTY29wZSkge1xuICAgIGNvbnN0IGZuID0gKG5vZGUpID0+IHtcbiAgICAgIHRoaXMuZWxlbWVudChub2RlLCBzY29wZSB8fCAnJywgc2hvdWxkUmVtb3ZlU2NvcGUpO1xuICAgIH07XG4gICAgdGhpcy5fdHJhbnNmb3JtRG9tKG5vZGUsIGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG5vZGUgYW5kIHNjb3BlIG5hbWUsIGFkZCBhIHNjb3BpbmcgY2xhc3MgdG8gZWFjaCBub2RlIGluIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuICAgKi9cbiAgZG9tQWRkU2NvcGUobm9kZSwgc2NvcGUpIHtcbiAgICBjb25zdCBmbiA9IChub2RlKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQobm9kZSwgc2NvcGUgfHwgJycpO1xuICAgIH07XG4gICAgdGhpcy5fdHJhbnNmb3JtRG9tKG5vZGUsIGZuKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBzdGFydE5vZGVcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oIU5vZGUpfSB0cmFuc2Zvcm1lclxuICAgKi9cbiAgX3RyYW5zZm9ybURvbShzdGFydE5vZGUsIHRyYW5zZm9ybWVyKSB7XG4gICAgaWYgKHN0YXJ0Tm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgIHRyYW5zZm9ybWVyKHN0YXJ0Tm9kZSlcbiAgICB9XG4gICAgbGV0IGMkO1xuICAgIGlmIChzdGFydE5vZGUubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChzdGFydE5vZGUpO1xuICAgICAgLy8gSW4gY2FzZSB0aGUgdGVtcGxhdGUgaXMgaW4gc3ZnIGNvbnRleHQsIGZhbGwgYmFjayB0byB0aGUgbm9kZVxuICAgICAgLy8gc2luY2UgaXQgd29uJ3QgYmUgYW4gSFRNTFRlbXBsYXRlRWxlbWVudCB3aXRoIGEgLmNvbnRlbnQgcHJvcGVydHlcbiAgICAgIGMkID0gKHRlbXBsYXRlLmNvbnRlbnQgfHwgdGVtcGxhdGUuX2NvbnRlbnQgfHwgdGVtcGxhdGUpLmNoaWxkTm9kZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGMkID0gLyoqIEB0eXBlIHshUGFyZW50Tm9kZX0gKi8gKHN0YXJ0Tm9kZSkuY2hpbGRyZW4gfHxcbiAgICAgICAgICBzdGFydE5vZGUuY2hpbGROb2RlcztcbiAgICB9XG4gICAgaWYgKGMkKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGMkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybURvbShjJFtpXSwgdHJhbnNmb3JtZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez99IGVsZW1lbnRcbiAgICogQHBhcmFtIHs/fSBzY29wZVxuICAgKiBAcGFyYW0gez89fSBzaG91bGRSZW1vdmVTY29wZVxuICAgKi9cbiAgZWxlbWVudChlbGVtZW50LCBzY29wZSwgc2hvdWxkUmVtb3ZlU2NvcGUpIHtcbiAgICAvLyBub3RlOiBpZiB1c2luZyBjbGFzc2VzLCB3ZSBhZGQgYm90aCB0aGUgZ2VuZXJhbCAnc3R5bGUtc2NvcGUnIGNsYXNzXG4gICAgLy8gYXMgd2VsbCBhcyB0aGUgc3BlY2lmaWMgc2NvcGUuIFRoaXMgZW5hYmxlcyBlYXN5IGZpbHRlcmluZyBvZiBhbGxcbiAgICAvLyBgc3R5bGUtc2NvcGVgIGVsZW1lbnRzXG4gICAgaWYgKHNjb3BlKSB7XG4gICAgICAvLyBub3RlOiBzdmcgb24gSUUgZG9lcyBub3QgaGF2ZSBjbGFzc0xpc3Qgc28gZmFsbGJhY2sgdG8gY2xhc3NcbiAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdCkge1xuICAgICAgICBpZiAoc2hvdWxkUmVtb3ZlU2NvcGUpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoU0NPUEVfTkFNRSk7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKHNjb3BlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoU0NPUEVfTkFNRSk7XG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSkge1xuICAgICAgICBsZXQgYyA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKENMQVNTKTtcbiAgICAgICAgaWYgKHNob3VsZFJlbW92ZVNjb3BlKSB7XG4gICAgICAgICAgaWYgKGMpIHtcbiAgICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IGMucmVwbGFjZShTQ09QRV9OQU1FLCAnJykucmVwbGFjZShzY29wZSwgJycpO1xuICAgICAgICAgICAgU3R5bGVVdGlsLnNldEVsZW1lbnRDbGFzc1JhdyhlbGVtZW50LCBuZXdWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBuZXdWYWx1ZSA9IChjID8gYyArICcgJyA6ICcnKSArIFNDT1BFX05BTUUgKyAnICcgKyBzY29wZTtcbiAgICAgICAgICBTdHlsZVV0aWwuc2V0RWxlbWVudENsYXNzUmF3KGVsZW1lbnQsIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG5vZGUsIHJlcGxhY2UgdGhlIHNjb3BpbmcgY2xhc3MgdG8gZWFjaCBzdWJub2RlIGluIHRoZSB0cmVlLlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBvbGRTY29wZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3U2NvcGVcbiAgICovXG4gIGRvbVJlcGxhY2VTY29wZShub2RlLCBvbGRTY29wZSwgbmV3U2NvcGUpIHtcbiAgICBjb25zdCBmbiA9IChub2RlKSA9PiB7XG4gICAgICB0aGlzLmVsZW1lbnQobm9kZSwgb2xkU2NvcGUsIHRydWUpO1xuICAgICAgdGhpcy5lbGVtZW50KG5vZGUsIG5ld1Njb3BlKTtcbiAgICB9O1xuICAgIHRoaXMuX3RyYW5zZm9ybURvbShub2RlLCBmbik7XG4gIH1cbiAgLyoqXG4gICAqIEdpdmVuIGEgbm9kZSwgcmVtb3ZlIHRoZSBzY29waW5nIGNsYXNzIHRvIGVhY2ggc3Vibm9kZSBpbiB0aGUgdHJlZS5cbiAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkU2NvcGVcbiAgICovXG4gIGRvbVJlbW92ZVNjb3BlKG5vZGUsIG9sZFNjb3BlKSB7XG4gICAgY29uc3QgZm4gPSAobm9kZSkgPT4ge1xuICAgICAgdGhpcy5lbGVtZW50KG5vZGUsIG9sZFNjb3BlIHx8ICcnLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuX3RyYW5zZm9ybURvbShub2RlLCBmbik7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7P30gc3R5bGVSdWxlc1xuICAgKiBAcGFyYW0gez89fSBjYWxsYmFja1xuICAgKiBAcGFyYW0ge3N0cmluZz19IGNzc0J1aWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBlbGVtZW50U3R5bGVzKGVsZW1lbnQsIHN0eWxlUnVsZXMsIGNhbGxiYWNrLCBjc3NCdWlsZCA9ICcnLCBjc3NUZXh0ID0gJycpIHtcbiAgICAvLyBubyBuZWVkIHRvIHNoaW0gc2VsZWN0b3JzIGlmIHNldHRpbmdzLnVzZU5hdGl2ZVNoYWRvdywgYWxzb1xuICAgIC8vIGEgc2hhZHkgY3NzIGJ1aWxkIHdpbGwgYWxyZWFkeSBoYXZlIHRyYW5zZm9ybWVkIHNlbGVjdG9yc1xuICAgIC8vIE5PVEU6IFRoaXMgbWV0aG9kIG1heSBiZSBjYWxsZWQgYXMgcGFydCBvZiBzdGF0aWMgb3IgcHJvcGVydHkgc2hpbW1pbmcuXG4gICAgLy8gV2hlbiB0aGVyZSBpcyBhIHRhcmdldGVkIGJ1aWxkIGl0IHdpbGwgbm90IGJlIGNhbGxlZCBmb3Igc3RhdGljIHNoaW1taW5nLFxuICAgIC8vIGJ1dCB3aGVuIHRoZSBwcm9wZXJ0eSBzaGltIGlzIHVzZWQgaXQgaXMgY2FsbGVkIGFuZCBzaG91bGQgb3B0IG91dCBvZlxuICAgIC8vIHN0YXRpYyBzaGltbWluZyB3b3JrIHdoZW4gYSBwcm9wZXIgYnVpbGQgZXhpc3RzLlxuICAgIGlmIChjc3NUZXh0ID09PSAnJykge1xuICAgICAgaWYgKG5hdGl2ZVNoYWRvdyB8fCBjc3NCdWlsZCA9PT0gJ3NoYWR5Jykge1xuICAgICAgICBjc3NUZXh0ID0gU3R5bGVVdGlsLnRvQ3NzVGV4dChzdHlsZVJ1bGVzLCBjYWxsYmFjayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQge2lzLCB0eXBlRXh0ZW5zaW9ufSA9IFN0eWxlVXRpbC5nZXRJc0V4dGVuZHMoZWxlbWVudCk7XG4gICAgICAgIGNzc1RleHQgPSB0aGlzLmNzcyhzdHlsZVJ1bGVzLCBpcywgdHlwZUV4dGVuc2lvbiwgY2FsbGJhY2spICsgJ1xcblxcbic7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjc3NUZXh0LnRyaW0oKTtcbiAgfVxuXG4gIC8vIEdpdmVuIGEgc3RyaW5nIG9mIGNzc1RleHQgYW5kIGEgc2NvcGluZyBzdHJpbmcgKHNjb3BlKSwgcmV0dXJuc1xuICAvLyBhIHN0cmluZyBvZiBzY29wZWQgY3NzIHdoZXJlIGVhY2ggc2VsZWN0b3IgaXMgdHJhbnNmb3JtZWQgdG8gaW5jbHVkZVxuICAvLyBhIGNsYXNzIGNyZWF0ZWQgZnJvbSB0aGUgc2NvcGUuIFNoYWRvd0RPTSBzZWxlY3RvcnMgYXJlIGFsc28gdHJhbnNmb3JtZWRcbiAgLy8gKGUuZy4gOmhvc3QpIHRvIHVzZSB0aGUgc2NvcGluZyBzZWxlY3Rvci5cbiAgY3NzKHJ1bGVzLCBzY29wZSwgZXh0LCBjYWxsYmFjaykge1xuICAgIGxldCBob3N0U2NvcGUgPSB0aGlzLl9jYWxjSG9zdFNjb3BlKHNjb3BlLCBleHQpO1xuICAgIHNjb3BlID0gdGhpcy5fY2FsY0VsZW1lbnRTY29wZShzY29wZSk7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIHJldHVybiBTdHlsZVV0aWwudG9Dc3NUZXh0KHJ1bGVzLCBmdW5jdGlvbigvKiogU3R5bGVOb2RlICovcnVsZSkge1xuICAgICAgaWYgKCFydWxlLmlzU2NvcGVkKSB7XG4gICAgICAgIHNlbGYucnVsZShydWxlLCBzY29wZSwgaG9zdFNjb3BlKTtcbiAgICAgICAgcnVsZS5pc1Njb3BlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2socnVsZSwgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBfY2FsY0VsZW1lbnRTY29wZShzY29wZSkge1xuICAgIGlmIChzY29wZSkge1xuICAgICAgcmV0dXJuIENTU19DTEFTU19QUkVGSVggKyBzY29wZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cbiAgfVxuXG4gIF9jYWxjSG9zdFNjb3BlKHNjb3BlLCBleHQpIHtcbiAgICByZXR1cm4gZXh0ID8gYFtpcz0ke3Njb3BlfV1gIDogc2NvcGU7XG4gIH1cblxuICBydWxlKHJ1bGUsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1SdWxlKHJ1bGUsIHRoaXMuX3RyYW5zZm9ybUNvbXBsZXhTZWxlY3RvcixcbiAgICAgIHNjb3BlLCBob3N0U2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHRyYW5zZm9ybXMgYSBjc3MgcnVsZSB0byBhIHNjb3BlZCBydWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm1lclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHNjb3BlXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gaG9zdFNjb3BlXG4gICAqL1xuICBfdHJhbnNmb3JtUnVsZShydWxlLCB0cmFuc2Zvcm1lciwgc2NvcGUsIGhvc3RTY29wZSkge1xuICAgIC8vIE5PVEU6IHNhdmUgdHJhbnNmb3JtZWRTZWxlY3RvciBmb3Igc3Vic2VxdWVudCBtYXRjaGluZyBvZiBlbGVtZW50c1xuICAgIC8vIGFnYWluc3Qgc2VsZWN0b3JzIChlLmcuIHdoZW4gY2FsY3VsYXRpbmcgc3R5bGUgcHJvcGVydGllcylcbiAgICBydWxlWydzZWxlY3RvciddID0gcnVsZS50cmFuc2Zvcm1lZFNlbGVjdG9yID1cbiAgICAgIHRoaXMuX3RyYW5zZm9ybVJ1bGVDc3MocnVsZSwgdHJhbnNmb3JtZXIsIHNjb3BlLCBob3N0U2NvcGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybWVyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gc2NvcGVcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBob3N0U2NvcGVcbiAgICovXG4gIF90cmFuc2Zvcm1SdWxlQ3NzKHJ1bGUsIHRyYW5zZm9ybWVyLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgbGV0IHAkID0gU3R5bGVVdGlsLnNwbGl0U2VsZWN0b3JMaXN0KHJ1bGVbJ3NlbGVjdG9yJ10pO1xuICAgIC8vIHdlIHdhbnQgdG8gc2tpcCB0cmFuc2Zvcm1hdGlvbiBvZiBydWxlcyB0aGF0IGFwcGVhciBpbiBrZXlmcmFtZXMsXG4gICAgLy8gYmVjYXVzZSB0aGV5IGFyZSBrZXlmcmFtZSBzZWxlY3RvcnMsIG5vdCBlbGVtZW50IHNlbGVjdG9ycy5cbiAgICBpZiAoIVN0eWxlVXRpbC5pc0tleWZyYW1lc1NlbGVjdG9yKHJ1bGUpKSB7XG4gICAgICBmb3IgKGxldCBpPTAsIGw9cCQubGVuZ3RoLCBwOyAoaTxsKSAmJiAocD1wJFtpXSk7IGkrKykge1xuICAgICAgICBwJFtpXSA9IHRyYW5zZm9ybWVyLmNhbGwodGhpcywgcCwgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwJC5maWx0ZXIoKHBhcnQpID0+IEJvb2xlYW4ocGFydCkpLmpvaW4oQ09NUExFWF9TRUxFQ1RPUl9TRVApO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBfdHdpZGRsZU50aFBsdXMoc2VsZWN0b3IpIHtcbiAgICByZXR1cm4gc2VsZWN0b3IucmVwbGFjZShOVEgsIChtLCB0eXBlLCBpbnNpZGUpID0+IHtcbiAgICAgIGlmIChpbnNpZGUuaW5kZXhPZignKycpID4gLTEpIHtcbiAgICAgICAgaW5zaWRlID0gaW5zaWRlLnJlcGxhY2UoL1xcKy9nLCAnX19fJyk7XG4gICAgICB9IGVsc2UgaWYgKGluc2lkZS5pbmRleE9mKCdfX18nKSA+IC0xKSB7XG4gICAgICAgIGluc2lkZSA9IGluc2lkZS5yZXBsYWNlKC9fX18vZywgJysnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgOiR7dHlwZX0oJHtpbnNpZGV9KWA7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUHJlc2VydmUgYDptYXRjaGVzKClgIHNlbGVjdG9ycyBieSByZXBsYWNpbmcgdGhlbSB3aXRoIE1BVENIRVNfUkVQTEFDTUVOVFxuICAgKiBhbmQgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGA6bWF0Y2hlcygpYCBzZWxlY3RvcnMuXG4gICAqIFVzZSBgX3JlcGxhY2VzTWF0Y2hlc1BzZXVkb2AgdG8gcmVwbGFjZSB0aGUgYDptYXRjaGVzKClgIHBhcnRzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxuICAgKiBAcmV0dXJuIHt7c2VsZWN0b3I6IHN0cmluZywgbWF0Y2hlczogIUFycmF5PHN0cmluZz59fVxuICAgKi9cbiAgX3ByZXNlcnZlTWF0Y2hlc1BzZXVkbyhzZWxlY3Rvcikge1xuICAgIC8qKiBAdHlwZSB7IUFycmF5PHN0cmluZz59ICovXG4gICAgY29uc3QgbWF0Y2hlcyA9IFtdO1xuICAgIGxldCBtYXRjaDtcbiAgICB3aGlsZSAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goTUFUQ0hFUykpKSB7XG4gICAgICBjb25zdCBzdGFydCA9IG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgZW5kID0gU3R5bGVVdGlsLmZpbmRNYXRjaGluZ1BhcmVuKHNlbGVjdG9yLCBzdGFydCk7XG4gICAgICBpZiAoZW5kID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7bWF0Y2guaW5wdXR9IHNlbGVjdG9yIG1pc3NpbmcgJyknYClcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnQgPSBzZWxlY3Rvci5zbGljZShzdGFydCwgZW5kICsgMSk7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UocGFydCwgTUFUQ0hFU19SRVBMQUNFTUVOVCk7XG4gICAgICBtYXRjaGVzLnB1c2gocGFydCk7XG4gICAgfVxuICAgIHJldHVybiB7c2VsZWN0b3IsIG1hdGNoZXN9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2UgTUFUQ0hFU19SRVBMQUNNRU5UIGNoYXJhY3RlciB3aXRoIHRoZSBnaXZlbiBzZXQgb2YgYDptYXRjaGVzKClgXG4gICAqIHNlbGVjdG9ycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IG1hdGNoZXNcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgX3JlcGxhY2VNYXRjaGVzUHNldWRvKHNlbGVjdG9yLCBtYXRjaGVzKSB7XG4gICAgY29uc3QgcGFydHMgPSBzZWxlY3Rvci5zcGxpdChNQVRDSEVTX1JFUExBQ0VNRU5UKTtcbiAgICByZXR1cm4gbWF0Y2hlcy5yZWR1Y2UoKGFjYywgY3VyLCBpZHgpID0+IGFjYyArIGN1ciArIHBhcnRzW2lkeCArIDFdLCBwYXJ0c1swXSk7XG4gIH1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuICogQHBhcmFtIHtzdHJpbmc9fSBob3N0U2NvcGVcbiAqL1xuICBfdHJhbnNmb3JtQ29tcGxleFNlbGVjdG9yKHNlbGVjdG9yLCBzY29wZSwgaG9zdFNjb3BlKSB7XG4gICAgbGV0IHN0b3AgPSBmYWxzZTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnRyaW0oKTtcbiAgICAvLyBSZW1vdmUgc3BhY2VzIGluc2lkZSBvZiBzZWxlY3RvcnMgbGlrZSBgOm50aC1vZi10eXBlYCBiZWNhdXNlIGl0IGNvbmZ1c2VzIFNJTVBMRV9TRUxFQ1RPUl9TRVBcbiAgICBsZXQgaXNOdGggPSBOVEgudGVzdChzZWxlY3Rvcik7XG4gICAgaWYgKGlzTnRoKSB7XG4gICAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoTlRILCAobSwgdHlwZSwgaW5uZXIpID0+IGA6JHt0eXBlfSgke2lubmVyLnJlcGxhY2UoL1xccy9nLCAnJyl9KWApXG4gICAgICBzZWxlY3RvciA9IHRoaXMuX3R3aWRkbGVOdGhQbHVzKHNlbGVjdG9yKTtcbiAgICB9XG4gICAgLy8gUHJlc2VydmUgc2VsZWN0b3JzIGxpa2UgYDotd2Via2l0LWFueWAgc28gdGhhdCBTSU1QTEVfU0VMRUNUT1JfU0VQIGRvZXNcbiAgICAvLyBub3QgZ2V0IGNvbmZ1c2VkIGJ5IHNwYWNlcyBpbnNpZGUgdGhlIHBzZXVkbyBzZWxlY3RvclxuICAgIGNvbnN0IGlzTWF0Y2hlcyA9IE1BVENIRVMudGVzdChzZWxlY3Rvcik7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICBsZXQgbWF0Y2hlcztcbiAgICBpZiAoaXNNYXRjaGVzKSB7XG4gICAgICAoe3NlbGVjdG9yLCBtYXRjaGVzfSA9IHRoaXMuX3ByZXNlcnZlTWF0Y2hlc1BzZXVkbyhzZWxlY3RvcikpO1xuICAgIH1cbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0xPVFRFRF9TVEFSVCwgYCR7SE9TVH0gJDFgKTtcbiAgICBzZWxlY3RvciA9IHNlbGVjdG9yLnJlcGxhY2UoU0lNUExFX1NFTEVDVE9SX1NFUCwgKG0sIGMsIHMpID0+IHtcbiAgICAgIGlmICghc3RvcCkge1xuICAgICAgICBsZXQgaW5mbyA9IHRoaXMuX3RyYW5zZm9ybUNvbXBvdW5kU2VsZWN0b3IocywgYywgc2NvcGUsIGhvc3RTY29wZSk7XG4gICAgICAgIHN0b3AgPSBzdG9wIHx8IGluZm8uc3RvcDtcbiAgICAgICAgYyA9IGluZm8uY29tYmluYXRvcjtcbiAgICAgICAgcyA9IGluZm8udmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYyArIHM7XG4gICAgfSk7XG4gICAgLy8gcmVwbGFjZSBgOm1hdGNoZXMoKWAgc2VsZWN0b3JzXG4gICAgaWYgKGlzTWF0Y2hlcykge1xuICAgICAgc2VsZWN0b3IgPSB0aGlzLl9yZXBsYWNlTWF0Y2hlc1BzZXVkbyhzZWxlY3RvciwgbWF0Y2hlcyk7XG4gICAgfVxuICAgIGlmIChpc050aCkge1xuICAgICAgc2VsZWN0b3IgPSB0aGlzLl90d2lkZGxlTnRoUGx1cyhzZWxlY3Rvcik7XG4gICAgfVxuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShESVJfUEFSRU4sIChtLCBiZWZvcmUsIGRpciwgYWZ0ZXIpID0+XG4gICAgICBgW2Rpcj1cIiR7ZGlyfVwiXSAke2JlZm9yZX0ke2FmdGVyfSwgJHtiZWZvcmV9W2Rpcj1cIiR7ZGlyfVwiXSR7YWZ0ZXJ9YCk7XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xuICB9XG5cbiAgX3RyYW5zZm9ybUNvbXBvdW5kU2VsZWN0b3Ioc2VsZWN0b3IsIGNvbWJpbmF0b3IsIHNjb3BlLCBob3N0U2NvcGUpIHtcbiAgICAvLyByZXBsYWNlIDpob3N0IHdpdGggaG9zdCBzY29waW5nIGNsYXNzXG4gICAgbGV0IHNsb3R0ZWRJbmRleCA9IHNlbGVjdG9yLmluZGV4T2YoU0xPVFRFRCk7XG4gICAgaWYgKHNlbGVjdG9yLmluZGV4T2YoSE9TVCkgPj0gMCkge1xuICAgICAgc2VsZWN0b3IgPSB0aGlzLl90cmFuc2Zvcm1Ib3N0U2VsZWN0b3Ioc2VsZWN0b3IsIGhvc3RTY29wZSk7XG4gICAgLy8gcmVwbGFjZSBvdGhlciBzZWxlY3RvcnMgd2l0aCBzY29waW5nIGNsYXNzXG4gICAgfSBlbHNlIGlmIChzbG90dGVkSW5kZXggIT09IDApIHtcbiAgICAgIHNlbGVjdG9yID0gc2NvcGUgPyB0aGlzLl90cmFuc2Zvcm1TaW1wbGVTZWxlY3RvcihzZWxlY3Rvciwgc2NvcGUpIDpcbiAgICAgICAgc2VsZWN0b3I7XG4gICAgfVxuICAgIC8vIG1hcmsgOjpzbG90dGVkKCkgc2NvcGUganVtcCB0byByZXBsYWNlIHdpdGggZGVzY2VuZGFudCBzZWxlY3RvciArIGFyZ1xuICAgIC8vIGFsc28gaWdub3JlIGxlZnQtc2lkZSBjb21iaW5hdG9yXG4gICAgbGV0IHNsb3R0ZWQgPSBmYWxzZTtcbiAgICBpZiAoc2xvdHRlZEluZGV4ID49IDApIHtcbiAgICAgIGNvbWJpbmF0b3IgPSAnJztcbiAgICAgIHNsb3R0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBwcm9jZXNzIHNjb3BlIGp1bXBpbmcgc2VsZWN0b3JzIHVwIHRvIHRoZSBzY29wZSBqdW1wIGFuZCB0aGVuIHN0b3BcbiAgICBsZXQgc3RvcDtcbiAgICBpZiAoc2xvdHRlZCkge1xuICAgICAgc3RvcCA9IHRydWU7XG4gICAgICBpZiAoc2xvdHRlZCkge1xuICAgICAgICAvLyAuem9uayA6OnNsb3R0ZWQoLmZvbykgLT4gLnpvbmsuc2NvcGUgPiAuZm9vXG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZShTTE9UVEVEX1BBUkVOLCAobSwgcGFyZW4pID0+IGAgPiAke3BhcmVufWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge3ZhbHVlOiBzZWxlY3RvciwgY29tYmluYXRvciwgc3RvcH07XG4gIH1cblxuICBfdHJhbnNmb3JtU2ltcGxlU2VsZWN0b3Ioc2VsZWN0b3IsIHNjb3BlKSB7XG4gICAgY29uc3QgYXR0cmlidXRlcyA9IHNlbGVjdG9yLnNwbGl0KC8oXFxbLis/XFxdKS8pO1xuXG4gICAgY29uc3Qgb3V0cHV0ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byB0cmFuc2Zvcm0gYW55IGF0dHJpYnV0ZSBzZWxlY3RvciBjb250ZW50XG4gICAgICBpZiAoKGkgJSAyKSA9PT0gMSkge1xuICAgICAgICBvdXRwdXQucHVzaChhdHRyaWJ1dGVzW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHBhcnQgPSBhdHRyaWJ1dGVzW2ldO1xuXG4gICAgICAgIGlmICghKHBhcnQgPT09ICcnICYmIGkgPT09IGF0dHJpYnV0ZXMubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgICBsZXQgcCQgPSBwYXJ0LnNwbGl0KFBTRVVET19QUkVGSVgpO1xuICAgICAgICAgIHAkWzBdICs9IHNjb3BlO1xuICAgICAgICAgIG91dHB1dC5wdXNoKHAkLmpvaW4oUFNFVURPX1BSRUZJWCkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dHB1dC5qb2luKCcnKTtcbiAgfVxuXG4gIC8vIDpob3N0KC4uLikgLT4gc2NvcGVOYW1lLi4uXG4gIF90cmFuc2Zvcm1Ib3N0U2VsZWN0b3Ioc2VsZWN0b3IsIGhvc3RTY29wZSkge1xuICAgIGxldCBtID0gc2VsZWN0b3IubWF0Y2goSE9TVF9QQVJFTik7XG4gICAgbGV0IHBhcmVuID0gbSAmJiBtWzJdLnRyaW0oKSB8fCAnJztcbiAgICBpZiAocGFyZW4pIHtcbiAgICAgIGlmICghcGFyZW5bMF0ubWF0Y2goU0lNUExFX1NFTEVDVE9SX1BSRUZJWCkpIHtcbiAgICAgICAgLy8gcGFyZW4gc3RhcnRzIHdpdGggYSB0eXBlIHNlbGVjdG9yXG4gICAgICAgIGxldCB0eXBlU2VsZWN0b3IgPSBwYXJlbi5zcGxpdChTSU1QTEVfU0VMRUNUT1JfUFJFRklYKVswXTtcbiAgICAgICAgLy8gaWYgdGhlIHR5cGUgc2VsZWN0b3IgaXMgb3VyIGhvc3RTY29wZSB0aGVuIGF2b2lkIHByZS1wZW5kaW5nIGl0XG4gICAgICAgIGlmICh0eXBlU2VsZWN0b3IgPT09IGhvc3RTY29wZSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbjtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCB0aGlzIHNlbGVjdG9yIHNob3VsZCBub3QgbWF0Y2ggaW4gdGhpcyBzY29wZSBzb1xuICAgICAgICAvLyBvdXRwdXQgYSBib2d1cyBzZWxlY3Rvci5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gU0VMRUNUT1JfTk9fTUFUQ0g7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSB0byBkbyBhIHJlcGxhY2UgaGVyZSB0byBjYXRjaCBzZWxlY3RvcnMgbGlrZTpcbiAgICAgICAgLy8gYDpob3N0KC5mb28pOjpiZWZvcmVgXG4gICAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKEhPU1RfUEFSRU4sIGZ1bmN0aW9uKG0sIGhvc3QsIHBhcmVuKSB7XG4gICAgICAgICAgcmV0dXJuIGhvc3RTY29wZSArIHBhcmVuO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAvLyBpZiBubyBwYXJlbiwgZG8gYSBzdHJhaWdodCA6aG9zdCByZXBsYWNlbWVudC5cbiAgICAvLyBUT0RPKHNvcnZlbGwpOiB0aGlzIHNob3VsZCBub3Qgc3RyaWN0bHkgYmUgbmVjZXNzYXJ5IGJ1dFxuICAgIC8vIGl0J3MgbmVlZGVkIHRvIG1haW50YWluIHN1cHBvcnQgZm9yIGA6aG9zdFtmb29dYCB0eXBlIHNlbGVjdG9yc1xuICAgIC8vIHdoaWNoIGhhdmUgYmVlbiBpbXByb3Blcmx5IHVzZWQgdW5kZXIgU2hhZHkgRE9NLiBUaGlzIHNob3VsZCBiZVxuICAgIC8vIGRlcHJlY2F0ZWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKEhPU1QsIGhvc3RTY29wZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlXG4gICAqL1xuICBkb2N1bWVudFJ1bGUocnVsZSkge1xuICAgIC8vIHJlc2V0IHNlbGVjdG9yIGluIGNhc2UgdGhpcyBpcyByZWRvbmUuXG4gICAgcnVsZVsnc2VsZWN0b3InXSA9IHJ1bGVbJ3BhcnNlZFNlbGVjdG9yJ107XG4gICAgdGhpcy5ub3JtYWxpemVSb290U2VsZWN0b3IocnVsZSk7XG4gICAgdGhpcy5fdHJhbnNmb3JtUnVsZShydWxlLCB0aGlzLl90cmFuc2Zvcm1Eb2N1bWVudFNlbGVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICAgKi9cbiAgbm9ybWFsaXplUm9vdFNlbGVjdG9yKHJ1bGUpIHtcbiAgICBpZiAocnVsZVsnc2VsZWN0b3InXSA9PT0gUk9PVCkge1xuICAgICAgcnVsZVsnc2VsZWN0b3InXSA9ICdodG1sJztcbiAgICB9XG4gIH1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAqL1xuICBfdHJhbnNmb3JtRG9jdW1lbnRTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIGlmIChzZWxlY3Rvci5tYXRjaChIT1NUKSkge1xuICAgICAgLy8gcmVtb3ZlICc6aG9zdCcgdHlwZSBzZWxlY3RvcnMgaW4gZG9jdW1lbnQgcnVsZXNcbiAgICAgIHJldHVybiAnJztcbiAgICB9IGVsc2UgaWYgKHNlbGVjdG9yLm1hdGNoKFNMT1RURUQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29tcGxleFNlbGVjdG9yKHNlbGVjdG9yLCBTQ09QRV9ET0NfU0VMRUNUT1IpXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFuc2Zvcm1TaW1wbGVTZWxlY3RvcihzZWxlY3Rvci50cmltKCksIFNDT1BFX0RPQ19TRUxFQ1RPUik7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IE5USCA9IC86KG50aFstXFx3XSspXFwoKFteKV0rKVxcKS87XG5jb25zdCBTQ09QRV9ET0NfU0VMRUNUT1IgPSBgOm5vdCguJHtTQ09QRV9OQU1FfSlgO1xuY29uc3QgQ09NUExFWF9TRUxFQ1RPUl9TRVAgPSAnLCc7XG5jb25zdCBTSU1QTEVfU0VMRUNUT1JfU0VQID0gLyhefFtcXHM+K35dKykoKD86XFxbLis/XFxdfFteXFxzPit+PVtdKSspL2c7XG5jb25zdCBTSU1QTEVfU0VMRUNUT1JfUFJFRklYID0gL1tbLjojKl0vO1xuY29uc3QgSE9TVCA9ICc6aG9zdCc7XG5jb25zdCBST09UID0gJzpyb290JztcbmNvbnN0IFNMT1RURUQgPSAnOjpzbG90dGVkJztcbmNvbnN0IFNMT1RURURfU1RBUlQgPSBuZXcgUmVnRXhwKGBeKCR7U0xPVFRFRH0pYCk7XG4vLyBOT1RFOiB0aGlzIHN1cHBvcnRzIDEgbmVzdGVkICgpIHBhaXIgZm9yIHRoaW5ncyBsaWtlXG4vLyA6aG9zdCg6bm90KFtzZWxlY3RlZF0pLCBtb3JlIGdlbmVyYWwgc3VwcG9ydCByZXF1aXJlc1xuLy8gcGFyc2luZyB3aGljaCBzZWVtcyBsaWtlIG92ZXJraWxsXG5jb25zdCBIT1NUX1BBUkVOID0gLyg6aG9zdCkoPzpcXCgoKD86XFwoW14pKF0qXFwpfFteKShdKikrPylcXCkpLztcbi8vIHNpbWlsYXIgdG8gSE9TVF9QQVJFTlxuY29uc3QgU0xPVFRFRF9QQVJFTiA9IC8oPzo6OnNsb3R0ZWQpKD86XFwoKCg/OlxcKFteKShdKlxcKXxbXikoXSopKz8pXFwpKS87XG5jb25zdCBESVJfUEFSRU4gPSAvKC4qKTpkaXJcXCgoPzoobHRyfHJ0bCkpXFwpKC4qKS87XG5jb25zdCBDU1NfQ0xBU1NfUFJFRklYID0gJy4nO1xuY29uc3QgUFNFVURPX1BSRUZJWCA9ICc6JztcbmNvbnN0IENMQVNTID0gJ2NsYXNzJztcbmNvbnN0IFNFTEVDVE9SX05PX01BVENIID0gJ3Nob3VsZF9ub3RfbWF0Y2gnO1xuY29uc3QgTUFUQ0hFUyA9IC86KD86bWF0Y2hlc3xhbnl8LSg/OndlYmtpdHxtb3opLWFueSkvO1xuY29uc3QgTUFUQ0hFU19SRVBMQUNFTUVOVCA9ICdcXHV7ZTAwMH0nO1xuXG5leHBvcnQgZGVmYXVsdCBuZXcgU3R5bGVUcmFuc2Zvcm1lcigpXG4iLCIvKipcbkBsaWNlbnNlXG5Db3B5cmlnaHQgKGMpIDIwMTcgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbnN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbmltcG9ydCB7U3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgaW5mb0tleSA9ICdfX3N0eWxlSW5mbyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlSW5mbyB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICogQHJldHVybiB7U3R5bGVJbmZvfVxuICAgKi9cbiAgc3RhdGljIGdldChub2RlKSB7XG4gICAgaWYgKG5vZGUpIHtcbiAgICAgIHJldHVybiBub2RlW2luZm9LZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtTdHlsZUluZm99IHN0eWxlSW5mb1xuICAgKiBAcmV0dXJuIHtTdHlsZUluZm99XG4gICAqL1xuICBzdGF0aWMgc2V0KG5vZGUsIHN0eWxlSW5mbykge1xuICAgIG5vZGVbaW5mb0tleV0gPSBzdHlsZUluZm87XG4gICAgcmV0dXJuIHN0eWxlSW5mbztcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IGFzdFxuICAgKiBAcGFyYW0ge05vZGU9fSBwbGFjZWhvbGRlclxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz49fSBvd25TdHlsZVByb3BlcnR5TmFtZXNcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZz19IHR5cGVFeHRlbnNpb25cbiAgICogQHBhcmFtIHtzdHJpbmc9fSBjc3NCdWlsZFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXN0LCBwbGFjZWhvbGRlciwgb3duU3R5bGVQcm9wZXJ0eU5hbWVzLCBlbGVtZW50TmFtZSwgdHlwZUV4dGVuc2lvbiwgY3NzQnVpbGQpIHtcbiAgICAvKiogQHR5cGUge1N0eWxlTm9kZX0gKi9cbiAgICB0aGlzLnN0eWxlUnVsZXMgPSBhc3QgfHwgbnVsbDtcbiAgICAvKiogQHR5cGUge05vZGV9ICovXG4gICAgdGhpcy5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyIHx8IG51bGw7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8c3RyaW5nPn0gKi9cbiAgICB0aGlzLm93blN0eWxlUHJvcGVydHlOYW1lcyA9IG93blN0eWxlUHJvcGVydHlOYW1lcyB8fCBbXTtcbiAgICAvKiogQHR5cGUge09iamVjdH0gKi9cbiAgICB0aGlzLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUge3N0cmluZ30gKi9cbiAgICB0aGlzLmVsZW1lbnROYW1lID0gZWxlbWVudE5hbWUgfHwgJyc7XG4gICAgLyoqIEB0eXBlIHtzdHJpbmd9ICovXG4gICAgdGhpcy5jc3NCdWlsZCA9IGNzc0J1aWxkIHx8ICcnO1xuICAgIC8qKiBAdHlwZSB7c3RyaW5nfSAqL1xuICAgIHRoaXMudHlwZUV4dGVuc2lvbiA9IHR5cGVFeHRlbnNpb24gfHwgJyc7XG4gICAgLyoqIEB0eXBlIHtPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuICAgIHRoaXMuc3R5bGVQcm9wZXJ0aWVzID0gbnVsbDtcbiAgICAvKiogQHR5cGUgez9zdHJpbmd9ICovXG4gICAgdGhpcy5zY29wZVNlbGVjdG9yID0gbnVsbDtcbiAgICAvKiogQHR5cGUge0hUTUxTdHlsZUVsZW1lbnR9ICovXG4gICAgdGhpcy5jdXN0b21TdHlsZSA9IG51bGw7XG4gIH1cbiAgX2dldFN0eWxlUnVsZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3R5bGVSdWxlcztcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tc2VsZi1hc3NpZ24gKi9cblN0eWxlSW5mby5wcm90b3R5cGVbJ19nZXRTdHlsZVJ1bGVzJ10gPSBTdHlsZUluZm8ucHJvdG90eXBlLl9nZXRTdHlsZVJ1bGVzO1xuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pbXBvcnQge3JlbW92ZUN1c3RvbVByb3BBc3NpZ25tZW50LCBTdHlsZU5vZGV9IGZyb20gJy4vY3NzLXBhcnNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuaW1wb3J0IHtuYXRpdmVTaGFkb3d9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuaW1wb3J0IFN0eWxlVHJhbnNmb3JtZXIgZnJvbSAnLi9zdHlsZS10cmFuc2Zvcm1lci5qcyc7XG5pbXBvcnQgKiBhcyBTdHlsZVV0aWwgZnJvbSAnLi9zdHlsZS11dGlsLmpzJztcbmltcG9ydCAqIGFzIFJYIGZyb20gJy4vY29tbW9uLXJlZ2V4LmpzJztcbmltcG9ydCBTdHlsZUluZm8gZnJvbSAnLi9zdHlsZS1pbmZvLmpzJztcblxuLy8gVE9ETzogZGVkdXBlIHdpdGggc2hhZHlcbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICogQHRoaXMge0VsZW1lbnR9XG4gKi9cbmNvbnN0IG1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG4gIGNvbnN0IG1ldGhvZCA9IHRoaXMubWF0Y2hlcyB8fCB0aGlzLm1hdGNoZXNTZWxlY3RvciB8fFxuICAgIHRoaXMubW96TWF0Y2hlc1NlbGVjdG9yIHx8IHRoaXMubXNNYXRjaGVzU2VsZWN0b3IgfHxcbiAgICB0aGlzLm9NYXRjaGVzU2VsZWN0b3IgfHwgdGhpcy53ZWJraXRNYXRjaGVzU2VsZWN0b3I7XG4gIHJldHVybiBtZXRob2QgJiYgbWV0aG9kLmNhbGwodGhpcywgc2VsZWN0b3IpO1xufTtcblxuY29uc3QgSVNfSUUgPSBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKCdUcmlkZW50Jyk7XG5cbmNvbnN0IFhTQ09QRV9OQU1FID0gJ3gtc2NvcGUnO1xuXG5jbGFzcyBTdHlsZVByb3BlcnRpZXMge1xuICBnZXQgWFNDT1BFX05BTUUoKSB7XG4gICAgcmV0dXJuIFhTQ09QRV9OQU1FO1xuICB9XG4vKipcbiAqIGRlY29yYXRlcyBzdHlsZXMgd2l0aCBydWxlIGluZm8gYW5kIHJldHVybnMgYW4gYXJyYXkgb2YgdXNlZCBzdHlsZSBwcm9wZXJ0eSBuYW1lc1xuICpcbiAqIEBwYXJhbSB7U3R5bGVOb2RlfSBydWxlc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuICBkZWNvcmF0ZVN0eWxlcyhydWxlcykge1xuICAgIGxldCBzZWxmID0gdGhpcywgcHJvcHMgPSB7fSwga2V5ZnJhbWVzID0gW10sIHJ1bGVJbmRleCA9IDA7XG4gICAgU3R5bGVVdGlsLmZvckVhY2hSdWxlKHJ1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICBzZWxmLmRlY29yYXRlUnVsZShydWxlKTtcbiAgICAgIC8vIG1hcmsgaW4tb3JkZXIgcG9zaXRpb24gb2YgYXN0IHJ1bGUgaW4gc3R5bGVzIGJsb2NrLCB1c2VkIGZvciBjYWNoZSBrZXlcbiAgICAgIHJ1bGUuaW5kZXggPSBydWxlSW5kZXgrKztcbiAgICAgIHNlbGYuY29sbGVjdFByb3BlcnRpZXNJbkNzc1RleHQocnVsZS5wcm9wZXJ0eUluZm8uY3NzVGV4dCwgcHJvcHMpO1xuICAgIH0sIGZ1bmN0aW9uIG9uS2V5ZnJhbWVzUnVsZShydWxlKSB7XG4gICAgICBrZXlmcmFtZXMucHVzaChydWxlKTtcbiAgICB9KTtcbiAgICAvLyBDYWNoZSBhbGwgZm91bmQga2V5ZnJhbWVzIHJ1bGVzIGZvciBsYXRlciByZWZlcmVuY2U6XG4gICAgcnVsZXMuX2tleWZyYW1lcyA9IGtleWZyYW1lcztcbiAgICAvLyByZXR1cm4gdGhpcyBsaXN0IG9mIHByb3BlcnR5IG5hbWVzICpjb25zdW1lcyogaW4gdGhlc2Ugc3R5bGVzLlxuICAgIGxldCBuYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgaW4gcHJvcHMpIHtcbiAgICAgIG5hbWVzLnB1c2goaSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcztcbiAgfVxuXG4gIC8vIGRlY29yYXRlIGEgc2luZ2xlIHJ1bGUgd2l0aCBwcm9wZXJ0eSBpbmZvXG4gIGRlY29yYXRlUnVsZShydWxlKSB7XG4gICAgaWYgKHJ1bGUucHJvcGVydHlJbmZvKSB7XG4gICAgICByZXR1cm4gcnVsZS5wcm9wZXJ0eUluZm87XG4gICAgfVxuICAgIGxldCBpbmZvID0ge30sIHByb3BlcnRpZXMgPSB7fTtcbiAgICBsZXQgaGFzUHJvcGVydGllcyA9IHRoaXMuY29sbGVjdFByb3BlcnRpZXMocnVsZSwgcHJvcGVydGllcyk7XG4gICAgaWYgKGhhc1Byb3BlcnRpZXMpIHtcbiAgICAgIGluZm8ucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gICAgICAvLyBUT0RPKHNvcnZlbGwpOiB3b3JrYXJvdW5kIHBhcnNlciBzZWVpbmcgbWl4aW5zIGFzIGFkZGl0aW9uYWwgcnVsZXNcbiAgICAgIHJ1bGVbJ3J1bGVzJ10gPSBudWxsO1xuICAgIH1cbiAgICBpbmZvLmNzc1RleHQgPSB0aGlzLmNvbGxlY3RDc3NUZXh0KHJ1bGUpO1xuICAgIHJ1bGUucHJvcGVydHlJbmZvID0gaW5mbztcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuXG4gIC8vIGNvbGxlY3RzIHRoZSBjdXN0b20gcHJvcGVydGllcyBmcm9tIGEgcnVsZSdzIGNzc1RleHRcbiAgY29sbGVjdFByb3BlcnRpZXMocnVsZSwgcHJvcGVydGllcykge1xuICAgIGxldCBpbmZvID0gcnVsZS5wcm9wZXJ0eUluZm87XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIGlmIChpbmZvLnByb3BlcnRpZXMpIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihwcm9wZXJ0aWVzLCBpbmZvLnByb3BlcnRpZXMpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IG0sIHJ4ID0gUlguVkFSX0FTU0lHTjtcbiAgICAgIGxldCBjc3NUZXh0ID0gcnVsZVsncGFyc2VkQ3NzVGV4dCddO1xuICAgICAgbGV0IHZhbHVlO1xuICAgICAgbGV0IGFueTtcbiAgICAgIHdoaWxlICgobSA9IHJ4LmV4ZWMoY3NzVGV4dCkpKSB7XG4gICAgICAgIC8vIG5vdGU6IGdyb3VwIDIgaXMgdmFyLCAzIGlzIG1peGluXG4gICAgICAgIHZhbHVlID0gKG1bMl0gfHwgbVszXSkudHJpbSgpO1xuICAgICAgICAvLyB2YWx1ZSBvZiAnaW5oZXJpdCcgb3IgJ3Vuc2V0JyBpcyBlcXVpdmFsZW50IHRvIG5vdCBzZXR0aW5nIHRoZSBwcm9wZXJ0eSBoZXJlXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gJ2luaGVyaXQnIHx8IHZhbHVlICE9PSAndW5zZXQnKSB7XG4gICAgICAgICAgcHJvcGVydGllc1ttWzFdLnRyaW0oKV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBhbnkgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFueTtcbiAgICB9XG5cbiAgfVxuXG4gIC8vIHJldHVybnMgY3NzVGV4dCBvZiBwcm9wZXJ0aWVzIHRoYXQgY29uc3VtZSB2YXJpYWJsZXMvbWl4aW5zXG4gIGNvbGxlY3RDc3NUZXh0KHJ1bGUpIHtcbiAgICByZXR1cm4gdGhpcy5jb2xsZWN0Q29uc3VtaW5nQ3NzVGV4dChydWxlWydwYXJzZWRDc3NUZXh0J10pO1xuICB9XG5cbiAgLy8gTk9URTogd2Ugc3VwcG9ydCBjb25zdW1wdGlvbiBpbnNpZGUgbWl4aW4gYXNzaWdubWVudFxuICAvLyBidXQgbm90IHByb2R1Y3Rpb24sIHNvIHN0cmlwIG91dCB7Li4ufVxuICBjb2xsZWN0Q29uc3VtaW5nQ3NzVGV4dChjc3NUZXh0KSB7XG4gICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShSWC5CUkFDS0VURUQsICcnKVxuICAgICAgLnJlcGxhY2UoUlguVkFSX0FTU0lHTiwgJycpO1xuICB9XG5cbiAgY29sbGVjdFByb3BlcnRpZXNJbkNzc1RleHQoY3NzVGV4dCwgcHJvcHMpIHtcbiAgICBsZXQgbTtcbiAgICB3aGlsZSAoKG0gPSBSWC5WQVJfQ09OU1VNRUQuZXhlYyhjc3NUZXh0KSkpIHtcbiAgICAgIGxldCBuYW1lID0gbVsxXTtcbiAgICAgIC8vIFRoaXMgcmVnZXggY2F0Y2hlcyBhbGwgdmFyaWFibGUgbmFtZXMsIGFuZCBmb2xsb3dpbmcgbm9uLXdoaXRlc3BhY2UgY2hhclxuICAgICAgLy8gSWYgbmV4dCBjaGFyIGlzIG5vdCAnOicsIHRoZW4gdmFyaWFibGUgaXMgYSBjb25zdW1lclxuICAgICAgaWYgKG1bMl0gIT09ICc6Jykge1xuICAgICAgICBwcm9wc1tuYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gdHVybnMgY3VzdG9tIHByb3BlcnRpZXMgaW50byByZWFsaXplZCB2YWx1ZXMuXG4gIHJlaWZ5KHByb3BzKSB7XG4gICAgLy8gYmlnIHBlcmYgb3B0aW1pemF0aW9uIGhlcmU6IHJlaWZ5IG9ubHkgKm93biogcHJvcGVydGllc1xuICAgIC8vIHNpbmNlIHRoaXMgb2JqZWN0IGhhcyBfX3Byb3RvX18gb2YgdGhlIGVsZW1lbnQncyBzY29wZSBwcm9wZXJ0aWVzXG4gICAgbGV0IG5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMocHJvcHMpO1xuICAgIGZvciAobGV0IGk9MCwgbjsgaSA8IG5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBuID0gbmFtZXNbaV07XG4gICAgICBwcm9wc1tuXSA9IHRoaXMudmFsdWVGb3JQcm9wZXJ0eShwcm9wc1tuXSwgcHJvcHMpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGdpdmVuIGEgcHJvcGVydHkgdmFsdWUsIHJldHVybnMgdGhlIHJlaWZpZWQgdmFsdWVcbiAgLy8gYSBwcm9wZXJ0eSB2YWx1ZSBtYXkgYmU6XG4gIC8vICgxKSBhIGxpdGVyYWwgdmFsdWUgbGlrZTogcmVkIG9yIDVweDtcbiAgLy8gKDIpIGEgdmFyaWFibGUgdmFsdWUgbGlrZTogdmFyKC0tYSksIHZhcigtLWEsIHJlZCksIG9yIHZhcigtLWEsIC0tYikgb3JcbiAgLy8gdmFyKC0tYSwgdmFyKC0tYikpO1xuICAvLyAoMykgYSBsaXRlcmFsIG1peGluIHZhbHVlIGxpa2UgeyBwcm9wZXJ0aWVzIH0uIEVhY2ggb2YgdGhlc2UgcHJvcGVydGllc1xuICAvLyBjYW4gaGF2ZSB2YWx1ZXMgdGhhdCBhcmU6IChhKSBsaXRlcmFsLCAoYikgdmFyaWFibGVzLCAoYykgQGFwcGx5IG1peGlucy5cbiAgdmFsdWVGb3JQcm9wZXJ0eShwcm9wZXJ0eSwgcHJvcHMpIHtcbiAgICAvLyBjYXNlICgxKSBkZWZhdWx0XG4gICAgLy8gY2FzZSAoMykgZGVmaW5lcyBhIG1peGluIGFuZCB3ZSBoYXZlIHRvIHJlaWZ5IHRoZSBpbnRlcm5hbHNcbiAgICBpZiAocHJvcGVydHkpIHtcbiAgICAgIGlmIChwcm9wZXJ0eS5pbmRleE9mKCc7JykgPj0wKSB7XG4gICAgICAgIHByb3BlcnR5ID0gdGhpcy52YWx1ZUZvclByb3BlcnRpZXMocHJvcGVydHksIHByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNhc2UgKDIpIHZhcmlhYmxlXG4gICAgICAgIGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IGZuID0gZnVuY3Rpb24ocHJlZml4LCB2YWx1ZSwgZmFsbGJhY2ssIHN1ZmZpeCkge1xuICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXggKyBzdWZmaXg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCBwcm9wZXJ0eVZhbHVlID0gc2VsZi52YWx1ZUZvclByb3BlcnR5KHByb3BzW3ZhbHVlXSwgcHJvcHMpO1xuICAgICAgICAgIC8vIGlmIHZhbHVlIGlzIFwiaW5pdGlhbFwiLCB0aGVuIHRoZSB2YXJpYWJsZSBzaG91bGQgYmUgdHJlYXRlZCBhcyB1bnNldFxuICAgICAgICAgIGlmICghcHJvcGVydHlWYWx1ZSB8fCBwcm9wZXJ0eVZhbHVlID09PSAnaW5pdGlhbCcpIHtcbiAgICAgICAgICAgIC8vIGZhbGxiYWNrIG1heSBiZSAtLWEgb3IgdmFyKC0tYSkgb3IgbGl0ZXJhbFxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9IHNlbGYudmFsdWVGb3JQcm9wZXJ0eShwcm9wc1tmYWxsYmFja10gfHwgZmFsbGJhY2ssIHByb3BzKSB8fFxuICAgICAgICAgICAgZmFsbGJhY2s7XG4gICAgICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eVZhbHVlID09PSAnYXBwbHktc2hpbS1pbmhlcml0Jykge1xuICAgICAgICAgICAgLy8gQ1NTIGJ1aWxkIHdpbGwgcmVwbGFjZSBgaW5oZXJpdGAgd2l0aCBgYXBwbHktc2hpbS1pbmhlcml0YFxuICAgICAgICAgICAgLy8gZm9yIHVzZSB3aXRoIG5hdGl2ZSBjc3MgdmFyaWFibGVzLlxuICAgICAgICAgICAgLy8gU2luY2Ugd2UgaGF2ZSBmdWxsIGNvbnRyb2wsIHdlIGNhbiB1c2UgYGluaGVyaXRgIGRpcmVjdGx5LlxuICAgICAgICAgICAgcHJvcGVydHlWYWx1ZSA9ICdpbmhlcml0JztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHByZWZpeCArIChwcm9wZXJ0eVZhbHVlIHx8ICcnKSArIHN1ZmZpeDtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvcGVydHkgPSBTdHlsZVV0aWwucHJvY2Vzc1ZhcmlhYmxlQW5kRmFsbGJhY2socHJvcGVydHksIGZuKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5ICYmIHByb3BlcnR5LnRyaW0oKSB8fCAnJztcbiAgfVxuXG4gIC8vIG5vdGU6IHdlIGRvIG5vdCB5ZXQgc3VwcG9ydCBtaXhpbiB3aXRoaW4gbWl4aW5cbiAgdmFsdWVGb3JQcm9wZXJ0aWVzKHByb3BlcnR5LCBwcm9wcykge1xuICAgIGxldCBwYXJ0cyA9IHByb3BlcnR5LnNwbGl0KCc7Jyk7XG4gICAgZm9yIChsZXQgaT0wLCBwLCBtOyBpPHBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoKHAgPSBwYXJ0c1tpXSkpIHtcbiAgICAgICAgUlguTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gMDtcbiAgICAgICAgbSA9IFJYLk1JWElOX01BVENILmV4ZWMocCk7XG4gICAgICAgIGlmIChtKSB7XG4gICAgICAgICAgcCA9IHRoaXMudmFsdWVGb3JQcm9wZXJ0eShwcm9wc1ttWzFdXSwgcHJvcHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBjb2xvbiA9IHAuaW5kZXhPZignOicpO1xuICAgICAgICAgIGlmIChjb2xvbiAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxldCBwcCA9IHAuc3Vic3RyaW5nKGNvbG9uKTtcbiAgICAgICAgICAgIHBwID0gcHAudHJpbSgpO1xuICAgICAgICAgICAgcHAgPSB0aGlzLnZhbHVlRm9yUHJvcGVydHkocHAsIHByb3BzKSB8fCBwcDtcbiAgICAgICAgICAgIHAgPSBwLnN1YnN0cmluZygwLCBjb2xvbikgKyBwcDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcGFydHNbaV0gPSAocCAmJiBwLmxhc3RJbmRleE9mKCc7JykgPT09IHAubGVuZ3RoIC0gMSkgP1xuICAgICAgICAgIC8vIHN0cmlwIHRyYWlsaW5nIDtcbiAgICAgICAgICBwLnNsaWNlKDAsIC0xKSA6XG4gICAgICAgICAgcCB8fCAnJztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJzsnKTtcbiAgfVxuXG4gIGFwcGx5UHJvcGVydGllcyhydWxlLCBwcm9wcykge1xuICAgIGxldCBvdXRwdXQgPSAnJztcbiAgICAvLyBkeW5hbWljYWxseSBhZGRlZCBzaGVldHMgbWF5IG5vdCBiZSBkZWNvcmF0ZWQgc28gZW5zdXJlIHRoZXkgYXJlLlxuICAgIGlmICghcnVsZS5wcm9wZXJ0eUluZm8pIHtcbiAgICAgIHRoaXMuZGVjb3JhdGVSdWxlKHJ1bGUpO1xuICAgIH1cbiAgICBpZiAocnVsZS5wcm9wZXJ0eUluZm8uY3NzVGV4dCkge1xuICAgICAgb3V0cHV0ID0gdGhpcy52YWx1ZUZvclByb3BlcnRpZXMocnVsZS5wcm9wZXJ0eUluZm8uY3NzVGV4dCwgcHJvcHMpO1xuICAgIH1cbiAgICBydWxlWydjc3NUZXh0J10gPSBvdXRwdXQ7XG4gIH1cblxuICAvLyBBcHBseSBrZXlmcmFtZSB0cmFuc2Zvcm1hdGlvbnMgdG8gdGhlIGNzc1RleHQgb2YgYSBnaXZlbiBydWxlLiBUaGVcbiAgLy8ga2V5ZnJhbWVUcmFuc2Zvcm1zIG9iamVjdCBpcyBhIG1hcCBvZiBrZXlmcmFtZSBuYW1lcyB0byB0cmFuc2Zvcm1lclxuICAvLyBmdW5jdGlvbnMgd2hpY2ggdGFrZSBpbiBjc3NUZXh0IGFuZCBzcGl0IG91dCB0cmFuc2Zvcm1lZCBjc3NUZXh0LlxuICBhcHBseUtleWZyYW1lVHJhbnNmb3JtcyhydWxlLCBrZXlmcmFtZVRyYW5zZm9ybXMpIHtcbiAgICBsZXQgaW5wdXQgPSBydWxlWydjc3NUZXh0J107XG4gICAgbGV0IG91dHB1dCA9IHJ1bGVbJ2Nzc1RleHQnXTtcbiAgICBpZiAocnVsZS5oYXNBbmltYXRpb25zID09IG51bGwpIHtcbiAgICAgIC8vIENhY2hlIHdoZXRoZXIgb3Igbm90IHRoZSBydWxlIGhhcyBhbnkgYW5pbWF0aW9ucyB0byBiZWdpbiB3aXRoOlxuICAgICAgcnVsZS5oYXNBbmltYXRpb25zID0gUlguQU5JTUFUSU9OX01BVENILnRlc3QoaW5wdXQpO1xuICAgIH1cbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gYW5pbWF0aW9ucyByZWZlcmVuY2VkLCB3ZSBjYW4gc2tpcCB0cmFuc2Zvcm1zOlxuICAgIGlmIChydWxlLmhhc0FuaW1hdGlvbnMpIHtcbiAgICAgIGxldCB0cmFuc2Zvcm07XG4gICAgICAvLyBJZiB3ZSBoYXZlbid0IHRyYW5zZm9ybWVkIHRoaXMgcnVsZSBiZWZvcmUsIHdlIGl0ZXJhdGUgb3ZlciBhbGxcbiAgICAgIC8vIHRyYW5zZm9ybXM6XG4gICAgICBpZiAocnVsZS5rZXlmcmFtZU5hbWVzVG9UcmFuc2Zvcm0gPT0gbnVsbCkge1xuICAgICAgICBydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybSA9IFtdO1xuICAgICAgICBmb3IgKGxldCBrZXlmcmFtZSBpbiBrZXlmcmFtZVRyYW5zZm9ybXMpIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBrZXlmcmFtZVRyYW5zZm9ybXNba2V5ZnJhbWVdO1xuICAgICAgICAgIG91dHB1dCA9IHRyYW5zZm9ybShpbnB1dCk7XG4gICAgICAgICAgLy8gSWYgdGhlIHRyYW5zZm9ybSBhY3R1YWxseSBjaGFuZ2VkIHRoZSBDU1MgdGV4dCwgd2UgY2FjaGUgdGhlXG4gICAgICAgICAgLy8gdHJhbnNmb3JtIG5hbWUgZm9yIGZ1dHVyZSB1c2U6XG4gICAgICAgICAgaWYgKGlucHV0ICE9PSBvdXRwdXQpIHtcbiAgICAgICAgICAgIGlucHV0ID0gb3V0cHV0O1xuICAgICAgICAgICAgcnVsZS5rZXlmcmFtZU5hbWVzVG9UcmFuc2Zvcm0ucHVzaChrZXlmcmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgYSBsaXN0IG9mIGtleWZyYW1lIG5hbWVzIHRoYXQgYXBwbHkgdG8gdGhpc1xuICAgICAgICAvLyBydWxlLCB3ZSBhcHBseSBvbmx5IHRob3NlIGtleWZyYW1lIG5hbWUgdHJhbnNmb3JtczpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRyYW5zZm9ybSA9IGtleWZyYW1lVHJhbnNmb3Jtc1tydWxlLmtleWZyYW1lTmFtZXNUb1RyYW5zZm9ybVtpXV07XG4gICAgICAgICAgaW5wdXQgPSB0cmFuc2Zvcm0oaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCA9IGlucHV0O1xuICAgICAgfVxuICAgIH1cbiAgICBydWxlWydjc3NUZXh0J10gPSBvdXRwdXQ7XG4gIH1cblxuICAvLyBUZXN0IGlmIHRoZSBydWxlcyBpbiB0aGVzZSBzdHlsZXMgbWF0Y2hlcyB0aGUgZ2l2ZW4gYGVsZW1lbnRgIGFuZCBpZiBzbyxcbiAgLy8gY29sbGVjdCBhbnkgY3VzdG9tIHByb3BlcnRpZXMgaW50byBgcHJvcHNgLlxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVzXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgcHJvcGVydHlEYXRhRnJvbVN0eWxlcyhydWxlcywgZWxlbWVudCkge1xuICAgIGxldCBwcm9wcyA9IHt9O1xuICAgIC8vIGdlbmVyYXRlcyBhIHVuaXF1ZSBrZXkgZm9yIHRoZXNlIG1hdGNoZXNcbiAgICBsZXQgbyA9IFtdO1xuICAgIC8vIG5vdGU6IGFjdGl2ZSBydWxlcyBleGNsdWRlcyBub24tbWF0Y2hpbmcgQG1lZGlhIHJ1bGVzXG4gICAgU3R5bGVVdGlsLmZvckVhY2hSdWxlKHJ1bGVzLCAocnVsZSkgPT4ge1xuICAgICAgLy8gVE9ETyhzb3J2ZWxsKTogd2UgY291bGQgdHJpbSB0aGUgc2V0IG9mIHJ1bGVzIGF0IGRlY2xhcmF0aW9uXG4gICAgICAvLyB0aW1lIHRvIG9ubHkgaW5jbHVkZSBvbmVzIHRoYXQgaGF2ZSBwcm9wZXJ0aWVzXG4gICAgICBpZiAoIXJ1bGUucHJvcGVydHlJbmZvKSB7XG4gICAgICAgIHRoaXMuZGVjb3JhdGVSdWxlKHJ1bGUpO1xuICAgICAgfVxuICAgICAgLy8gbWF0Y2ggZWxlbWVudCBhZ2FpbnN0IHRyYW5zZm9ybWVkU2VsZWN0b3I6IHNlbGVjdG9yIG1heSBjb250YWluXG4gICAgICAvLyB1bndhbnRlZCB1bmlxdWlmaWNhdGlvbiBhbmQgcGFyc2VkU2VsZWN0b3IgZG9lcyBub3QgZGlyZWN0bHkgbWF0Y2hcbiAgICAgIC8vIGZvciA6aG9zdCBzZWxlY3RvcnMuXG4gICAgICBsZXQgc2VsZWN0b3JUb01hdGNoID0gcnVsZS50cmFuc2Zvcm1lZFNlbGVjdG9yIHx8IHJ1bGVbJ3BhcnNlZFNlbGVjdG9yJ107XG4gICAgICBpZiAoZWxlbWVudCAmJiBydWxlLnByb3BlcnR5SW5mby5wcm9wZXJ0aWVzICYmIHNlbGVjdG9yVG9NYXRjaCkge1xuICAgICAgICBpZiAobWF0Y2hlc1NlbGVjdG9yLmNhbGwoZWxlbWVudCwgc2VsZWN0b3JUb01hdGNoKSkge1xuICAgICAgICAgIHRoaXMuY29sbGVjdFByb3BlcnRpZXMocnVsZSwgcHJvcHMpO1xuICAgICAgICAgIC8vIHByb2R1Y2UgbnVtZXJpYyBrZXkgZm9yIHRoZXNlIG1hdGNoZXMgZm9yIGxvb2t1cFxuICAgICAgICAgIGFkZFRvQml0TWFzayhydWxlLmluZGV4LCBvKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sIG51bGwsIHRydWUpO1xuICAgIHJldHVybiB7cHJvcGVydGllczogcHJvcHMsIGtleTogb307XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzY29wZVxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3NzQnVpbGRcbiAgICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QpfSBjYWxsYmFja1xuICAgKi9cbiAgd2hlbkhvc3RPclJvb3RSdWxlKHNjb3BlLCBydWxlLCBjc3NCdWlsZCwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXJ1bGUucHJvcGVydHlJbmZvKSB7XG4gICAgICB0aGlzLmRlY29yYXRlUnVsZShydWxlKTtcbiAgICB9XG4gICAgaWYgKCFydWxlLnByb3BlcnR5SW5mby5wcm9wZXJ0aWVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxldCB7aXMsIHR5cGVFeHRlbnNpb259ID0gU3R5bGVVdGlsLmdldElzRXh0ZW5kcyhzY29wZSk7XG4gICAgbGV0IGhvc3RTY29wZSA9IGlzID9cbiAgICAgIFN0eWxlVHJhbnNmb3JtZXIuX2NhbGNIb3N0U2NvcGUoaXMsIHR5cGVFeHRlbnNpb24pIDpcbiAgICAgICdodG1sJztcbiAgICBsZXQgcGFyc2VkU2VsZWN0b3IgPSBydWxlWydwYXJzZWRTZWxlY3RvciddO1xuICAgIGxldCBpc1Jvb3QgPSAocGFyc2VkU2VsZWN0b3IgPT09ICc6aG9zdCA+IConIHx8IHBhcnNlZFNlbGVjdG9yID09PSAnaHRtbCcpO1xuICAgIGxldCBpc0hvc3QgPSBwYXJzZWRTZWxlY3Rvci5pbmRleE9mKCc6aG9zdCcpID09PSAwICYmICFpc1Jvb3Q7XG4gICAgLy8gYnVpbGQgaW5mbyBpcyBlaXRoZXIgaW4gc2NvcGUgKHdoZW4gc2NvcGUgaXMgYW4gZWxlbWVudCkgb3IgaW4gdGhlIHN0eWxlXG4gICAgLy8gd2hlbiBzY29wZSBpcyB0aGUgZGVmYXVsdCBzY29wZTsgbm90ZTogdGhpcyBhbGxvd3MgZGVmYXVsdCBzY29wZSB0byBoYXZlXG4gICAgLy8gbWl4ZWQgbW9kZSBidWlsdCBhbmQgdW5idWlsdCBzdHlsZXMuXG4gICAgaWYgKGNzc0J1aWxkID09PSAnc2hhZHknKSB7XG4gICAgICAvLyA6cm9vdCAtPiB4LWZvbyA+ICoueC1mb28gZm9yIGVsZW1lbnRzIGFuZCBodG1sIGZvciBjdXN0b20tc3R5bGVcbiAgICAgIGlzUm9vdCA9IHBhcnNlZFNlbGVjdG9yID09PSAoaG9zdFNjb3BlICsgJyA+ICouJyArIGhvc3RTY29wZSkgfHwgcGFyc2VkU2VsZWN0b3IuaW5kZXhPZignaHRtbCcpICE9PSAtMTtcbiAgICAgIC8vIDpob3N0IC0+IHgtZm9vIGZvciBlbGVtZW50cywgYnV0IHN1Yi1ydWxlcyBoYXZlIC54LWZvbyBpbiB0aGVtXG4gICAgICBpc0hvc3QgPSAhaXNSb290ICYmIHBhcnNlZFNlbGVjdG9yLmluZGV4T2YoaG9zdFNjb3BlKSA9PT0gMDtcbiAgICB9XG4gICAgaWYgKCFpc1Jvb3QgJiYgIWlzSG9zdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgc2VsZWN0b3JUb01hdGNoID0gaG9zdFNjb3BlO1xuICAgIGlmIChpc0hvc3QpIHtcbiAgICAgIC8vIG5lZWQgdG8gdHJhbnNmb3JtIDpob3N0IGJlY2F1c2UgYDpob3N0YCBkb2VzIG5vdCB3b3JrIHdpdGggYG1hdGNoZXNgXG4gICAgICBpZiAoIXJ1bGUudHJhbnNmb3JtZWRTZWxlY3Rvcikge1xuICAgICAgICAvLyB0cmFuc2Zvcm0gOmhvc3QgaW50byBhIG1hdGNoYWJsZSBzZWxlY3RvclxuICAgICAgICBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IgPVxuICAgICAgICBTdHlsZVRyYW5zZm9ybWVyLl90cmFuc2Zvcm1SdWxlQ3NzKFxuICAgICAgICAgIHJ1bGUsXG4gICAgICAgICAgU3R5bGVUcmFuc2Zvcm1lci5fdHJhbnNmb3JtQ29tcGxleFNlbGVjdG9yLFxuICAgICAgICAgIFN0eWxlVHJhbnNmb3JtZXIuX2NhbGNFbGVtZW50U2NvcGUoaXMpLFxuICAgICAgICAgIGhvc3RTY29wZVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgc2VsZWN0b3JUb01hdGNoID0gcnVsZS50cmFuc2Zvcm1lZFNlbGVjdG9yIHx8IGhvc3RTY29wZTtcbiAgICB9XG4gICAgY2FsbGJhY2soe1xuICAgICAgc2VsZWN0b3I6IHNlbGVjdG9yVG9NYXRjaCxcbiAgICAgIGlzSG9zdDogaXNIb3N0LFxuICAgICAgaXNSb290OiBpc1Jvb3RcbiAgICB9KTtcbiAgfVxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IHNjb3BlXG4gKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZXNcbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NCdWlsZFxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG4gIGhvc3RBbmRSb290UHJvcGVydGllc0ZvclNjb3BlKHNjb3BlLCBydWxlcywgY3NzQnVpbGQpIHtcbiAgICBsZXQgaG9zdFByb3BzID0ge30sIHJvb3RQcm9wcyA9IHt9O1xuICAgIC8vIG5vdGU6IGFjdGl2ZSBydWxlcyBleGNsdWRlcyBub24tbWF0Y2hpbmcgQG1lZGlhIHJ1bGVzXG4gICAgU3R5bGVVdGlsLmZvckVhY2hSdWxlKHJ1bGVzLCAocnVsZSkgPT4ge1xuICAgICAgLy8gaWYgc2NvcGUgaXMgU3R5bGVEZWZhdWx0cywgdXNlIF9lbGVtZW50IGZvciBtYXRjaGVzU2VsZWN0b3JcbiAgICAgIHRoaXMud2hlbkhvc3RPclJvb3RSdWxlKHNjb3BlLCBydWxlLCBjc3NCdWlsZCwgKGluZm8pID0+IHtcbiAgICAgICAgbGV0IGVsZW1lbnQgPSBzY29wZS5fZWxlbWVudCB8fCBzY29wZTtcbiAgICAgICAgaWYgKG1hdGNoZXNTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIGluZm8uc2VsZWN0b3IpKSB7XG4gICAgICAgICAgaWYgKGluZm8uaXNIb3N0KSB7XG4gICAgICAgICAgICB0aGlzLmNvbGxlY3RQcm9wZXJ0aWVzKHJ1bGUsIGhvc3RQcm9wcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdFByb3BlcnRpZXMocnVsZSwgcm9vdFByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0sIG51bGwsIHRydWUpO1xuICAgIHJldHVybiB7cm9vdFByb3BzOiByb290UHJvcHMsIGhvc3RQcm9wczogaG9zdFByb3BzfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlU2VsZWN0b3JcbiAgICovXG4gIHRyYW5zZm9ybVN0eWxlcyhlbGVtZW50LCBwcm9wZXJ0aWVzLCBzY29wZVNlbGVjdG9yKSB7XG4gICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgIGxldCB7aXMsIHR5cGVFeHRlbnNpb259ID0gU3R5bGVVdGlsLmdldElzRXh0ZW5kcyhlbGVtZW50KTtcbiAgICBsZXQgaG9zdFNlbGVjdG9yID0gU3R5bGVUcmFuc2Zvcm1lclxuICAgICAgLl9jYWxjSG9zdFNjb3BlKGlzLCB0eXBlRXh0ZW5zaW9uKTtcbiAgICBsZXQgcnhIb3N0U2VsZWN0b3IgPSBlbGVtZW50LmV4dGVuZHMgP1xuICAgICAgJ1xcXFwnICsgaG9zdFNlbGVjdG9yLnNsaWNlKDAsIC0xKSArICdcXFxcXScgOlxuICAgICAgaG9zdFNlbGVjdG9yO1xuICAgIGxldCBob3N0UnggPSBuZXcgUmVnRXhwKFJYLkhPU1RfUFJFRklYICsgcnhIb3N0U2VsZWN0b3IgK1xuICAgICAgUlguSE9TVF9TVUZGSVgpO1xuICAgIGxldCB7c3R5bGVSdWxlczogcnVsZXMsIGNzc0J1aWxkfSA9IFN0eWxlSW5mby5nZXQoZWxlbWVudCk7XG4gICAgbGV0IGtleWZyYW1lVHJhbnNmb3JtcyA9XG4gICAgICB0aGlzLl9lbGVtZW50S2V5ZnJhbWVUcmFuc2Zvcm1zKGVsZW1lbnQsIHJ1bGVzLCBzY29wZVNlbGVjdG9yKTtcbiAgICByZXR1cm4gU3R5bGVUcmFuc2Zvcm1lci5lbGVtZW50U3R5bGVzKGVsZW1lbnQsIHJ1bGVzLCBmdW5jdGlvbihydWxlKSB7XG4gICAgICBzZWxmLmFwcGx5UHJvcGVydGllcyhydWxlLCBwcm9wZXJ0aWVzKTtcbiAgICAgIGlmICghbmF0aXZlU2hhZG93ICYmXG4gICAgICAgICAgIVN0eWxlVXRpbC5pc0tleWZyYW1lc1NlbGVjdG9yKHJ1bGUpICYmXG4gICAgICAgICAgcnVsZVsnY3NzVGV4dCddKSB7XG4gICAgICAgIC8vIE5PVEU6IGtleWZyYW1lIHRyYW5zZm9ybXMgb25seSBzY29wZSBtdW5nZSBhbmltYXRpb24gbmFtZXMsIHNvIGl0XG4gICAgICAgIC8vIGlzIG5vdCBuZWNlc3NhcnkgdG8gYXBwbHkgdGhlbSBpbiBTaGFkb3dET00uXG4gICAgICAgIHNlbGYuYXBwbHlLZXlmcmFtZVRyYW5zZm9ybXMocnVsZSwga2V5ZnJhbWVUcmFuc2Zvcm1zKTtcbiAgICAgICAgc2VsZi5fc2NvcGVTZWxlY3RvcihydWxlLCBob3N0UngsIGhvc3RTZWxlY3Rvciwgc2NvcGVTZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfSwgY3NzQnVpbGQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge1N0eWxlTm9kZX0gcnVsZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlU2VsZWN0b3JcbiAgICogQHJldHVybiB7T2JqZWN0fVxuICAgKi9cbiAgX2VsZW1lbnRLZXlmcmFtZVRyYW5zZm9ybXMoZWxlbWVudCwgcnVsZXMsIHNjb3BlU2VsZWN0b3IpIHtcbiAgICBsZXQga2V5ZnJhbWVzUnVsZXMgPSBydWxlcy5fa2V5ZnJhbWVzO1xuICAgIGxldCBrZXlmcmFtZVRyYW5zZm9ybXMgPSB7fTtcbiAgICBpZiAoIW5hdGl2ZVNoYWRvdyAmJiBrZXlmcmFtZXNSdWxlcykge1xuICAgICAgLy8gRm9yIG5vbi1TaGFkb3dET00sIHdlIHRyYW5zZm9ybSBhbGwga25vd24ga2V5ZnJhbWVzIHJ1bGVzIGluXG4gICAgICAvLyBhZHZhbmNlIGZvciB0aGUgY3VycmVudCBzY29wZS4gVGhpcyBhbGxvd3MgdXMgdG8gY2F0Y2gga2V5ZnJhbWVzXG4gICAgICAvLyBydWxlcyB0aGF0IGFwcGVhciBhbnl3aGVyZSBpbiB0aGUgc3R5bGVzaGVldDpcbiAgICAgIGZvciAobGV0IGkgPSAwLCBrZXlmcmFtZXNSdWxlID0ga2V5ZnJhbWVzUnVsZXNbaV07XG4gICAgICAgICAgIGkgPCBrZXlmcmFtZXNSdWxlcy5sZW5ndGg7XG4gICAgICAgICAgIGtleWZyYW1lc1J1bGUgPSBrZXlmcmFtZXNSdWxlc1srK2ldKSB7XG4gICAgICAgIHRoaXMuX3Njb3BlS2V5ZnJhbWVzKGtleWZyYW1lc1J1bGUsIHNjb3BlU2VsZWN0b3IpO1xuICAgICAgICBrZXlmcmFtZVRyYW5zZm9ybXNba2V5ZnJhbWVzUnVsZVsna2V5ZnJhbWVzTmFtZSddXSA9XG4gICAgICAgICAgICB0aGlzLl9rZXlmcmFtZXNSdWxlVHJhbnNmb3JtZXIoa2V5ZnJhbWVzUnVsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBrZXlmcmFtZVRyYW5zZm9ybXM7XG4gIH1cblxuICAvLyBHZW5lcmF0ZSBhIGZhY3RvcnkgZm9yIHRyYW5zZm9ybWluZyBhIGNodW5rIG9mIENTUyB0ZXh0IHRvIGhhbmRsZSBhXG4gIC8vIHBhcnRpY3VsYXIgc2NvcGVkIGtleWZyYW1lcyBydWxlLlxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IGtleWZyYW1lc1J1bGVcbiAgICogQHJldHVybiB7ZnVuY3Rpb24oc3RyaW5nKTpzdHJpbmd9XG4gICAqL1xuICBfa2V5ZnJhbWVzUnVsZVRyYW5zZm9ybWVyKGtleWZyYW1lc1J1bGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oY3NzVGV4dCkge1xuICAgICAgcmV0dXJuIGNzc1RleHQucmVwbGFjZShcbiAgICAgICAgICBrZXlmcmFtZXNSdWxlLmtleWZyYW1lc05hbWVSeCxcbiAgICAgICAgICBrZXlmcmFtZXNSdWxlLnRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSk7XG4gICAgfTtcbiAgfVxuXG4vKipcbiAqIFRyYW5zZm9ybXMgYEBrZXlmcmFtZXNgIG5hbWVzIHRvIGJlIHVuaXF1ZSBmb3IgdGhlIGN1cnJlbnQgaG9zdC5cbiAqIEV4YW1wbGU6IEBrZXlmcmFtZXMgZm9vLWFuaW0gLT4gQGtleWZyYW1lcyBmb28tYW5pbS14LWZvby0wXG4gKlxuICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZUlkXG4gKi9cbiAgX3Njb3BlS2V5ZnJhbWVzKHJ1bGUsIHNjb3BlSWQpIHtcbiAgICAvLyBBbmltYXRpb24gbmFtZXMgYXJlIG9mIHRoZSBmb3JtIFtcXHctXSwgc28gZW5zdXJlIHRoYXQgdGhlIG5hbWUgcmVnZXggZG9lcyBub3QgcGFydGlhbGx5IGFwcGx5XG4gICAgLy8gdG8gc2ltaWxhcmx5IG5hbWVkIGtleWZyYW1lIG5hbWVzIGJ5IGNoZWNraW5nIGZvciBhIHdvcmQgYm91bmRhcnkgYXQgdGhlIGJlZ2lubmluZyBhbmRcbiAgICAvLyBhIG5vbi13b3JkIGJvdW5kYXJ5IG9yIGAtYCBhdCB0aGUgZW5kLlxuICAgIHJ1bGUua2V5ZnJhbWVzTmFtZVJ4ID0gbmV3IFJlZ0V4cChgXFxcXGIke3J1bGVbJ2tleWZyYW1lc05hbWUnXX0oPyFcXFxcQnwtKWAsICdnJyk7XG4gICAgcnVsZS50cmFuc2Zvcm1lZEtleWZyYW1lc05hbWUgPSBydWxlWydrZXlmcmFtZXNOYW1lJ10gKyAnLScgKyBzY29wZUlkO1xuICAgIHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciA9IHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciB8fCBydWxlWydzZWxlY3RvciddO1xuICAgIHJ1bGVbJ3NlbGVjdG9yJ10gPSBydWxlLnRyYW5zZm9ybWVkU2VsZWN0b3IucmVwbGFjZShcbiAgICAgICAgcnVsZVsna2V5ZnJhbWVzTmFtZSddLCBydWxlLnRyYW5zZm9ybWVkS2V5ZnJhbWVzTmFtZSk7XG4gIH1cblxuICAvLyBTdHJhdGVneTogeCBzY29wZSBzaGltIGEgc2VsZWN0b3IgZS5nLiB0byBzY29wZSBgLngtZm9vLTQyYCAodmlhIGNsYXNzZXMpOlxuICAvLyBub24taG9zdCBzZWxlY3RvcjogLmEueC1mb28gLT4gLngtZm9vLTQyIC5hLngtZm9vXG4gIC8vIGhvc3Qgc2VsZWN0b3I6IHgtZm9vLndpZGUgLT4gLngtZm9vLTQyLndpZGVcbiAgLy8gbm90ZTogd2UgdXNlIG9ubHkgdGhlIHNjb3BlIGNsYXNzICgueC1mb28tNDIpIGFuZCBub3QgdGhlIGhvc3RTZWxlY3RvclxuICAvLyAoeC1mb28pIHRvIHNjb3BlIDpob3N0IHJ1bGVzOyB0aGlzIGhlbHBzIG1ha2UgcHJvcGVydHkgaG9zdCBydWxlc1xuICAvLyBoYXZlIGxvdyBzcGVjaWZpY2l0eS4gVGhleSBhcmUgb3ZlcnJpZGVhYmxlIGJ5IGNsYXNzIHNlbGVjdG9ycyBidXQsXG4gIC8vIHVuZm9ydHVuYXRlbHksIG5vdCBieSB0eXBlIHNlbGVjdG9ycyAoZS5nLiBvdmVycmlkaW5nIHZpYVxuICAvLyBgLnNwZWNpYWxgIGlzIG9rLCBidXQgbm90IGJ5IGB4LWZvb2ApLlxuICAvKipcbiAgICogQHBhcmFtIHtTdHlsZU5vZGV9IHJ1bGVcbiAgICogQHBhcmFtIHtSZWdFeHB9IGhvc3RSeFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaG9zdFNlbGVjdG9yXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZUlkXG4gICAqL1xuICBfc2NvcGVTZWxlY3RvcihydWxlLCBob3N0UngsIGhvc3RTZWxlY3Rvciwgc2NvcGVJZCkge1xuICAgIHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciA9IHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvciB8fCBydWxlWydzZWxlY3RvciddO1xuICAgIGxldCBzZWxlY3RvciA9IHJ1bGUudHJhbnNmb3JtZWRTZWxlY3RvcjtcbiAgICBsZXQgc2NvcGUgPSAnLicgKyBzY29wZUlkO1xuICAgIGxldCBwYXJ0cyA9IFN0eWxlVXRpbC5zcGxpdFNlbGVjdG9yTGlzdChzZWxlY3Rvcik7XG4gICAgZm9yIChsZXQgaT0wLCBsPXBhcnRzLmxlbmd0aCwgcDsgKGk8bCkgJiYgKHA9cGFydHNbaV0pOyBpKyspIHtcbiAgICAgIHBhcnRzW2ldID0gcC5tYXRjaChob3N0UngpID9cbiAgICAgICAgcC5yZXBsYWNlKGhvc3RTZWxlY3Rvciwgc2NvcGUpIDpcbiAgICAgICAgc2NvcGUgKyAnICcgKyBwO1xuICAgIH1cbiAgICBydWxlWydzZWxlY3RvciddID0gcGFydHMuam9pbignLCcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2VsZWN0b3JcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZFxuICAgKi9cbiAgYXBwbHlFbGVtZW50U2NvcGVTZWxlY3RvcihlbGVtZW50LCBzZWxlY3Rvciwgb2xkKSB7XG4gICAgbGV0IGMgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJztcbiAgICBsZXQgdiA9IGM7XG4gICAgaWYgKG9sZCkge1xuICAgICAgdiA9IGMucmVwbGFjZShcbiAgICAgICAgbmV3IFJlZ0V4cCgnXFxcXHMqJyArIFhTQ09QRV9OQU1FICsgJ1xcXFxzKicgKyBvbGQgKyAnXFxcXHMqJywgJ2cnKSwgJyAnKTtcbiAgICB9XG4gICAgdiArPSAodiA/ICcgJyA6ICcnKSArIFhTQ09QRV9OQU1FICsgJyAnICsgc2VsZWN0b3I7XG4gICAgaWYgKGMgIT09IHYpIHtcbiAgICAgIFN0eWxlVXRpbC5zZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgdik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEBwYXJhbSB7SFRNTFN0eWxlRWxlbWVudH0gc3R5bGVcbiAgICogQHJldHVybiB7SFRNTFN0eWxlRWxlbWVudH1cbiAgICovXG4gIGFwcGx5RWxlbWVudFN0eWxlKGVsZW1lbnQsIHByb3BlcnRpZXMsIHNlbGVjdG9yLCBzdHlsZSkge1xuICAgIC8vIGNhbGN1bGF0ZSBjc3NUZXh0IHRvIGFwcGx5XG4gICAgbGV0IGNzc1RleHQgPSBzdHlsZSA/IHN0eWxlLnRleHRDb250ZW50IHx8ICcnIDpcbiAgICAgIHRoaXMudHJhbnNmb3JtU3R5bGVzKGVsZW1lbnQsIHByb3BlcnRpZXMsIHNlbGVjdG9yKTtcbiAgICAvLyBpZiBzaGFkeSBhbmQgd2UgaGF2ZSBhIGNhY2hlZCBzdHlsZSB0aGF0IGlzIG5vdCBzdHlsZSwgZGVjcmVtZW50XG4gICAgbGV0IHN0eWxlSW5mbyA9IFN0eWxlSW5mby5nZXQoZWxlbWVudCk7XG4gICAgbGV0IHMgPSBzdHlsZUluZm8uY3VzdG9tU3R5bGU7XG4gICAgaWYgKHMgJiYgIW5hdGl2ZVNoYWRvdyAmJiAocyAhPT0gc3R5bGUpKSB7XG4gICAgICBzWydfdXNlQ291bnQnXS0tO1xuICAgICAgaWYgKHNbJ191c2VDb3VudCddIDw9IDAgJiYgcy5wYXJlbnROb2RlKSB7XG4gICAgICAgIHMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXBwbHkgc3R5bGluZyBhbHdheXMgdW5kZXIgbmF0aXZlIG9yIGlmIHdlIGdlbmVyYXRlZCBzdHlsZVxuICAgIC8vIG9yIHRoZSBjYWNoZWQgc3R5bGUgaXMgbm90IGluIGRvY3VtZW50KCEpXG4gICAgaWYgKG5hdGl2ZVNoYWRvdykge1xuICAgICAgLy8gdXBkYXRlIGV4aXN0aW5nIHN0eWxlIG9ubHkgdW5kZXIgbmF0aXZlXG4gICAgICBpZiAoc3R5bGVJbmZvLmN1c3RvbVN0eWxlKSB7XG4gICAgICAgIHN0eWxlSW5mby5jdXN0b21TdHlsZS50ZXh0Q29udGVudCA9IGNzc1RleHQ7XG4gICAgICAgIHN0eWxlID0gc3R5bGVJbmZvLmN1c3RvbVN0eWxlO1xuICAgICAgLy8gb3RoZXJ3aXNlLCBpZiB3ZSBoYXZlIGNzcyB0byBhcHBseSwgZG8gc29cbiAgICAgIH0gZWxzZSBpZiAoY3NzVGV4dCkge1xuICAgICAgICAvLyBhcHBseSBjc3MgYWZ0ZXIgdGhlIHNjb3BlIHN0eWxlIG9mIHRoZSBlbGVtZW50IHRvIGhlbHAgd2l0aFxuICAgICAgICAvLyBzdHlsZSBwcmVjZWRlbmNlIHJ1bGVzLlxuICAgICAgICBzdHlsZSA9IFN0eWxlVXRpbC5hcHBseUNzcyhjc3NUZXh0LCBzZWxlY3RvciwgZWxlbWVudC5zaGFkb3dSb290LFxuICAgICAgICAgIHN0eWxlSW5mby5wbGFjZWhvbGRlcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNoYWR5IGFuZCBubyBjYWNoZSBoaXRcbiAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgLy8gYXBwbHkgY3NzIGFmdGVyIHRoZSBzY29wZSBzdHlsZSBvZiB0aGUgZWxlbWVudCB0byBoZWxwIHdpdGhcbiAgICAgICAgLy8gc3R5bGUgcHJlY2VkZW5jZSBydWxlcy5cbiAgICAgICAgaWYgKGNzc1RleHQpIHtcbiAgICAgICAgICBzdHlsZSA9IFN0eWxlVXRpbC5hcHBseUNzcyhjc3NUZXh0LCBzZWxlY3RvciwgbnVsbCxcbiAgICAgICAgICAgIHN0eWxlSW5mby5wbGFjZWhvbGRlcik7XG4gICAgICAgIH1cbiAgICAgIC8vIHNoYWR5IGFuZCBjYWNoZSBoaXQgYnV0IG5vdCBpbiBkb2N1bWVudFxuICAgICAgfSBlbHNlIGlmICghc3R5bGUucGFyZW50Tm9kZSkge1xuICAgICAgICBpZiAoSVNfSUUgJiYgY3NzVGV4dC5pbmRleE9mKCdAbWVkaWEnKSA+IC0xKSB7XG4gICAgICAgICAgICAvLyBAbWVkaWEgcnVsZXMgbWF5IGJlIHN0YWxlIGluIElFIDEwIGFuZCAxMVxuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBzdHlsZSB0byByZXZhbGlkYXRlIHRoZW0uXG4gICAgICAgICAgc3R5bGUudGV4dENvbnRlbnQgPSBjc3NUZXh0O1xuICAgICAgICB9XG4gICAgICAgIFN0eWxlVXRpbC5hcHBseVN0eWxlKHN0eWxlLCBudWxsLCBzdHlsZUluZm8ucGxhY2Vob2xkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgdGhpcyBzdHlsZSBpcyBvdXIgY3VzdG9tIHN0eWxlIGFuZCBpbmNyZW1lbnQgaXRzIHVzZSBjb3VudC5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN0eWxlWydfdXNlQ291bnQnXSA9IHN0eWxlWydfdXNlQ291bnQnXSB8fCAwO1xuICAgICAgLy8gaW5jcmVtZW50IHVzZSBjb3VudCBpZiB3ZSBjaGFuZ2VkIHN0eWxlc1xuICAgICAgaWYgKHN0eWxlSW5mby5jdXN0b21TdHlsZSAhPSBzdHlsZSkge1xuICAgICAgICBzdHlsZVsnX3VzZUNvdW50J10rKztcbiAgICAgIH1cbiAgICAgIHN0eWxlSW5mby5jdXN0b21TdHlsZSA9IHN0eWxlO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGU7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBzdHlsZVxuICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllc1xuICAgKi9cbiAgYXBwbHlDdXN0b21TdHlsZShzdHlsZSwgcHJvcGVydGllcykge1xuICAgIGxldCBydWxlcyA9IFN0eWxlVXRpbC5ydWxlc0ZvclN0eWxlKC8qKiBAdHlwZSB7SFRNTFN0eWxlRWxlbWVudH0gKi8oc3R5bGUpKTtcbiAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgc3R5bGUudGV4dENvbnRlbnQgPSBTdHlsZVV0aWwudG9Dc3NUZXh0KHJ1bGVzLCBmdW5jdGlvbigvKiogU3R5bGVOb2RlICovcnVsZSkge1xuICAgICAgbGV0IGNzcyA9IHJ1bGVbJ2Nzc1RleHQnXSA9IHJ1bGVbJ3BhcnNlZENzc1RleHQnXTtcbiAgICAgIGlmIChydWxlLnByb3BlcnR5SW5mbyAmJiBydWxlLnByb3BlcnR5SW5mby5jc3NUZXh0KSB7XG4gICAgICAgIC8vIHJlbW92ZSBwcm9wZXJ0eSBhc3NpZ25tZW50c1xuICAgICAgICAvLyBzbyBuZXh0IGZ1bmN0aW9uIGlzbid0IGNvbmZ1c2VkXG4gICAgICAgIC8vIE5PVEU6IHdlIGhhdmUgMyBjYXRlZ29yaWVzIG9mIGNzczpcbiAgICAgICAgLy8gKDEpIG5vcm1hbCBwcm9wZXJ0aWVzLFxuICAgICAgICAvLyAoMikgY3VzdG9tIHByb3BlcnR5IGFzc2lnbm1lbnRzICgtLWZvbzogcmVkOyksXG4gICAgICAgIC8vICgzKSBjdXN0b20gcHJvcGVydHkgdXNhZ2U6IGJvcmRlcjogdmFyKC0tZm9vKTsgQGFwcGx5KC0tZm9vKTtcbiAgICAgICAgLy8gSW4gZWxlbWVudHMsIDEgYW5kIDMgYXJlIHNlcGFyYXRlZCBmb3IgZWZmaWNpZW5jeTsgaGVyZSB0aGV5XG4gICAgICAgIC8vIGFyZSBub3QgYW5kIHRoaXMgbWFrZXMgdGhpcyBjYXNlIHVuaXF1ZS5cbiAgICAgICAgY3NzID0gcmVtb3ZlQ3VzdG9tUHJvcEFzc2lnbm1lbnQoLyoqIEB0eXBlIHtzdHJpbmd9ICovKGNzcykpO1xuICAgICAgICAvLyByZXBsYWNlIHdpdGggcmVpZmllZCBwcm9wZXJ0aWVzLCBzY2VuYXJpbyBpcyBzYW1lIGFzIG1peGluXG4gICAgICAgIHJ1bGVbJ2Nzc1RleHQnXSA9IHNlbGYudmFsdWVGb3JQcm9wZXJ0aWVzKGNzcywgcHJvcGVydGllcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gblxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiaXRzXG4gKi9cbmZ1bmN0aW9uIGFkZFRvQml0TWFzayhuLCBiaXRzKSB7XG4gIGxldCBvID0gcGFyc2VJbnQobiAvIDMyLCAxMCk7XG4gIGxldCB2ID0gMSA8PCAobiAlIDMyKTtcbiAgYml0c1tvXSA9IChiaXRzW29dIHx8IDApIHwgdjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgbmV3IFN0eWxlUHJvcGVydGllcygpOyIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHthcHBseVN0eWxlUGxhY2VIb2xkZXJ9IGZyb20gJy4vc3R5bGUtdXRpbC5qcyc7XG5pbXBvcnQge25hdGl2ZVNoYWRvdywgZGlzYWJsZVJ1bnRpbWV9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuXG4vKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCAhTm9kZT59ICovXG5jb25zdCBwbGFjZWhvbGRlck1hcCA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Tm9kZX1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFN0eWxlUGxhY2Vob2xkZXIoZWxlbWVudE5hbWUpIHtcbiAgcmV0dXJuIHBsYWNlaG9sZGVyTWFwW2VsZW1lbnROYW1lXSB8fCBudWxsO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU3R5bGVQbGFjZWhvbGRlcihlbGVtZW50TmFtZSkge1xuICBpZiAoIXBsYWNlaG9sZGVyTWFwW2VsZW1lbnROYW1lXSkge1xuICAgIHBsYWNlaG9sZGVyTWFwW2VsZW1lbnROYW1lXSA9IGFwcGx5U3R5bGVQbGFjZUhvbGRlcihlbGVtZW50TmFtZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3Qge0N1c3RvbUVsZW1lbnRSZWdpc3RyeX1cbiAqL1xuY29uc3QgY2UgPSB3aW5kb3dbJ2N1c3RvbUVsZW1lbnRzJ107XG5pZiAoY2UgJiYgIW5hdGl2ZVNoYWRvdyAmJiAhZGlzYWJsZVJ1bnRpbWUpIHtcbiAgLyoqXG4gICAqIEBjb25zdCB7ZnVuY3Rpb24odGhpczpDdXN0b21FbGVtZW50UmVnaXN0cnksIHN0cmluZyxmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpLHtleHRlbmRzOiBzdHJpbmd9PSl9XG4gICAqL1xuICBjb25zdCBvcmlnRGVmaW5lID0gY2VbJ2RlZmluZSddO1xuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6SFRNTEVsZW1lbnQpfSBjbGF6elxuICAgKiBAcGFyYW0ge3tleHRlbmRzOiBzdHJpbmd9PX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3Qgd3JhcHBlZERlZmluZSA9IChuYW1lLCBjbGF6eiwgb3B0aW9ucykgPT4ge1xuICAgIGVuc3VyZVN0eWxlUGxhY2Vob2xkZXIobmFtZSk7XG4gICAgb3JpZ0RlZmluZS5jYWxsKC8qKiBAdHlwZSB7IUN1c3RvbUVsZW1lbnRSZWdpc3RyeX0gKi8oY2UpLCBuYW1lLCBjbGF6eiwgb3B0aW9ucyk7XG4gIH07XG4gIGNlWydkZWZpbmUnXSA9IHdyYXBwZWREZWZpbmU7XG59IiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cbid1c2Ugc3RyaWN0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3R5bGVDYWNoZSB7XG4gIGNvbnN0cnVjdG9yKHR5cGVNYXggPSAxMDApIHtcbiAgICAvLyBtYXAgZWxlbWVudCBuYW1lIC0+IFt7cHJvcGVydGllcywgc3R5bGVFbGVtZW50LCBzY29wZVNlbGVjdG9yfV1cbiAgICB0aGlzLmNhY2hlID0ge307XG4gICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovXG4gICAgdGhpcy50eXBlTWF4ID0gdHlwZU1heDtcbiAgfVxuXG4gIF92YWxpZGF0ZShjYWNoZUVudHJ5LCBwcm9wZXJ0aWVzLCBvd25Qcm9wZXJ0eU5hbWVzKSB7XG4gICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgb3duUHJvcGVydHlOYW1lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICBsZXQgcG4gPSBvd25Qcm9wZXJ0eU5hbWVzW2lkeF07XG4gICAgICBpZiAoY2FjaGVFbnRyeS5wcm9wZXJ0aWVzW3BuXSAhPT0gcHJvcGVydGllc1twbl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHN0b3JlKHRhZ25hbWUsIHByb3BlcnRpZXMsIHN0eWxlRWxlbWVudCwgc2NvcGVTZWxlY3Rvcikge1xuICAgIGxldCBsaXN0ID0gdGhpcy5jYWNoZVt0YWduYW1lXSB8fCBbXTtcbiAgICBsaXN0LnB1c2goe3Byb3BlcnRpZXMsIHN0eWxlRWxlbWVudCwgc2NvcGVTZWxlY3Rvcn0pO1xuICAgIGlmIChsaXN0Lmxlbmd0aCA+IHRoaXMudHlwZU1heCkge1xuICAgICAgbGlzdC5zaGlmdCgpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlW3RhZ25hbWVdID0gbGlzdDtcbiAgfVxuXG4gIGZldGNoKHRhZ25hbWUsIHByb3BlcnRpZXMsIG93blByb3BlcnR5TmFtZXMpIHtcbiAgICBsZXQgbGlzdCA9IHRoaXMuY2FjaGVbdGFnbmFtZV07XG4gICAgaWYgKCFsaXN0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHJldmVyc2UgbGlzdCBmb3IgbW9zdC1yZWNlbnQgbG9va3Vwc1xuICAgIGZvciAobGV0IGlkeCA9IGxpc3QubGVuZ3RoIC0gMTsgaWR4ID49IDA7IGlkeC0tKSB7XG4gICAgICBsZXQgZW50cnkgPSBsaXN0W2lkeF07XG4gICAgICBpZiAodGhpcy5fdmFsaWRhdGUoZW50cnksIHByb3BlcnRpZXMsIG93blByb3BlcnR5TmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtuYXRpdmVTaGFkb3d9IGZyb20gJy4vc3R5bGUtc2V0dGluZ3MuanMnO1xuaW1wb3J0IFN0eWxlVHJhbnNmb3JtZXIgZnJvbSAnLi9zdHlsZS10cmFuc2Zvcm1lci5qcyc7XG5pbXBvcnQge2dldElzRXh0ZW5kcywgZWxlbWVudEhhc0J1aWx0Q3NzLCB3cmFwfSBmcm9tICcuL3N0eWxlLXV0aWwuanMnO1xuXG5leHBvcnQgbGV0IGZsdXNoID0gZnVuY3Rpb24oKSB7fTtcblxuLyoqXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENsYXNzZXMoZWxlbWVudCkge1xuICBpZiAoZWxlbWVudC5jbGFzc0xpc3QgJiYgZWxlbWVudC5jbGFzc0xpc3QudmFsdWUpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gTk9URTogY2xhc3NOYW1lIGlzIHBhdGNoZWQgdG8gcmVtb3ZlIHNjb3BpbmcgY2xhc3NlcyBpbiBTaGFkeURPTVxuICAgIC8vIHVzZSBnZXRBdHRyaWJ1dGUoJ2NsYXNzJykgaW5zdGVhZCwgd2hpY2ggaXMgdW5wYXRjaGVkXG4gICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdjbGFzcycpIHx8ICcnO1xuICB9XG59XG5cbmNvbnN0IHNjb3BlUmVnRXhwID0gbmV3IFJlZ0V4cChgJHtTdHlsZVRyYW5zZm9ybWVyLlNDT1BFX05BTUV9XFxcXHMqKFteXFxcXHNdKilgKTtcblxuLyoqXG4gKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRDdXJyZW50U2NvcGUoZWxlbWVudCkge1xuICBjb25zdCBtYXRjaCA9IGdldENsYXNzZXMoZWxlbWVudCkubWF0Y2goc2NvcGVSZWdFeHApO1xuICBpZiAobWF0Y2gpIHtcbiAgICByZXR1cm4gbWF0Y2hbMV07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3duZXJTY29wZShub2RlKSB7XG4gIGNvbnN0IG93bmVyUm9vdCA9IHdyYXAobm9kZSkuZ2V0Um9vdE5vZGUoKTtcbiAgaWYgKG93bmVyUm9vdCA9PT0gbm9kZSB8fCBvd25lclJvb3QgPT09IG5vZGUub3duZXJEb2N1bWVudCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuICBjb25zdCBob3N0ID0gLyoqIEB0eXBlIHshU2hhZG93Um9vdH0gKi8ob3duZXJSb290KS5ob3N0O1xuICBpZiAoIWhvc3QpIHtcbiAgICAvLyB0aGlzIG1heSBhY3R1YWxseSBiZSBhIGRvY3VtZW50IGZyYWdtZW50XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHJldHVybiBnZXRJc0V4dGVuZHMoaG9zdCkuaXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlQ29ycmVjdFNjb3BlKGVsZW1lbnQpIHtcbiAgY29uc3QgY3VycmVudFNjb3BlID0gZ2V0Q3VycmVudFNjb3BlKGVsZW1lbnQpO1xuICBjb25zdCBvd25lclJvb3QgPSB3cmFwKGVsZW1lbnQpLmdldFJvb3ROb2RlKCk7XG4gIGlmIChvd25lclJvb3QgPT09IGVsZW1lbnQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGN1cnJlbnRTY29wZSAmJiBvd25lclJvb3QgPT09IGVsZW1lbnQub3duZXJEb2N1bWVudCkge1xuICAgIC8vIG5vZGUgd2FzIHNjb3BlZCwgYnV0IG5vdyBpcyBpbiBkb2N1bWVudFxuICAgIFN0eWxlVHJhbnNmb3JtZXIuZG9tUmVtb3ZlU2NvcGUoZWxlbWVudCwgY3VycmVudFNjb3BlKTtcbiAgfSBlbHNlIGlmIChvd25lclJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgY29uc3Qgb3duZXJTY29wZSA9IGdldE93bmVyU2NvcGUoZWxlbWVudCk7XG4gICAgaWYgKG93bmVyU2NvcGUgIT09IGN1cnJlbnRTY29wZSkge1xuICAgICAgLy8gbm9kZSB3YXMgc2NvcGVkLCBidXQgbm90IGJ5IGl0cyBjdXJyZW50IG93bmVyXG4gICAgICBTdHlsZVRyYW5zZm9ybWVyLmRvbVJlcGxhY2VTY29wZShlbGVtZW50LCBjdXJyZW50U2NvcGUsIG93bmVyU2NvcGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fCFIVE1MRG9jdW1lbnR9IGVsZW1lbnRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUNvcnJlY3RTdWJ0cmVlU2NvcGluZyhlbGVtZW50KSB7XG4gIC8vIGZpbmQgdW5zY29wZWQgc3VidHJlZSBub2Rlc1xuICBjb25zdCB1bnNjb3BlZE5vZGVzID0gd2luZG93WydTaGFkeURPTSddWyduYXRpdmVNZXRob2RzJ11bJ3F1ZXJ5U2VsZWN0b3JBbGwnXS5jYWxsKFxuICAgIGVsZW1lbnQsIGA6bm90KC4ke1N0eWxlVHJhbnNmb3JtZXIuU0NPUEVfTkFNRX0pYCk7XG5cbiAgZm9yIChsZXQgaiA9IDA7IGogPCB1bnNjb3BlZE5vZGVzLmxlbmd0aDsgaisrKSB7XG4gICAgLy8gaXQncyBwb3NzaWJsZSwgZHVyaW5nIGxhcmdlIGJhdGNoIGluc2VydHMsIHRoYXQgbm9kZXMgdGhhdCBhcmVuJ3RcbiAgICAvLyBzY29wZWQgd2l0aGluIHRoZSBjdXJyZW50IHNjb3BlIHdlcmUgYWRkZWQuXG4gICAgLy8gVG8gbWFrZSBzdXJlIHRoYXQgYW55IHVuc2NvcGVkIG5vZGVzIHRoYXQgd2VyZSBpbnNlcnRlZCBpbiB0aGUgY3VycmVudCBiYXRjaCBhcmUgY29ycmVjdGx5IHN0eWxlZCxcbiAgICAvLyBxdWVyeSBhbGwgdW5zY29wZWQgbm9kZXMgYW5kIGZvcmNlIHRoZWlyIHN0eWxlLXNjb3BlIHRvIGJlIGFwcGxpZWQuXG4gICAgLy8gVGhpcyBjb3VsZCBoYXBwZW4gaWYgYSBzdWItZWxlbWVudCBhcHBlbmRlZCBhbiB1bnNjb3BlZCBub2RlIGluIGl0cyBzaGFkb3dyb290IGFuZCB0aGlzIGZ1bmN0aW9uXG4gICAgLy8gcnVucyBvbiBhIHBhcmVudCBlbGVtZW50IG9mIHRoZSBob3N0IG9mIHRoYXQgdW5zY29wZWQgbm9kZTpcbiAgICAvLyBwYXJlbnQtZWxlbWVudCAtPiBlbGVtZW50IC0+IHVuc2NvcGVkIG5vZGVcbiAgICAvLyBIZXJlIHVuc2NvcGVkIG5vZGUgc2hvdWxkIGhhdmUgdGhlIHN0eWxlLXNjb3BlIGVsZW1lbnQsIG5vdCBwYXJlbnQtZWxlbWVudC5cbiAgICBjb25zdCB1bnNjb3BlZE5vZGUgPSB1bnNjb3BlZE5vZGVzW2pdO1xuICAgIGNvbnN0IHNjb3BlRm9yUHJldmlvdXNseVVuc2NvcGVkTm9kZSA9IGdldE93bmVyU2NvcGUodW5zY29wZWROb2RlKTtcbiAgICBpZiAoc2NvcGVGb3JQcmV2aW91c2x5VW5zY29wZWROb2RlKSB7XG4gICAgICBTdHlsZVRyYW5zZm9ybWVyLmVsZW1lbnQodW5zY29wZWROb2RlLCBzY29wZUZvclByZXZpb3VzbHlVbnNjb3BlZE5vZGUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnRXaXRoQnVpbHRDc3MoZWwpIHtcbiAgaWYgKGVsLmxvY2FsTmFtZSA9PT0gJ3N0eWxlJyB8fCBlbC5sb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICByZXR1cm4gZWxlbWVudEhhc0J1aWx0Q3NzKGVsKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHtBcnJheTxNdXRhdGlvblJlY29yZHxudWxsPnxudWxsfSBteG5zXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZXIobXhucykge1xuICBmb3IgKGxldCB4PTA7IHggPCBteG5zLmxlbmd0aDsgeCsrKSB7XG4gICAgbGV0IG14biA9IG14bnNbeF07XG4gICAgaWYgKG14bi50YXJnZXQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCB8fFxuICAgICAgbXhuLnRhcmdldCA9PT0gZG9jdW1lbnQuaGVhZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGk9MDsgaSA8IG14bi5hZGRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgbiA9IG14bi5hZGRlZE5vZGVzW2ldO1xuICAgICAgaWYgKG4ubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbiA9IC8qKiBAdHlwZSB7SFRNTEVsZW1lbnR9ICovKG4pOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtYXNzaWduXG4gICAgICBsZXQgcm9vdCA9IG4uZ2V0Um9vdE5vZGUoKTtcbiAgICAgIGxldCBjdXJyZW50U2NvcGUgPSBnZXRDdXJyZW50U2NvcGUobik7XG4gICAgICAvLyBub2RlIHdhcyBzY29wZWQsIGJ1dCBub3cgaXMgaW4gZG9jdW1lbnRcbiAgICAgIC8vIElmIHRoaXMgZWxlbWVudCBoYXMgYnVpbHQgY3NzLCB3ZSBtdXN0IG5vdCByZW1vdmUgc2NvcGluZyBhcyB0aGlzIG5vZGVcbiAgICAgIC8vIHdpbGwgYmUgdXNlZCBhcyBhIHRlbXBsYXRlIG9yIHN0eWxlIHdpdGhvdXQgcmUgLSBhcHBseWluZyBzY29waW5nIGFzIGFuIG9wdGltaXphdGlvblxuICAgICAgaWYgKGN1cnJlbnRTY29wZSAmJiByb290ID09PSBuLm93bmVyRG9jdW1lbnQgJiYgIWlzRWxlbWVudFdpdGhCdWlsdENzcyhuKSkge1xuICAgICAgICBTdHlsZVRyYW5zZm9ybWVyLmRvbVJlbW92ZVNjb3BlKG4sIGN1cnJlbnRTY29wZSk7XG4gICAgICB9IGVsc2UgaWYgKHJvb3QgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XG4gICAgICAgIGNvbnN0IG5ld1Njb3BlID0gZ2V0T3duZXJTY29wZShuKTtcbiAgICAgICAgLy8gcmVzY29wZSBjdXJyZW50IG5vZGUgYW5kIHN1YnRyZWUgaWYgbmVjZXNzYXJ5XG4gICAgICAgIGlmIChuZXdTY29wZSAhPT0gY3VycmVudFNjb3BlKSB7XG4gICAgICAgICAgU3R5bGVUcmFuc2Zvcm1lci5kb21SZXBsYWNlU2NvcGUobiwgY3VycmVudFNjb3BlLCBuZXdTY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbWFrZSBzdXJlIGFsbCB0aGUgc3VidHJlZSBlbGVtZW50cyBhcmUgc2NvcGVkIGNvcnJlY3RseVxuICAgICAgICBlbnN1cmVDb3JyZWN0U3VidHJlZVNjb3Bpbmcobik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGlmIG5hdGl2ZSBTaGFkb3cgRE9NIGlzIGJlaW5nIHVzZWQsIG9yIFNoYWR5RE9NIGhhbmRsZXMgZHluYW1pYyBzY29pcGluZywgZG8gbm90IGFjdGl2YXRlIHRoZSBNdXRhdGlvbk9ic2VydmVyXG5pZiAoIW5hdGl2ZVNoYWRvdyAmJiAhKHdpbmRvd1snU2hhZHlET00nXSAmJiB3aW5kb3dbJ1NoYWR5RE9NJ11bJ2hhbmRsZXNEeW5hbWljU2NvcGluZyddKSkge1xuICBsZXQgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihoYW5kbGVyKTtcbiAgbGV0IHN0YXJ0ID0gKG5vZGUpID0+IHtcbiAgICBvYnNlcnZlci5vYnNlcnZlKG5vZGUsIHtjaGlsZExpc3Q6IHRydWUsIHN1YnRyZWU6IHRydWV9KTtcbiAgfVxuICBsZXQgbmF0aXZlQ3VzdG9tRWxlbWVudHMgPSAod2luZG93WydjdXN0b21FbGVtZW50cyddICYmXG4gICAgIXdpbmRvd1snY3VzdG9tRWxlbWVudHMnXVsncG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayddKTtcbiAgLy8gbmVlZCB0byBzdGFydCBpbW1lZGlhdGVseSB3aXRoIG5hdGl2ZSBjdXN0b20gZWxlbWVudHNcbiAgLy8gVE9ETyhkZnJlZWRtKTogd2l0aCBwb2x5ZmlsbGVkIEhUTUxJbXBvcnRzIGFuZCBuYXRpdmUgY3VzdG9tIGVsZW1lbnRzXG4gIC8vIGV4Y2Vzc2l2ZSBtdXRhdGlvbnMgbWF5IGJlIG9ic2VydmVkOyB0aGlzIGNhbiBiZSBvcHRpbWl6ZWQgdmlhIGNvb3BlcmF0aW9uXG4gIC8vIHdpdGggdGhlIEhUTUxJbXBvcnRzIHBvbHlmaWxsLlxuICBpZiAobmF0aXZlQ3VzdG9tRWxlbWVudHMpIHtcbiAgICBzdGFydChkb2N1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGRlbGF5ZWRTdGFydCA9ICgpID0+IHtcbiAgICAgIHN0YXJ0KGRvY3VtZW50LmJvZHkpO1xuICAgIH1cbiAgICAvLyB1c2UgcG9seWZpbGwgdGltaW5nIGlmIGl0J3MgYXZhaWxhYmxlXG4gICAgaWYgKHdpbmRvd1snSFRNTEltcG9ydHMnXSkge1xuICAgICAgd2luZG93WydIVE1MSW1wb3J0cyddWyd3aGVuUmVhZHknXShkZWxheWVkU3RhcnQpO1xuICAgIC8vIG90aGVyd2lzZSBwdXNoIGJleW9uZCBuYXRpdmUgaW1wb3J0cyBiZWluZyByZWFkeVxuICAgIC8vIHdoaWNoIHJlcXVpcmVzIFJBRiArIHJlYWR5c3RhdGUgaW50ZXJhY3RpdmUuXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgICAgIGxldCBsaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZGVsYXllZFN0YXJ0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdyZWFkeXN0YXRlY2hhbmdlJywgbGlzdGVuZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRlbGF5ZWRTdGFydCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBmbHVzaCA9IGZ1bmN0aW9uKCkge1xuICAgIGhhbmRsZXIob2JzZXJ2ZXIudGFrZVJlY29yZHMoKSk7XG4gIH1cbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY29uc3QgeyFPYmplY3Q8c3RyaW5nLCAhSFRNTFRlbXBsYXRlRWxlbWVudD59XG4gKi9cbmNvbnN0IHRlbXBsYXRlTWFwID0ge307XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZU1hcDtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQge1N0eWxlTm9kZX0gZnJvbSAnLi9jc3MtcGFyc2UuanMnOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC12YXJzXG5cbi8qXG4gKiBVdGlsaXRpZXMgZm9yIGhhbmRsaW5nIGludmFsaWRhdGluZyBhcHBseS1zaGltIG1peGlucyBmb3IgYSBnaXZlbiB0ZW1wbGF0ZS5cbiAqXG4gKiBUaGUgaW52YWxpZGF0aW9uIHN0cmF0ZWd5IGludm9sdmVzIGtlZXBpbmcgdHJhY2sgb2YgdGhlIFwiY3VycmVudFwiIHZlcnNpb24gb2YgYSB0ZW1wbGF0ZSdzIG1peGlucywgYW5kIHVwZGF0aW5nIHRoYXQgY291bnQgd2hlbiBhIG1peGluIGlzIGludmFsaWRhdGVkLlxuICogVGhlIHRlbXBsYXRlXG4gKi9cblxuLyoqIEBjb25zdCB7c3RyaW5nfSAqL1xuY29uc3QgQ1VSUkVOVF9WRVJTSU9OID0gJ19hcHBseVNoaW1DdXJyZW50VmVyc2lvbic7XG5cbi8qKiBAY29uc3Qge3N0cmluZ30gKi9cbmNvbnN0IE5FWFRfVkVSU0lPTiA9ICdfYXBwbHlTaGltTmV4dFZlcnNpb24nO1xuXG4vKiogQGNvbnN0IHtzdHJpbmd9ICovXG5jb25zdCBWQUxJREFUSU5HX1ZFUlNJT04gPSAnX2FwcGx5U2hpbVZhbGlkYXRpbmdWZXJzaW9uJztcblxuLyoqXG4gKiBAY29uc3Qge1Byb21pc2U8dm9pZD59XG4gKi9cbmNvbnN0IHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGUoZWxlbWVudE5hbWUpe1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgdG8gbWFyayBhIHRlbXBsYXRlIGludmFsaWRcbiAqIGFuZCBzaWduYWwgdGhhdCB0aGUgc3R5bGUgaW5zaWRlIG11c3QgYmUgcmVnZW5lcmF0ZWQuXG4gKlxuICogVXNlIGBzdGFydFZhbGlkYXRpbmdUZW1wbGF0ZWAgdG8gYmVnaW4gYW4gYXN5bmNocm9ub3VzIHZhbGlkYXRpb24gY3ljbGUuXG4gKiBEdXJpbmcgdGhhdCBjeWNsZSwgY2FsbCBgdGVtcGxhdGVJc1ZhbGlkYXRpbmdgIHRvIHNlZSBpZiB0aGUgdGVtcGxhdGUgbXVzdFxuICogYmUgcmV2YWxpZGF0ZWRcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGludmFsaWRhdGVUZW1wbGF0ZSh0ZW1wbGF0ZSkge1xuICAvLyBkZWZhdWx0IHRoZSBjdXJyZW50IHZlcnNpb24gdG8gMFxuICB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID0gdGVtcGxhdGVbQ1VSUkVOVF9WRVJTSU9OXSB8fCAwO1xuICAvLyBlbnN1cmUgdGhlIFwidmFsaWRhdGluZyBmb3JcIiBmbGFnIGV4aXN0c1xuICB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID0gdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSB8fCAwO1xuICAvLyBpbmNyZW1lbnQgdGhlIG5leHQgdmVyc2lvblxuICB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dID0gKHRlbXBsYXRlW05FWFRfVkVSU0lPTl0gfHwgMCkgKyAxO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWQoZWxlbWVudE5hbWUpIHtcbiAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICBpZiAodGVtcGxhdGUpIHtcbiAgICByZXR1cm4gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge0hUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSB7XG4gIHJldHVybiB0ZW1wbGF0ZVtDVVJSRU5UX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRhdGluZyhlbGVtZW50TmFtZSkge1xuICBsZXQgdGVtcGxhdGUgPSB0ZW1wbGF0ZU1hcFtlbGVtZW50TmFtZV07XG4gIGlmICh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiB0ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgdGVtcGxhdGUgaXMgY3VycmVudGx5IGludmFsaWQgYW5kIGBzdGFydFZhbGlkYXRpbmdgIGhhcyBiZWVuIGNhbGxlZCBzaW5jZSB0aGUgbGFzdCBpbnZhbGlkYXRpb24uXG4gKiBJZiBmYWxzZSwgdGhlIHRlbXBsYXRlIG11c3QgYmUgdmFsaWRhdGVkLlxuICogQHBhcmFtIHtIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRlbXBsYXRlSXNWYWxpZGF0aW5nKHRlbXBsYXRlKSB7XG4gIHJldHVybiAhdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSAmJiB0ZW1wbGF0ZVtWQUxJREFUSU5HX1ZFUlNJT05dID09PSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xufVxuXG4vKipcbiAqIHRoZSB0ZW1wbGF0ZSBpcyBtYXJrZWQgYXMgYHZhbGlkYXRpbmdgIGZvciBvbmUgbWljcm90YXNrIHNvIHRoYXQgYWxsIGluc3RhbmNlc1xuICogZm91bmQgaW4gdGhlIHRyZWUgY3Jhd2wgb2YgYGFwcGx5U3R5bGVgIHdpbGwgdXBkYXRlIHRoZW1zZWx2ZXMsXG4gKiBidXQgdGhlIHRlbXBsYXRlIHdpbGwgb25seSBiZSB1cGRhdGVkIG9uY2UuXG4gKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnRWYWxpZGF0aW5nKGVsZW1lbnROYW1lKSB7XG4gIGxldCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXTtcbiAgc3RhcnRWYWxpZGF0aW5nVGVtcGxhdGUodGVtcGxhdGUpO1xufVxuXG4vKipcbiAqIEJlZ2luIGFuIGFzeW5jaHJvbm91cyBpbnZhbGlkYXRpb24gY3ljbGUuXG4gKiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYWZ0ZXIgZXZlcnkgdmFsaWRhdGlvbiBvZiBhIHRlbXBsYXRlXG4gKlxuICogQWZ0ZXIgb25lIG1pY3JvdGFzaywgdGhlIHRlbXBsYXRlIHdpbGwgYmUgbWFya2VkIGFzIHZhbGlkIHVudGlsIHRoZSBuZXh0IGNhbGwgdG8gYGludmFsaWRhdGVUZW1wbGF0ZWBcbiAqIEBwYXJhbSB7SFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKSB7XG4gIC8vIHJlbWVtYmVyIHRoYXQgdGhlIGN1cnJlbnQgXCJuZXh0IHZlcnNpb25cIiBpcyB0aGUgcmVhc29uIGZvciB0aGlzIHZhbGlkYXRpb24gY3ljbGVcbiAgdGVtcGxhdGVbVkFMSURBVElOR19WRVJTSU9OXSA9IHRlbXBsYXRlW05FWFRfVkVSU0lPTl07XG4gIC8vIGhvd2V2ZXIsIHRoZXJlIG9ubHkgbmVlZHMgdG8gYmUgb25lIGFzeW5jIHRhc2sgdG8gY2xlYXIgdGhlIGNvdW50ZXJzXG4gIGlmICghdGVtcGxhdGUuX3ZhbGlkYXRpbmcpIHtcbiAgICB0ZW1wbGF0ZS5fdmFsaWRhdGluZyA9IHRydWU7XG4gICAgcHJvbWlzZS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgLy8gc3luYyB0aGUgY3VycmVudCB2ZXJzaW9uIHRvIGxldCBmdXR1cmUgaW52YWxpZGF0aW9ucyBjYXVzZSBhIHJlZnJlc2ggY3ljbGVcbiAgICAgIHRlbXBsYXRlW0NVUlJFTlRfVkVSU0lPTl0gPSB0ZW1wbGF0ZVtORVhUX1ZFUlNJT05dO1xuICAgICAgdGVtcGxhdGUuX3ZhbGlkYXRpbmcgPSBmYWxzZTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbGVtZW50c0FyZUludmFsaWQoKSB7XG4gIGZvciAobGV0IGVsZW1lbnROYW1lIGluIHRlbXBsYXRlTWFwKSB7XG4gICAgbGV0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbZWxlbWVudE5hbWVdO1xuICAgIGlmICghdGVtcGxhdGVJc1ZhbGlkKHRlbXBsYXRlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHsgTUlYSU5fTUFUQ0gsIFZBUl9BU1NJR04gfSBmcm9tICcuL2NvbW1vbi1yZWdleC5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU5hdGl2ZVByb3BlcnRpZXMoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAvLyByZW1vdmUgcHJldmlvdXMgcHJvcGVydGllc1xuICBmb3IgKGxldCBwIGluIHByb3BlcnRpZXMpIHtcbiAgICAvLyBOT1RFOiBmb3IgYmMgd2l0aCBzaGltLCBkb24ndCBhcHBseSBudWxsIHZhbHVlcy5cbiAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudC5zdHlsZS5zZXRQcm9wZXJ0eShwLCBwcm9wZXJ0aWVzW3BdKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIC8qKlxuICAgKiBAY29uc3Qge3N0cmluZ31cbiAgICovXG4gIGNvbnN0IHZhbHVlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gIGlmICghdmFsdWUpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgfVxufVxuXG4vKipcbiAqIHJldHVybiB0cnVlIGlmIGBjc3NUZXh0YCBjb250YWlucyBhIG1peGluIGRlZmluaXRpb24gb3IgY29uc3VtcHRpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBjc3NUZXh0XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGV0ZWN0TWl4aW4oY3NzVGV4dCkge1xuICBjb25zdCBoYXMgPSBNSVhJTl9NQVRDSC50ZXN0KGNzc1RleHQpIHx8IFZBUl9BU1NJR04udGVzdChjc3NUZXh0KTtcbiAgLy8gcmVzZXQgc3RhdGUgb2YgdGhlIHJlZ2V4ZXNcbiAgTUlYSU5fTUFUQ0gubGFzdEluZGV4ID0gMDtcbiAgVkFSX0FTU0lHTi5sYXN0SW5kZXggPSAwO1xuICByZXR1cm4gaGFzO1xufVxuIiwiLyoqXG5AbGljZW5zZVxuQ29weXJpZ2h0IChjKSAyMDE3IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cblRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcblRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbkNvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG5zdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKiogQHR5cGUge1Byb21pc2U8dm9pZD59ICovXG5sZXQgcmVhZHlQcm9taXNlID0gbnVsbDtcblxuLyoqIEB0eXBlIHs/ZnVuY3Rpb24oP2Z1bmN0aW9uKCkpfSAqL1xubGV0IHdoZW5SZWFkeSA9IHdpbmRvd1snSFRNTEltcG9ydHMnXSAmJiB3aW5kb3dbJ0hUTUxJbXBvcnRzJ11bJ3doZW5SZWFkeSddIHx8IG51bGw7XG5cbi8qKiBAdHlwZSB7ZnVuY3Rpb24oKX0gKi9cbmxldCByZXNvbHZlRm47XG5cbi8qKlxuICogQHBhcmFtIHs/ZnVuY3Rpb24oKX0gY2FsbGJhY2tcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZG9jdW1lbnRXYWl0KGNhbGxiYWNrKSB7XG4gIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICBpZiAod2hlblJlYWR5KSB7XG4gICAgICB3aGVuUmVhZHkoY2FsbGJhY2spXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcmVhZHlQcm9taXNlKSB7XG4gICAgICAgIHJlYWR5UHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7cmVzb2x2ZUZuID0gcmVzb2x2ZX0pO1xuICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIHJlc29sdmVGbigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3JlYWR5c3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgICAgICByZXNvbHZlRm4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVhZHlQcm9taXNlLnRoZW4oZnVuY3Rpb24oKXsgY2FsbGJhY2sgJiYgY2FsbGJhY2soKTsgfSk7XG4gICAgfVxuICB9KTtcbn1cbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IGRvY3VtZW50V2FpdCBmcm9tICcuL2RvY3VtZW50LXdhaXQuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHtIVE1MU3R5bGVFbGVtZW50IHwge2dldFN0eWxlOiBmdW5jdGlvbigpOkhUTUxTdHlsZUVsZW1lbnR9fVxuICovXG5leHBvcnQgbGV0IEN1c3RvbVN0eWxlUHJvdmlkZXI7XG5cbmNvbnN0IFNFRU5fTUFSS0VSID0gJ19fc2VlbkJ5U2hhZHlDU1MnO1xuY29uc3QgQ0FDSEVEX1NUWUxFID0gJ19fc2hhZHlDU1NDYWNoZWRTdHlsZSc7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbmxldCB0cmFuc2Zvcm1GbiA9IG51bGw7XG5cbi8qKiBAdHlwZSB7P2Z1bmN0aW9uKCl9ICovXG5sZXQgdmFsaWRhdGVGbiA9IG51bGw7XG5cbi8qKlxuVGhpcyBpbnRlcmZhY2UgaXMgcHJvdmlkZWQgdG8gYWRkIGRvY3VtZW50LWxldmVsIDxzdHlsZT4gZWxlbWVudHMgdG8gU2hhZHlDU1MgZm9yIHByb2Nlc3NpbmcuXG5UaGVzZSBzdHlsZXMgbXVzdCBiZSBwcm9jZXNzZWQgYnkgU2hhZHlDU1MgdG8gc2ltdWxhdGUgU2hhZG93Um9vdCB1cHBlci1ib3VuZCBlbmNhcHN1bGF0aW9uIGZyb20gb3V0c2lkZSBzdHlsZXNcbkluIGFkZGl0aW9uLCB0aGVzZSBzdHlsZXMgbWF5IGFsc28gbmVlZCB0byBiZSBwcm9jZXNzZWQgZm9yIEBhcHBseSBydWxlcyBhbmQgQ1NTIEN1c3RvbSBQcm9wZXJ0aWVzXG5cblRvIGFkZCBkb2N1bWVudC1sZXZlbCBzdHlsZXMgdG8gU2hhZHlDU1MsIG9uZSBjYW4gY2FsbCBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZShzdHlsZUVsZW1lbnQpYCBvciBgU2hhZHlDU1MuYWRkRG9jdW1lbnRTdHlsZSh7Z2V0U3R5bGU6ICgpID0+IHN0eWxlRWxlbWVudH0pYFxuXG5JbiBhZGRpdGlvbiwgaWYgdGhlIHByb2Nlc3MgdXNlZCB0byBkaXNjb3ZlciBkb2N1bWVudC1sZXZlbCBzdHlsZXMgY2FuIGJlIHN5bmNocm9ub3VzbHkgZmx1c2hlZCwgb25lIHNob3VsZCBzZXQgYFNoYWR5Q1NTLmRvY3VtZW50U3R5bGVGbHVzaGAuXG5UaGlzIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIHdoZW4gY2FsY3VsYXRpbmcgc3R5bGVzLlxuXG5BbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBkb2N1bWVudC1sZXZlbCBzdHlsaW5nIGFwaSBjYW4gYmUgZm91bmQgaW4gYGV4YW1wbGVzL2RvY3VtZW50LXN0eWxlLWxpYi5qc2BcblxuQHVucmVzdHJpY3RlZFxuKi9cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEN1c3RvbVN0eWxlSW50ZXJmYWNlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+fSAqL1xuICAgIHRoaXNbJ2N1c3RvbVN0eWxlcyddID0gW107XG4gICAgdGhpc1snZW5xdWV1ZWQnXSA9IGZhbHNlO1xuICAgIC8vIE5PVEUoZGZyZWVkbSk6IHVzZSBxdW90ZXMgaGVyZSB0byBwcmV2ZW50IGNsb3N1cmUgaW5saW5pbmcgdG8gYGZ1bmN0aW9uKCl7fWA7XG4gICAgZG9jdW1lbnRXYWl0KCgpID0+IHtcbiAgICAgIGlmICh3aW5kb3dbJ1NoYWR5Q1NTJ11bJ2ZsdXNoQ3VzdG9tU3R5bGVzJ10pIHtcbiAgICAgICAgd2luZG93WydTaGFkeUNTUyddWydmbHVzaEN1c3RvbVN0eWxlcyddKCk7XG4gICAgICB9XG4gICAgfSlcbiAgfVxuICAvKipcbiAgICogUXVldWUgYSB2YWxpZGF0aW9uIGZvciBuZXcgY3VzdG9tIHN0eWxlcyB0byBiYXRjaCBzdHlsZSByZWNhbGN1bGF0aW9uc1xuICAgKi9cbiAgZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpIHtcbiAgICBpZiAodGhpc1snZW5xdWV1ZWQnXSB8fCAhdmFsaWRhdGVGbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzWydlbnF1ZXVlZCddID0gdHJ1ZTtcbiAgICBkb2N1bWVudFdhaXQodmFsaWRhdGVGbik7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxTdHlsZUVsZW1lbnR9IHN0eWxlXG4gICAqL1xuICBhZGRDdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGlmICghc3R5bGVbU0VFTl9NQVJLRVJdKSB7XG4gICAgICBzdHlsZVtTRUVOX01BUktFUl0gPSB0cnVlO1xuICAgICAgdGhpc1snY3VzdG9tU3R5bGVzJ10ucHVzaChzdHlsZSk7XG4gICAgICB0aGlzLmVucXVldWVEb2N1bWVudFZhbGlkYXRpb24oKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUN1c3RvbVN0eWxlUHJvdmlkZXJ9IGN1c3RvbVN0eWxlXG4gICAqIEByZXR1cm4ge0hUTUxTdHlsZUVsZW1lbnR9XG4gICAqL1xuICBnZXRTdHlsZUZvckN1c3RvbVN0eWxlKGN1c3RvbVN0eWxlKSB7XG4gICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgIHJldHVybiBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdO1xuICAgIH1cbiAgICBsZXQgc3R5bGU7XG4gICAgaWYgKGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKSB7XG4gICAgICBzdHlsZSA9IGN1c3RvbVN0eWxlWydnZXRTdHlsZSddKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlID0gY3VzdG9tU3R5bGU7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICAvKipcbiAgICogQHJldHVybiB7IUFycmF5PCFDdXN0b21TdHlsZVByb3ZpZGVyPn1cbiAgICovXG4gIHByb2Nlc3NTdHlsZXMoKSB7XG4gICAgY29uc3QgY3MgPSB0aGlzWydjdXN0b21TdHlsZXMnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjdXN0b21TdHlsZSA9IGNzW2ldO1xuICAgICAgaWYgKGN1c3RvbVN0eWxlW0NBQ0hFRF9TVFlMRV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHlsZSA9IHRoaXMuZ2V0U3R5bGVGb3JDdXN0b21TdHlsZShjdXN0b21TdHlsZSk7XG4gICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgLy8gSFRNTEltcG9ydHMgcG9seWZpbGwgbWF5IGhhdmUgY2xvbmVkIHRoZSBzdHlsZSBpbnRvIHRoZSBtYWluIGRvY3VtZW50LFxuICAgICAgICAvLyB3aGljaCBpcyByZWZlcmVuY2VkIHdpdGggX19hcHBsaWVkRWxlbWVudC5cbiAgICAgICAgY29uc3Qgc3R5bGVUb1RyYW5zZm9ybSA9IC8qKiBAdHlwZSB7IUhUTUxTdHlsZUVsZW1lbnR9ICovKHN0eWxlWydfX2FwcGxpZWRFbGVtZW50J10gfHwgc3R5bGUpO1xuICAgICAgICBpZiAodHJhbnNmb3JtRm4pIHtcbiAgICAgICAgICB0cmFuc2Zvcm1GbihzdHlsZVRvVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICBjdXN0b21TdHlsZVtDQUNIRURfU1RZTEVdID0gc3R5bGVUb1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNzO1xuICB9XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduICovXG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2FkZEN1c3RvbVN0eWxlJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUuYWRkQ3VzdG9tU3R5bGU7XG5DdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGVbJ2dldFN0eWxlRm9yQ3VzdG9tU3R5bGUnXSA9IEN1c3RvbVN0eWxlSW50ZXJmYWNlLnByb3RvdHlwZS5nZXRTdHlsZUZvckN1c3RvbVN0eWxlO1xuQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlWydwcm9jZXNzU3R5bGVzJ10gPSBDdXN0b21TdHlsZUludGVyZmFjZS5wcm90b3R5cGUucHJvY2Vzc1N0eWxlcztcbi8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gKi9cblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ3VzdG9tU3R5bGVJbnRlcmZhY2UucHJvdG90eXBlLCB7XG4gICd0cmFuc2Zvcm1DYWxsYmFjayc6IHtcbiAgICAvKiogQHJldHVybiB7P2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdHJhbnNmb3JtRm47XG4gICAgfSxcbiAgICAvKiogQHBhcmFtIHs/ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSBmbiAqL1xuICAgIHNldChmbikge1xuICAgICAgdHJhbnNmb3JtRm4gPSBmbjtcbiAgICB9XG4gIH0sXG4gICd2YWxpZGF0ZUNhbGxiYWNrJzoge1xuICAgIC8qKiBAcmV0dXJuIHs/ZnVuY3Rpb24oKX0gKi9cbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdmFsaWRhdGVGbjtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7P2Z1bmN0aW9uKCl9IGZuXG4gICAgICogQHRoaXMge0N1c3RvbVN0eWxlSW50ZXJmYWNlfVxuICAgICAqL1xuICAgIHNldChmbikge1xuICAgICAgbGV0IG5lZWRzRW5xdWV1ZSA9IGZhbHNlO1xuICAgICAgaWYgKCF2YWxpZGF0ZUZuKSB7XG4gICAgICAgIG5lZWRzRW5xdWV1ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB2YWxpZGF0ZUZuID0gZm47XG4gICAgICBpZiAobmVlZHNFbnF1ZXVlKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZURvY3VtZW50VmFsaWRhdGlvbigpO1xuICAgICAgfVxuICAgIH0sXG4gIH1cbn0pXG5cbi8qKiBAdHlwZWRlZiB7e1xuICogY3VzdG9tU3R5bGVzOiAhQXJyYXk8IUN1c3RvbVN0eWxlUHJvdmlkZXI+LFxuICogYWRkQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKSxcbiAqIGdldFN0eWxlRm9yQ3VzdG9tU3R5bGU6IGZ1bmN0aW9uKCFDdXN0b21TdHlsZVByb3ZpZGVyKTogSFRNTFN0eWxlRWxlbWVudCxcbiAqIGZpbmRTdHlsZXM6IGZ1bmN0aW9uKCksXG4gKiB0cmFuc2Zvcm1DYWxsYmFjazogP2Z1bmN0aW9uKCFIVE1MU3R5bGVFbGVtZW50KSxcbiAqIHZhbGlkYXRlQ2FsbGJhY2s6ID9mdW5jdGlvbigpXG4gKiB9fVxuICovXG5leHBvcnQgY29uc3QgQ3VzdG9tU3R5bGVJbnRlcmZhY2VJbnRlcmZhY2UgPSB7fTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IHtwYXJzZSwgU3R5bGVOb2RlfSBmcm9tICcuL2Nzcy1wYXJzZS5qcyc7XG5pbXBvcnQge25hdGl2ZVNoYWRvdywgbmF0aXZlQ3NzVmFyaWFibGVzLCBkaXNhYmxlUnVudGltZX0gZnJvbSAnLi9zdHlsZS1zZXR0aW5ncy5qcyc7XG5pbXBvcnQgU3R5bGVUcmFuc2Zvcm1lciBmcm9tICcuL3N0eWxlLXRyYW5zZm9ybWVyLmpzJztcbmltcG9ydCAqIGFzIFN0eWxlVXRpbCBmcm9tICcuL3N0eWxlLXV0aWwuanMnO1xuaW1wb3J0IFN0eWxlUHJvcGVydGllcyBmcm9tICcuL3N0eWxlLXByb3BlcnRpZXMuanMnO1xuaW1wb3J0IHtlbnN1cmVTdHlsZVBsYWNlaG9sZGVyLCBnZXRTdHlsZVBsYWNlaG9sZGVyfSBmcm9tICcuL3N0eWxlLXBsYWNlaG9sZGVyLmpzJztcbmltcG9ydCBTdHlsZUluZm8gZnJvbSAnLi9zdHlsZS1pbmZvLmpzJztcbmltcG9ydCBTdHlsZUNhY2hlIGZyb20gJy4vc3R5bGUtY2FjaGUuanMnO1xuaW1wb3J0IHtmbHVzaCBhcyB3YXRjaGVyRmx1c2gsIGdldE93bmVyU2NvcGUsIGdldEN1cnJlbnRTY29wZX0gZnJvbSAnLi9kb2N1bWVudC13YXRjaGVyLmpzJztcbmltcG9ydCB0ZW1wbGF0ZU1hcCBmcm9tICcuL3RlbXBsYXRlLW1hcC5qcyc7XG5pbXBvcnQgKiBhcyBBcHBseVNoaW1VdGlscyBmcm9tICcuL2FwcGx5LXNoaW0tdXRpbHMuanMnO1xuaW1wb3J0IHt1cGRhdGVOYXRpdmVQcm9wZXJ0aWVzLCBkZXRlY3RNaXhpbn0gZnJvbSAnLi9jb21tb24tdXRpbHMuanMnO1xuaW1wb3J0IHtDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gZnJvbSAnLi9jdXN0b20tc3R5bGUtaW50ZXJmYWNlLmpzJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtdmFyc1xuXG4vKiogQHR5cGUgeyFPYmplY3Q8c3RyaW5nLCBzdHJpbmc+fSAqL1xuY29uc3QgYWRvcHRlZENzc1RleHRNYXAgPSB7fTtcblxuLyoqXG4gKiBAY29uc3Qge1N0eWxlQ2FjaGV9XG4gKi9cbmNvbnN0IHN0eWxlQ2FjaGUgPSBuZXcgU3R5bGVDYWNoZSgpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTY29waW5nU2hpbSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX3Njb3BlQ291bnRlciA9IHt9O1xuICAgIHRoaXMuX2RvY3VtZW50T3duZXIgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KTtcbiAgICBsZXQgYXN0ID0gbmV3IFN0eWxlTm9kZSgpO1xuICAgIGFzdFsncnVsZXMnXSA9IFtdO1xuICAgIHRoaXMuX2RvY3VtZW50T3duZXJTdHlsZUluZm8gPSBTdHlsZUluZm8uc2V0KHRoaXMuX2RvY3VtZW50T3duZXIsIG5ldyBTdHlsZUluZm8oYXN0KSk7XG4gICAgdGhpcy5fZWxlbWVudHNIYXZlQXBwbGllZCA9IGZhbHNlO1xuICAgIC8qKiBAdHlwZSB7P09iamVjdH0gKi9cbiAgICB0aGlzLl9hcHBseVNoaW0gPSBudWxsO1xuICAgIC8qKiBAdHlwZSB7P0N1c3RvbVN0eWxlSW50ZXJmYWNlSW50ZXJmYWNlfSAqL1xuICAgIHRoaXMuX2N1c3RvbVN0eWxlSW50ZXJmYWNlID0gbnVsbDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICB3YXRjaGVyRmx1c2goKTtcbiAgfVxuICBfZ2VuZXJhdGVTY29wZVNlbGVjdG9yKG5hbWUpIHtcbiAgICBsZXQgaWQgPSB0aGlzLl9zY29wZUNvdW50ZXJbbmFtZV0gPSAodGhpcy5fc2NvcGVDb3VudGVyW25hbWVdIHx8IDApICsgMTtcbiAgICByZXR1cm4gYCR7bmFtZX0tJHtpZH1gO1xuICB9XG4gIGdldFN0eWxlQXN0KHN0eWxlKSB7XG4gICAgcmV0dXJuIFN0eWxlVXRpbC5ydWxlc0ZvclN0eWxlKHN0eWxlKTtcbiAgfVxuICBzdHlsZUFzdFRvU3RyaW5nKGFzdCkge1xuICAgIHJldHVybiBTdHlsZVV0aWwudG9Dc3NUZXh0KGFzdCk7XG4gIH1cbiAgX2dhdGhlclN0eWxlcyh0ZW1wbGF0ZSkge1xuICAgIHJldHVybiBTdHlsZVV0aWwuZ2F0aGVyU3R5bGVUZXh0KHRlbXBsYXRlLmNvbnRlbnQpO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlIHRoZSBzdHlsaW5nIGFuZCB0ZW1wbGF0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgdHlwZVxuICAgKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmc9fSB0eXBlRXh0ZW5zaW9uXG4gICAqL1xuICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCB0eXBlRXh0ZW5zaW9uKSB7XG4gICAgdGhpcy5wcmVwYXJlVGVtcGxhdGVEb20odGVtcGxhdGUsIGVsZW1lbnROYW1lKTtcbiAgICB0aGlzLnByZXBhcmVUZW1wbGF0ZVN0eWxlcyh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIHR5cGVFeHRlbnNpb24pO1xuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlIHN0eWxpbmcgZm9yIHRoZSBnaXZlbiBlbGVtZW50IHR5cGVcbiAgICogQHBhcmFtIHshSFRNTFRlbXBsYXRlRWxlbWVudH0gdGVtcGxhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVsZW1lbnROYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gdHlwZUV4dGVuc2lvblxuICAgKi9cbiAgcHJlcGFyZVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgdHlwZUV4dGVuc2lvbikge1xuICAgIGlmICh0ZW1wbGF0ZS5fcHJlcGFyZWQgfHwgZGlzYWJsZVJ1bnRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gc3R5bGUgcGxhY2Vob2xkZXJzIGFyZSBvbmx5IHVzZWQgd2hlbiBTaGFkeURPTSBpcyBhY3RpdmVcbiAgICBpZiAoIW5hdGl2ZVNoYWRvdykge1xuICAgICAgZW5zdXJlU3R5bGVQbGFjZWhvbGRlcihlbGVtZW50TmFtZSk7XG4gICAgfVxuICAgIHRlbXBsYXRlLl9wcmVwYXJlZCA9IHRydWU7XG4gICAgdGVtcGxhdGUubmFtZSA9IGVsZW1lbnROYW1lO1xuICAgIHRlbXBsYXRlLmV4dGVuZHMgPSB0eXBlRXh0ZW5zaW9uO1xuICAgIHRlbXBsYXRlTWFwW2VsZW1lbnROYW1lXSA9IHRlbXBsYXRlO1xuICAgIGxldCBjc3NCdWlsZCA9IFN0eWxlVXRpbC5nZXRDc3NCdWlsZCh0ZW1wbGF0ZSk7XG4gICAgY29uc3Qgb3B0aW1hbEJ1aWxkID0gU3R5bGVVdGlsLmlzT3B0aW1hbENzc0J1aWxkKGNzc0J1aWxkKTtcbiAgICBsZXQgaW5mbyA9IHtcbiAgICAgIGlzOiBlbGVtZW50TmFtZSxcbiAgICAgIGV4dGVuZHM6IHR5cGVFeHRlbnNpb24sXG4gICAgfTtcbiAgICBsZXQgY3NzVGV4dCA9IHRoaXMuX2dhdGhlclN0eWxlcyh0ZW1wbGF0ZSkgKyAoYWRvcHRlZENzc1RleHRNYXBbZWxlbWVudE5hbWVdIHx8ICcnKTtcbiAgICAvLyBjaGVjayBpZiB0aGUgc3R5bGluZyBoYXMgbWl4aW4gZGVmaW5pdGlvbnMgb3IgdXNlc1xuICAgIHRoaXMuX2Vuc3VyZSgpO1xuICAgIGlmICghb3B0aW1hbEJ1aWxkKSB7XG4gICAgICBsZXQgaGFzTWl4aW5zID0gIWNzc0J1aWxkICYmIGRldGVjdE1peGluKGNzc1RleHQpO1xuICAgICAgbGV0IGFzdCA9IHBhcnNlKGNzc1RleHQpO1xuICAgICAgLy8gb25seSBydW4gdGhlIGFwcGx5c2hpbSB0cmFuc2Zvcm1zIGlmIHRoZXJlIGlzIGEgbWl4aW4gaW52b2x2ZWRcbiAgICAgIGlmIChoYXNNaXhpbnMgJiYgbmF0aXZlQ3NzVmFyaWFibGVzICYmIHRoaXMuX2FwcGx5U2hpbSkge1xuICAgICAgICB0aGlzLl9hcHBseVNoaW1bJ3RyYW5zZm9ybVJ1bGVzJ10oYXN0LCBlbGVtZW50TmFtZSk7XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZVsnX3N0eWxlQXN0J10gPSBhc3Q7XG4gICAgfVxuICAgIGxldCBvd25Qcm9wZXJ0eU5hbWVzID0gW107XG4gICAgaWYgKCFuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIG93blByb3BlcnR5TmFtZXMgPSBTdHlsZVByb3BlcnRpZXMuZGVjb3JhdGVTdHlsZXModGVtcGxhdGVbJ19zdHlsZUFzdCddKTtcbiAgICB9XG4gICAgaWYgKCFvd25Qcm9wZXJ0eU5hbWVzLmxlbmd0aCB8fCBuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIGxldCByb290ID0gbmF0aXZlU2hhZG93ID8gdGVtcGxhdGUuY29udGVudCA6IG51bGw7XG4gICAgICBsZXQgcGxhY2Vob2xkZXIgPSBnZXRTdHlsZVBsYWNlaG9sZGVyKGVsZW1lbnROYW1lKTtcbiAgICAgIGxldCBzdHlsZSA9IHRoaXMuX2dlbmVyYXRlU3RhdGljU3R5bGUoaW5mbywgdGVtcGxhdGVbJ19zdHlsZUFzdCddLCByb290LCBwbGFjZWhvbGRlciwgY3NzQnVpbGQsIG9wdGltYWxCdWlsZCA/IGNzc1RleHQgOiAnJyk7XG4gICAgICB0ZW1wbGF0ZS5fc3R5bGUgPSBzdHlsZTtcbiAgICB9XG4gICAgdGVtcGxhdGUuX293blByb3BlcnR5TmFtZXMgPSBvd25Qcm9wZXJ0eU5hbWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUFycmF5PHN0cmluZz59IGNzc1RleHRBcnJheVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHByZXBhcmVBZG9wdGVkQ3NzVGV4dChjc3NUZXh0QXJyYXksIGVsZW1lbnROYW1lKSB7XG4gICAgYWRvcHRlZENzc1RleHRNYXBbZWxlbWVudE5hbWVdID0gY3NzVGV4dEFycmF5LmpvaW4oJyAnKTtcbiAgfVxuICAvKipcbiAgICogUHJlcGFyZSB0ZW1wbGF0ZSBmb3IgdGhlIGdpdmVuIGVsZW1lbnQgdHlwZVxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICovXG4gIHByZXBhcmVUZW1wbGF0ZURvbSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpIHtcbiAgICBpZiAoZGlzYWJsZVJ1bnRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3NzQnVpbGQgPSBTdHlsZVV0aWwuZ2V0Q3NzQnVpbGQodGVtcGxhdGUpO1xuICAgIGlmICghbmF0aXZlU2hhZG93ICYmIGNzc0J1aWxkICE9PSAnc2hhZHknICYmICF0ZW1wbGF0ZS5fZG9tUHJlcGFyZWQpIHtcbiAgICAgIHRlbXBsYXRlLl9kb21QcmVwYXJlZCA9IHRydWU7XG4gICAgICBTdHlsZVRyYW5zZm9ybWVyLmRvbUFkZFNjb3BlKHRlbXBsYXRlLmNvbnRlbnQsIGVsZW1lbnROYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IXtpczogc3RyaW5nLCBleHRlbmRzOiAoc3RyaW5nfHVuZGVmaW5lZCl9fSBpbmZvXG4gICAqIEBwYXJhbSB7IVN0eWxlTm9kZX0gcnVsZXNcbiAgICogQHBhcmFtIHtEb2N1bWVudEZyYWdtZW50fSBzaGFkb3dyb290XG4gICAqIEBwYXJhbSB7Tm9kZX0gcGxhY2Vob2xkZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNzc0J1aWxkXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gY3NzVGV4dFxuICAgKiBAcmV0dXJuIHs/SFRNTFN0eWxlRWxlbWVudH1cbiAgICovXG4gIF9nZW5lcmF0ZVN0YXRpY1N0eWxlKGluZm8sIHJ1bGVzLCBzaGFkb3dyb290LCBwbGFjZWhvbGRlciwgY3NzQnVpbGQsIGNzc1RleHQpIHtcbiAgICBjc3NUZXh0ID0gU3R5bGVUcmFuc2Zvcm1lci5lbGVtZW50U3R5bGVzKGluZm8sIHJ1bGVzLCBudWxsLCBjc3NCdWlsZCwgY3NzVGV4dCk7XG4gICAgaWYgKGNzc1RleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gU3R5bGVVdGlsLmFwcGx5Q3NzKGNzc1RleHQsIGluZm8uaXMsIHNoYWRvd3Jvb3QsIHBsYWNlaG9sZGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgX3ByZXBhcmVIb3N0KGhvc3QpIHtcbiAgICBjb25zdCB7aXMsIHR5cGVFeHRlbnNpb259ID0gU3R5bGVVdGlsLmdldElzRXh0ZW5kcyhob3N0KTtcbiAgICBjb25zdCBwbGFjZWhvbGRlciA9IGdldFN0eWxlUGxhY2Vob2xkZXIoaXMpO1xuICAgIGNvbnN0IHRlbXBsYXRlID0gdGVtcGxhdGVNYXBbaXNdO1xuICAgIGlmICghdGVtcGxhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYXN0ID0gdGVtcGxhdGVbJ19zdHlsZUFzdCddO1xuICAgIGNvbnN0IG93blN0eWxlUHJvcGVydHlOYW1lcyA9IHRlbXBsYXRlLl9vd25Qcm9wZXJ0eU5hbWVzO1xuICAgIGNvbnN0IGNzc0J1aWxkID0gU3R5bGVVdGlsLmdldENzc0J1aWxkKHRlbXBsYXRlKTtcbiAgICBjb25zdCBzdHlsZUluZm8gPSBuZXcgU3R5bGVJbmZvKFxuICAgICAgYXN0LFxuICAgICAgcGxhY2Vob2xkZXIsXG4gICAgICBvd25TdHlsZVByb3BlcnR5TmFtZXMsXG4gICAgICBpcyxcbiAgICAgIHR5cGVFeHRlbnNpb24sXG4gICAgICBjc3NCdWlsZFxuICAgICk7XG4gICAgU3R5bGVJbmZvLnNldChob3N0LCBzdHlsZUluZm8pO1xuICAgIHJldHVybiBzdHlsZUluZm87XG4gIH1cbiAgX2Vuc3VyZUFwcGx5U2hpbSgpIHtcbiAgICBpZiAodGhpcy5fYXBwbHlTaGltKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmICh3aW5kb3cuU2hhZHlDU1MgJiYgd2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSkge1xuICAgICAgdGhpcy5fYXBwbHlTaGltID0gLyoqIEB0eXBlIHshT2JqZWN0fSAqLyAod2luZG93LlNoYWR5Q1NTLkFwcGx5U2hpbSk7XG4gICAgICB0aGlzLl9hcHBseVNoaW1bJ2ludmFsaWRDYWxsYmFjayddID0gQXBwbHlTaGltVXRpbHMuaW52YWxpZGF0ZTtcbiAgICB9XG4gIH1cbiAgX2Vuc3VyZUN1c3RvbVN0eWxlSW50ZXJmYWNlKCkge1xuICAgIGlmICh0aGlzLl9jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAod2luZG93LlNoYWR5Q1NTICYmIHdpbmRvdy5TaGFkeUNTUy5DdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgdGhpcy5fY3VzdG9tU3R5bGVJbnRlcmZhY2UgPSAvKiogQHR5cGUgeyFDdXN0b21TdHlsZUludGVyZmFjZUludGVyZmFjZX0gKi8od2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlKTtcbiAgICAgIC8qKiBAdHlwZSB7ZnVuY3Rpb24oIUhUTUxTdHlsZUVsZW1lbnQpfSAqL1xuICAgICAgdGhpcy5fY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3RyYW5zZm9ybUNhbGxiYWNrJ10gPSAoc3R5bGUpID0+IHt0aGlzLnRyYW5zZm9ybUN1c3RvbVN0eWxlRm9yRG9jdW1lbnQoc3R5bGUpfTtcbiAgICAgIHRoaXMuX2N1c3RvbVN0eWxlSW50ZXJmYWNlWyd2YWxpZGF0ZUNhbGxiYWNrJ10gPSAoKSA9PiB7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMuX2N1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddIHx8IHRoaXMuX2VsZW1lbnRzSGF2ZUFwcGxpZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICBfZW5zdXJlKCkge1xuICAgIHRoaXMuX2Vuc3VyZUFwcGx5U2hpbSgpO1xuICAgIHRoaXMuX2Vuc3VyZUN1c3RvbVN0eWxlSW50ZXJmYWNlKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZsdXNoIGFuZCBhcHBseSBjdXN0b20gc3R5bGVzIHRvIGRvY3VtZW50XG4gICAqL1xuICBmbHVzaEN1c3RvbVN0eWxlcygpIHtcbiAgICBpZiAoZGlzYWJsZVJ1bnRpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZW5zdXJlKCk7XG4gICAgaWYgKCF0aGlzLl9jdXN0b21TdHlsZUludGVyZmFjZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgY3VzdG9tU3R5bGVzID0gdGhpcy5fY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ3Byb2Nlc3NTdHlsZXMnXSgpO1xuICAgIC8vIGVhcmx5IHJldHVybiBpZiBjdXN0b20tc3R5bGVzIGRvbid0IG5lZWQgdmFsaWRhdGlvblxuICAgIGlmICghdGhpcy5fY3VzdG9tU3R5bGVJbnRlcmZhY2VbJ2VucXVldWVkJ10pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gYmFpbCBpZiBjdXN0b20gc3R5bGVzIGFyZSBidWlsdCBvcHRpbWFsbHlcbiAgICBpZiAoU3R5bGVVdGlsLmlzT3B0aW1hbENzc0J1aWxkKHRoaXMuX2RvY3VtZW50T3duZXJTdHlsZUluZm8uY3NzQnVpbGQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghbmF0aXZlQ3NzVmFyaWFibGVzKSB7XG4gICAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKHRoaXMuX2RvY3VtZW50T3duZXIsIHRoaXMuX2RvY3VtZW50T3duZXJTdHlsZUluZm8pO1xuICAgICAgdGhpcy5fYXBwbHlDdXN0b21TdHlsZXMoY3VzdG9tU3R5bGVzKTtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50c0hhdmVBcHBsaWVkKSB7XG4gICAgICAgIC8vIGlmIGN1c3RvbSBlbGVtZW50cyBoYXZlIHVwZ3JhZGVkIGFuZCB0aGVyZSBhcmUgbm8gbmF0aXZlIGNzcyB2YXJpYWJsZXMsIHdlIG11c3QgcmVjYWxjdWxhdGUgdGhlIHdob2xlIHRyZWVcbiAgICAgICAgdGhpcy5zdHlsZURvY3VtZW50KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghdGhpcy5fZG9jdW1lbnRPd25lclN0eWxlSW5mby5jc3NCdWlsZCkge1xuICAgICAgdGhpcy5fcmV2YWxpZGF0ZUN1c3RvbVN0eWxlQXBwbHlTaGltKGN1c3RvbVN0eWxlcyk7XG4gICAgfVxuICAgIHRoaXMuX2N1c3RvbVN0eWxlSW50ZXJmYWNlWydlbnF1ZXVlZCddID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEFwcGx5IHN0eWxlcyBmb3IgdGhlIGdpdmVuIGVsZW1lbnRcbiAgICpcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGhvc3RcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvdmVycmlkZVByb3BzXG4gICAqL1xuICBzdHlsZUVsZW1lbnQoaG9zdCwgb3ZlcnJpZGVQcm9wcykge1xuICAgIGlmIChkaXNhYmxlUnVudGltZSkge1xuICAgICAgaWYgKG92ZXJyaWRlUHJvcHMpIHtcbiAgICAgICAgaWYgKCFTdHlsZUluZm8uZ2V0KGhvc3QpKSB7XG4gICAgICAgICAgU3R5bGVJbmZvLnNldChob3N0LCBuZXcgU3R5bGVJbmZvKG51bGwpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHlsZUluZm8gPSAvKiogQHR5cGUgeyFTdHlsZUluZm99ICovKFN0eWxlSW5mby5nZXQoaG9zdCkpO1xuICAgICAgICB0aGlzLl9taXhPdmVycmlkZVN0eWxlUHJvcHMoc3R5bGVJbmZvLCBvdmVycmlkZVByb3BzKTtcbiAgICAgICAgdGhpcy5zdHlsZUVsZW1lbnROYXRpdmVWYXJpYWJsZXMoaG9zdCwgc3R5bGVJbmZvKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3R5bGVJbmZvID0gU3R5bGVJbmZvLmdldChob3N0KSB8fCB0aGlzLl9wcmVwYXJlSG9zdChob3N0KTtcbiAgICAvLyBpZiB0aGVyZSBpcyBubyBzdHlsZSBpbmZvIGF0IHRoaXMgcG9pbnQsIGJhaWxcbiAgICBpZiAoIXN0eWxlSW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBPbmx5IHRyaXAgdGhlIGBlbGVtZW50c0hhdmVBcHBsaWVkYCBmbGFnIGlmIGEgbm9kZSBvdGhlciB0aGF0IHRoZSByb290IGRvY3VtZW50IGhhcyBgYXBwbHlTdHlsZWAgY2FsbGVkXG4gICAgaWYgKCF0aGlzLl9pc1Jvb3RPd25lcihob3N0KSkge1xuICAgICAgdGhpcy5fZWxlbWVudHNIYXZlQXBwbGllZCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvdmVycmlkZVByb3BzKSB7XG4gICAgICB0aGlzLl9taXhPdmVycmlkZVN0eWxlUHJvcHMoc3R5bGVJbmZvLCBvdmVycmlkZVByb3BzKTtcbiAgICB9XG4gICAgaWYgKCFuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50U2hpbVZhcmlhYmxlcyhob3N0LCBzdHlsZUluZm8pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0eWxlRWxlbWVudE5hdGl2ZVZhcmlhYmxlcyhob3N0LCBzdHlsZUluZm8pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshU3R5bGVJbmZvfSBzdHlsZUluZm9cbiAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlUHJvcHNcbiAgICovXG4gIF9taXhPdmVycmlkZVN0eWxlUHJvcHMoc3R5bGVJbmZvLCBvdmVycmlkZVByb3BzKSB7XG4gICAgc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzID1cbiAgICAgIHN0eWxlSW5mby5vdmVycmlkZVN0eWxlUHJvcGVydGllcyB8fCB7fTtcbiAgICBPYmplY3QuYXNzaWduKHN0eWxlSW5mby5vdmVycmlkZVN0eWxlUHJvcGVydGllcywgb3ZlcnJpZGVQcm9wcyk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBob3N0XG4gICAqIEBwYXJhbSB7IVN0eWxlSW5mb30gc3R5bGVJbmZvXG4gICAqL1xuICBzdHlsZUVsZW1lbnRTaGltVmFyaWFibGVzKGhvc3QsIHN0eWxlSW5mbykge1xuICAgIHRoaXMuZmx1c2goKTtcbiAgICB0aGlzLl91cGRhdGVQcm9wZXJ0aWVzKGhvc3QsIHN0eWxlSW5mbyk7XG4gICAgaWYgKHN0eWxlSW5mby5vd25TdHlsZVByb3BlcnR5TmFtZXMgJiYgc3R5bGVJbmZvLm93blN0eWxlUHJvcGVydHlOYW1lcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2FwcGx5U3R5bGVQcm9wZXJ0aWVzKGhvc3QsIHN0eWxlSW5mbyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gaG9zdFxuICAgKiBAcGFyYW0geyFTdHlsZUluZm99IHN0eWxlSW5mb1xuICAgKi9cbiAgc3R5bGVFbGVtZW50TmF0aXZlVmFyaWFibGVzKGhvc3QsIHN0eWxlSW5mbykge1xuICAgIGNvbnN0IHsgaXMgfSA9IFN0eWxlVXRpbC5nZXRJc0V4dGVuZHMoaG9zdCk7XG4gICAgaWYgKHN0eWxlSW5mby5vdmVycmlkZVN0eWxlUHJvcGVydGllcykge1xuICAgICAgdXBkYXRlTmF0aXZlUHJvcGVydGllcyhob3N0LCBzdHlsZUluZm8ub3ZlcnJpZGVTdHlsZVByb3BlcnRpZXMpO1xuICAgIH1cbiAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlTWFwW2lzXTtcbiAgICAvLyBiYWlsIGVhcmx5IGlmIHRoZXJlIGlzIG5vIHNoYWRvd3Jvb3QgZm9yIHRoaXMgZWxlbWVudFxuICAgIGlmICghdGVtcGxhdGUgJiYgIXRoaXMuX2lzUm9vdE93bmVyKGhvc3QpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIGJhaWwgZWFybHkgaWYgdGhlIHRlbXBsYXRlIHdhcyBidWlsdCB3aXRoIHBvbHltZXItY3NzLWJ1aWxkXG4gICAgaWYgKHRlbXBsYXRlICYmIFN0eWxlVXRpbC5lbGVtZW50SGFzQnVpbHRDc3ModGVtcGxhdGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSAmJiB0ZW1wbGF0ZS5fc3R5bGUgJiYgIUFwcGx5U2hpbVV0aWxzLnRlbXBsYXRlSXNWYWxpZCh0ZW1wbGF0ZSkpIHtcbiAgICAgIC8vIHVwZGF0ZSB0ZW1wbGF0ZVxuICAgICAgaWYgKCFBcHBseVNoaW1VdGlscy50ZW1wbGF0ZUlzVmFsaWRhdGluZyh0ZW1wbGF0ZSkpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlKCk7XG4gICAgICAgIHRoaXMuX2FwcGx5U2hpbSAmJiB0aGlzLl9hcHBseVNoaW1bJ3RyYW5zZm9ybVJ1bGVzJ10odGVtcGxhdGVbJ19zdHlsZUFzdCddLCBpcyk7XG4gICAgICAgIHRlbXBsYXRlLl9zdHlsZS50ZXh0Q29udGVudCA9IFN0eWxlVHJhbnNmb3JtZXIuZWxlbWVudFN0eWxlcyhob3N0LCBzdHlsZUluZm8uc3R5bGVSdWxlcyk7XG4gICAgICAgIEFwcGx5U2hpbVV0aWxzLnN0YXJ0VmFsaWRhdGluZ1RlbXBsYXRlKHRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICAgIC8vIHVwZGF0ZSBpbnN0YW5jZSBpZiBuYXRpdmUgc2hhZG93ZG9tXG4gICAgICBpZiAobmF0aXZlU2hhZG93KSB7XG4gICAgICAgIGxldCByb290ID0gaG9zdC5zaGFkb3dSb290O1xuICAgICAgICBpZiAocm9vdCkge1xuICAgICAgICAgIGxldCBzdHlsZSA9IHJvb3QucXVlcnlTZWxlY3Rvcignc3R5bGUnKTtcbiAgICAgICAgICBpZiAoc3R5bGUpIHtcbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gU3R5bGVUcmFuc2Zvcm1lci5lbGVtZW50U3R5bGVzKGhvc3QsIHN0eWxlSW5mby5zdHlsZVJ1bGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0eWxlSW5mby5zdHlsZVJ1bGVzID0gdGVtcGxhdGVbJ19zdHlsZUFzdCddO1xuICAgIH1cbiAgfVxuICBfc3R5bGVPd25lckZvck5vZGUobm9kZSkge1xuICAgIGxldCByb290ID0gU3R5bGVVdGlsLndyYXAobm9kZSkuZ2V0Um9vdE5vZGUoKTtcbiAgICBsZXQgaG9zdCA9IHJvb3QuaG9zdDtcbiAgICBpZiAoaG9zdCkge1xuICAgICAgaWYgKFN0eWxlSW5mby5nZXQoaG9zdCkgfHwgdGhpcy5fcHJlcGFyZUhvc3QoaG9zdCkpIHtcbiAgICAgICAgcmV0dXJuIGhvc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVPd25lckZvck5vZGUoaG9zdCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9kb2N1bWVudE93bmVyO1xuICB9XG4gIF9pc1Jvb3RPd25lcihub2RlKSB7XG4gICAgcmV0dXJuIChub2RlID09PSB0aGlzLl9kb2N1bWVudE93bmVyKTtcbiAgfVxuICBfYXBwbHlTdHlsZVByb3BlcnRpZXMoaG9zdCwgc3R5bGVJbmZvKSB7XG4gICAgbGV0IGlzID0gU3R5bGVVdGlsLmdldElzRXh0ZW5kcyhob3N0KS5pcztcbiAgICBsZXQgY2FjaGVFbnRyeSA9IHN0eWxlQ2FjaGUuZmV0Y2goaXMsIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMsIHN0eWxlSW5mby5vd25TdHlsZVByb3BlcnR5TmFtZXMpO1xuICAgIGxldCBjYWNoZWRTY29wZVNlbGVjdG9yID0gY2FjaGVFbnRyeSAmJiBjYWNoZUVudHJ5LnNjb3BlU2VsZWN0b3I7XG4gICAgbGV0IGNhY2hlZFN0eWxlID0gY2FjaGVFbnRyeSA/IGNhY2hlRW50cnkuc3R5bGVFbGVtZW50IDogbnVsbDtcbiAgICBsZXQgb2xkU2NvcGVTZWxlY3RvciA9IHN0eWxlSW5mby5zY29wZVNlbGVjdG9yO1xuICAgIC8vIG9ubHkgZ2VuZXJhdGUgbmV3IHNjb3BlIGlmIGNhY2hlZCBzdHlsZSBpcyBub3QgZm91bmRcbiAgICBzdHlsZUluZm8uc2NvcGVTZWxlY3RvciA9IGNhY2hlZFNjb3BlU2VsZWN0b3IgfHwgdGhpcy5fZ2VuZXJhdGVTY29wZVNlbGVjdG9yKGlzKTtcbiAgICBsZXQgc3R5bGUgPSBTdHlsZVByb3BlcnRpZXMuYXBwbHlFbGVtZW50U3R5bGUoaG9zdCwgc3R5bGVJbmZvLnN0eWxlUHJvcGVydGllcywgc3R5bGVJbmZvLnNjb3BlU2VsZWN0b3IsIGNhY2hlZFN0eWxlKTtcbiAgICBpZiAoIW5hdGl2ZVNoYWRvdykge1xuICAgICAgU3R5bGVQcm9wZXJ0aWVzLmFwcGx5RWxlbWVudFNjb3BlU2VsZWN0b3IoaG9zdCwgc3R5bGVJbmZvLnNjb3BlU2VsZWN0b3IsIG9sZFNjb3BlU2VsZWN0b3IpO1xuICAgIH1cbiAgICBpZiAoIWNhY2hlRW50cnkpIHtcbiAgICAgIHN0eWxlQ2FjaGUuc3RvcmUoaXMsIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMsIHN0eWxlLCBzdHlsZUluZm8uc2NvcGVTZWxlY3Rvcik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZTtcbiAgfVxuICBfdXBkYXRlUHJvcGVydGllcyhob3N0LCBzdHlsZUluZm8pIHtcbiAgICBsZXQgb3duZXIgPSB0aGlzLl9zdHlsZU93bmVyRm9yTm9kZShob3N0KTtcbiAgICBsZXQgb3duZXJTdHlsZUluZm8gPSBTdHlsZUluZm8uZ2V0KG93bmVyKTtcbiAgICBsZXQgb3duZXJQcm9wZXJ0aWVzID0gb3duZXJTdHlsZUluZm8uc3R5bGVQcm9wZXJ0aWVzO1xuICAgIC8vIHN0eWxlIG93bmVyIGhhcyBub3QgdXBkYXRlZCBwcm9wZXJ0aWVzIHlldFxuICAgIC8vIGdvIHVwIHRoZSBjaGFpbiBhbmQgZm9yY2UgcHJvcGVydHkgdXBkYXRlLFxuICAgIC8vIGV4Y2VwdCBpZiB0aGUgb3duZXIgaXMgdGhlIGRvY3VtZW50XG4gICAgaWYgKG93bmVyICE9PSB0aGlzLl9kb2N1bWVudE93bmVyICYmICFvd25lclByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX3VwZGF0ZVByb3BlcnRpZXMob3duZXIsIG93bmVyU3R5bGVJbmZvKTtcbiAgICAgIG93bmVyUHJvcGVydGllcyA9IG93bmVyU3R5bGVJbmZvLnN0eWxlUHJvcGVydGllcztcbiAgICB9XG4gICAgbGV0IHByb3BzID0gT2JqZWN0LmNyZWF0ZShvd25lclByb3BlcnRpZXMgfHwgbnVsbCk7XG4gICAgbGV0IGhvc3RBbmRSb290UHJvcHMgPSBTdHlsZVByb3BlcnRpZXMuaG9zdEFuZFJvb3RQcm9wZXJ0aWVzRm9yU2NvcGUoaG9zdCwgc3R5bGVJbmZvLnN0eWxlUnVsZXMsIHN0eWxlSW5mby5jc3NCdWlsZCk7XG4gICAgbGV0IHByb3BlcnR5RGF0YSA9IFN0eWxlUHJvcGVydGllcy5wcm9wZXJ0eURhdGFGcm9tU3R5bGVzKG93bmVyU3R5bGVJbmZvLnN0eWxlUnVsZXMsIGhvc3QpO1xuICAgIGxldCBwcm9wZXJ0aWVzTWF0Y2hpbmdIb3N0ID0gcHJvcGVydHlEYXRhLnByb3BlcnRpZXNcbiAgICBPYmplY3QuYXNzaWduKFxuICAgICAgcHJvcHMsXG4gICAgICBob3N0QW5kUm9vdFByb3BzLmhvc3RQcm9wcyxcbiAgICAgIHByb3BlcnRpZXNNYXRjaGluZ0hvc3QsXG4gICAgICBob3N0QW5kUm9vdFByb3BzLnJvb3RQcm9wc1xuICAgICk7XG4gICAgdGhpcy5fbWl4aW5PdmVycmlkZVN0eWxlcyhwcm9wcywgc3R5bGVJbmZvLm92ZXJyaWRlU3R5bGVQcm9wZXJ0aWVzKTtcbiAgICBTdHlsZVByb3BlcnRpZXMucmVpZnkocHJvcHMpO1xuICAgIHN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMgPSBwcm9wcztcbiAgfVxuICBfbWl4aW5PdmVycmlkZVN0eWxlcyhwcm9wcywgb3ZlcnJpZGVzKSB7XG4gICAgZm9yIChsZXQgcCBpbiBvdmVycmlkZXMpIHtcbiAgICAgIGxldCB2ID0gb3ZlcnJpZGVzW3BdO1xuICAgICAgLy8gc2tpcCBvdmVycmlkZSBwcm9wcyBpZiB0aGV5IGFyZSBub3QgdHJ1dGh5IG9yIDBcbiAgICAgIC8vIGluIG9yZGVyIHRvIGZhbGwgYmFjayB0byBpbmhlcml0ZWQgdmFsdWVzXG4gICAgICBpZiAodiB8fCB2ID09PSAwKSB7XG4gICAgICAgIHByb3BzW3BdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdHlsZXMgb2YgdGhlIHdob2xlIGRvY3VtZW50XG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVEb2N1bWVudChwcm9wZXJ0aWVzKSB7XG4gICAgdGhpcy5zdHlsZVN1YnRyZWUodGhpcy5fZG9jdW1lbnRPd25lciwgcHJvcGVydGllcyk7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZSBzdHlsZXMgb2YgYSBzdWJ0cmVlXG4gICAqXG4gICAqIEBwYXJhbSB7IUhUTUxFbGVtZW50fSBob3N0XG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllc1xuICAgKi9cbiAgc3R5bGVTdWJ0cmVlKGhvc3QsIHByb3BlcnRpZXMpIHtcbiAgICBjb25zdCB3cmFwcGVkSG9zdCA9IFN0eWxlVXRpbC53cmFwKGhvc3QpO1xuICAgIGxldCByb290ID0gd3JhcHBlZEhvc3Quc2hhZG93Um9vdDtcbiAgICBpZiAocm9vdCB8fCB0aGlzLl9pc1Jvb3RPd25lcihob3N0KSkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQoaG9zdCwgcHJvcGVydGllcyk7XG4gICAgfVxuICAgIC8vIHByb2Nlc3MgdGhlIHNoYWRvd2RvbSBjaGlsZHJlbiBvZiBgaG9zdGBcbiAgICBsZXQgc2hhZG93Q2hpbGRyZW4gPVxuICAgICAgICByb290ICYmICgvKiogQHR5cGUgeyFQYXJlbnROb2RlfSAqLyAocm9vdCkuY2hpbGRyZW4gfHwgcm9vdC5jaGlsZE5vZGVzKTtcbiAgICBpZiAoc2hhZG93Q2hpbGRyZW4pIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2hhZG93Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IGMgPSAvKiogQHR5cGUgeyFIVE1MRWxlbWVudH0gKi8oc2hhZG93Q2hpbGRyZW5baV0pO1xuICAgICAgICB0aGlzLnN0eWxlU3VidHJlZShjKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvY2VzcyB0aGUgbGlnaHRkb20gY2hpbGRyZW4gb2YgYGhvc3RgXG4gICAgICBsZXQgY2hpbGRyZW4gPSB3cmFwcGVkSG9zdC5jaGlsZHJlbiB8fCB3cmFwcGVkSG9zdC5jaGlsZE5vZGVzO1xuICAgICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBsZXQgYyA9IC8qKiBAdHlwZSB7IUhUTUxFbGVtZW50fSAqLyhjaGlsZHJlbltpXSk7XG4gICAgICAgICAgdGhpcy5zdHlsZVN1YnRyZWUoYyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyogQ3VzdG9tIFN0eWxlIG9wZXJhdGlvbnMgKi9cbiAgX3JldmFsaWRhdGVDdXN0b21TdHlsZUFwcGx5U2hpbShjdXN0b21TdHlsZXMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGN1c3RvbVN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IGMgPSBjdXN0b21TdHlsZXNbaV07XG4gICAgICBsZXQgcyA9IHRoaXMuX2N1c3RvbVN0eWxlSW50ZXJmYWNlWydnZXRTdHlsZUZvckN1c3RvbVN0eWxlJ10oYyk7XG4gICAgICBpZiAocykge1xuICAgICAgICB0aGlzLl9yZXZhbGlkYXRlQXBwbHlTaGltKHMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBfYXBwbHlDdXN0b21TdHlsZXMoY3VzdG9tU3R5bGVzKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXN0b21TdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxldCBjID0gY3VzdG9tU3R5bGVzW2ldO1xuICAgICAgbGV0IHMgPSB0aGlzLl9jdXN0b21TdHlsZUludGVyZmFjZVsnZ2V0U3R5bGVGb3JDdXN0b21TdHlsZSddKGMpO1xuICAgICAgaWYgKHMpIHtcbiAgICAgICAgU3R5bGVQcm9wZXJ0aWVzLmFwcGx5Q3VzdG9tU3R5bGUocywgdGhpcy5fZG9jdW1lbnRPd25lclN0eWxlSW5mby5zdHlsZVByb3BlcnRpZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICB0cmFuc2Zvcm1DdXN0b21TdHlsZUZvckRvY3VtZW50KHN0eWxlKSB7XG4gICAgY29uc3QgY3NzQnVpbGQgPSBTdHlsZVV0aWwuZ2V0Q3NzQnVpbGQoc3R5bGUpO1xuICAgIGlmIChjc3NCdWlsZCAhPT0gdGhpcy5fZG9jdW1lbnRPd25lclN0eWxlSW5mby5jc3NCdWlsZCkge1xuICAgICAgdGhpcy5fZG9jdW1lbnRPd25lclN0eWxlSW5mby5jc3NCdWlsZCA9IGNzc0J1aWxkO1xuICAgIH1cbiAgICBpZiAoU3R5bGVVdGlsLmlzT3B0aW1hbENzc0J1aWxkKGNzc0J1aWxkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsZXQgYXN0ID0gU3R5bGVVdGlsLnJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgIFN0eWxlVXRpbC5mb3JFYWNoUnVsZShhc3QsIChydWxlKSA9PiB7XG4gICAgICBpZiAobmF0aXZlU2hhZG93KSB7XG4gICAgICAgIFN0eWxlVHJhbnNmb3JtZXIubm9ybWFsaXplUm9vdFNlbGVjdG9yKHJ1bGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgU3R5bGVUcmFuc2Zvcm1lci5kb2N1bWVudFJ1bGUocnVsZSk7XG4gICAgICB9XG4gICAgICBpZiAobmF0aXZlQ3NzVmFyaWFibGVzICYmIGNzc0J1aWxkID09PSAnJykge1xuICAgICAgICB0aGlzLl9lbnN1cmUoKTtcbiAgICAgICAgdGhpcy5fYXBwbHlTaGltICYmIHRoaXMuX2FwcGx5U2hpbVsndHJhbnNmb3JtUnVsZSddKHJ1bGUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gU3R5bGVVdGlsLnRvQ3NzVGV4dChhc3QpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb2N1bWVudE93bmVyU3R5bGVJbmZvLnN0eWxlUnVsZXNbJ3J1bGVzJ10ucHVzaChhc3QpO1xuICAgIH1cbiAgfVxuICBfcmV2YWxpZGF0ZUFwcGx5U2hpbShzdHlsZSkge1xuICAgIGlmIChuYXRpdmVDc3NWYXJpYWJsZXMgJiYgdGhpcy5fYXBwbHlTaGltKSB7XG4gICAgICBsZXQgYXN0ID0gU3R5bGVVdGlsLnJ1bGVzRm9yU3R5bGUoc3R5bGUpO1xuICAgICAgdGhpcy5fZW5zdXJlKCk7XG4gICAgICB0aGlzLl9hcHBseVNoaW1bJ3RyYW5zZm9ybVJ1bGVzJ10oYXN0KTtcbiAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gU3R5bGVVdGlsLnRvQ3NzVGV4dChhc3QpO1xuICAgIH1cbiAgfVxuICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgaWYgKCFuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIC8vIGVsZW1lbnQgaXMgZWl0aGVyIGEgc3R5bGUgaG9zdCwgb3IgYW4gYW5jZXN0b3Igb2YgYSBzdHlsZSBob3N0XG4gICAgICBsZXQgc3R5bGVJbmZvID0gU3R5bGVJbmZvLmdldChlbGVtZW50KSB8fCBTdHlsZUluZm8uZ2V0KHRoaXMuX3N0eWxlT3duZXJGb3JOb2RlKGVsZW1lbnQpKTtcbiAgICAgIHZhbHVlID0gc3R5bGVJbmZvLnN0eWxlUHJvcGVydGllc1twcm9wZXJ0eV07XG4gICAgfVxuICAgIC8vIGZhbGwgYmFjayB0byB0aGUgcHJvcGVydHkgdmFsdWUgZnJvbSB0aGUgY29tcHV0ZWQgc3R5bGluZ1xuICAgIHZhbHVlID0gdmFsdWUgfHwgd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZShwcm9wZXJ0eSk7XG4gICAgLy8gdHJpbSB3aGl0ZXNwYWNlIHRoYXQgY2FuIGNvbWUgYWZ0ZXIgdGhlIGA6YCBpbiBjc3NcbiAgICAvLyBleGFtcGxlOiBwYWRkaW5nOiAycHggLT4gXCIgMnB4XCJcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS50cmltKCkgOiAnJztcbiAgfVxuICAvLyBnaXZlbiBhbiBlbGVtZW50IGFuZCBhIGNsYXNzU3RyaW5nLCByZXBsYWNlc1xuICAvLyB0aGUgZWxlbWVudCdzIGNsYXNzIHdpdGggdGhlIHByb3ZpZGVkIGNsYXNzU3RyaW5nIGFuZCBhZGRzXG4gIC8vIGFueSBuZWNlc3NhcnkgU2hhZHlDU1Mgc3RhdGljIGFuZCBwcm9wZXJ0eSBiYXNlZCBzY29waW5nIHNlbGVjdG9yc1xuICBzZXRFbGVtZW50Q2xhc3MoZWxlbWVudCwgY2xhc3NTdHJpbmcpIHtcbiAgICBsZXQgcm9vdCA9IFN0eWxlVXRpbC53cmFwKGVsZW1lbnQpLmdldFJvb3ROb2RlKCk7XG4gICAgbGV0IGNsYXNzZXMgPSBjbGFzc1N0cmluZyA/IGNsYXNzU3RyaW5nLnNwbGl0KC9cXHMvKSA6IFtdO1xuICAgIGxldCBzY29wZU5hbWUgPSByb290Lmhvc3QgJiYgcm9vdC5ob3N0LmxvY2FsTmFtZTtcbiAgICAvLyBJZiBubyBzY29wZSwgdHJ5IHRvIGRpc2NvdmVyIHNjb3BlIG5hbWUgZnJvbSBleGlzdGluZyBjbGFzcy5cbiAgICAvLyBUaGlzIGNhbiBvY2N1ciBpZiwgZm9yIGV4YW1wbGUsIGEgdGVtcGxhdGUgc3RhbXBlZCBlbGVtZW50IHRoYXRcbiAgICAvLyBoYXMgYmVlbiBzY29wZWQgaXMgbWFuaXB1bGF0ZWQgd2hlbiBub3QgaW4gYSByb290LlxuICAgIGlmICghc2NvcGVOYW1lKSB7XG4gICAgICB2YXIgY2xhc3NBdHRyID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgICBpZiAoY2xhc3NBdHRyKSB7XG4gICAgICAgIGxldCBrJCA9IGNsYXNzQXR0ci5zcGxpdCgvXFxzLyk7XG4gICAgICAgIGZvciAobGV0IGk9MDsgaSA8IGskLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKGskW2ldID09PSBTdHlsZVRyYW5zZm9ybWVyLlNDT1BFX05BTUUpIHtcbiAgICAgICAgICAgIHNjb3BlTmFtZSA9IGskW2krMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNjb3BlTmFtZSkge1xuICAgICAgY2xhc3Nlcy5wdXNoKFN0eWxlVHJhbnNmb3JtZXIuU0NPUEVfTkFNRSwgc2NvcGVOYW1lKTtcbiAgICB9XG4gICAgaWYgKCFuYXRpdmVDc3NWYXJpYWJsZXMpIHtcbiAgICAgIGxldCBzdHlsZUluZm8gPSBTdHlsZUluZm8uZ2V0KGVsZW1lbnQpO1xuICAgICAgaWYgKHN0eWxlSW5mbyAmJiBzdHlsZUluZm8uc2NvcGVTZWxlY3Rvcikge1xuICAgICAgICBjbGFzc2VzLnB1c2goU3R5bGVQcm9wZXJ0aWVzLlhTQ09QRV9OQU1FLCBzdHlsZUluZm8uc2NvcGVTZWxlY3Rvcik7XG4gICAgICB9XG4gICAgfVxuICAgIFN0eWxlVXRpbC5zZXRFbGVtZW50Q2xhc3NSYXcoZWxlbWVudCwgY2xhc3Nlcy5qb2luKCcgJykpO1xuICB9XG4gIF9zdHlsZUluZm9Gb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gU3R5bGVJbmZvLmdldChub2RlKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVcbiAgICovXG4gIHNjb3BlTm9kZShub2RlLCBzY29wZSkge1xuICAgIFN0eWxlVHJhbnNmb3JtZXIuZWxlbWVudChub2RlLCBzY29wZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IG5vZGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNjb3BlXG4gICAqL1xuICB1bnNjb3BlTm9kZShub2RlLCBzY29wZSkge1xuICAgIFN0eWxlVHJhbnNmb3JtZXIuZWxlbWVudChub2RlLCBzY29wZSwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgc2NvcGVGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0T3duZXJTY29wZShub2RlKTtcbiAgfVxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gbm9kZVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBjdXJyZW50U2NvcGVGb3JOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gZ2V0Q3VycmVudFNjb3BlKG5vZGUpO1xuICB9XG59XG5cbi8qIGV4cG9ydHMgKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtYXNzaWduICovXG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ2ZsdXNoJ10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUuZmx1c2g7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3ByZXBhcmVUZW1wbGF0ZSddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLnByZXBhcmVUZW1wbGF0ZTtcblNjb3BpbmdTaGltLnByb3RvdHlwZVsnc3R5bGVFbGVtZW50J10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUuc3R5bGVFbGVtZW50O1xuU2NvcGluZ1NoaW0ucHJvdG90eXBlWydzdHlsZURvY3VtZW50J10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUuc3R5bGVEb2N1bWVudDtcblNjb3BpbmdTaGltLnByb3RvdHlwZVsnc3R5bGVTdWJ0cmVlJ10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUuc3R5bGVTdWJ0cmVlO1xuU2NvcGluZ1NoaW0ucHJvdG90eXBlWydnZXRDb21wdXRlZFN0eWxlVmFsdWUnXSA9IFNjb3BpbmdTaGltLnByb3RvdHlwZS5nZXRDb21wdXRlZFN0eWxlVmFsdWU7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3NldEVsZW1lbnRDbGFzcyddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLnNldEVsZW1lbnRDbGFzcztcblNjb3BpbmdTaGltLnByb3RvdHlwZVsnX3N0eWxlSW5mb0Zvck5vZGUnXSA9IFNjb3BpbmdTaGltLnByb3RvdHlwZS5fc3R5bGVJbmZvRm9yTm9kZTtcblNjb3BpbmdTaGltLnByb3RvdHlwZVsndHJhbnNmb3JtQ3VzdG9tU3R5bGVGb3JEb2N1bWVudCddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLnRyYW5zZm9ybUN1c3RvbVN0eWxlRm9yRG9jdW1lbnQ7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ2dldFN0eWxlQXN0J10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUuZ2V0U3R5bGVBc3Q7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3N0eWxlQXN0VG9TdHJpbmcnXSA9IFNjb3BpbmdTaGltLnByb3RvdHlwZS5zdHlsZUFzdFRvU3RyaW5nO1xuU2NvcGluZ1NoaW0ucHJvdG90eXBlWydmbHVzaEN1c3RvbVN0eWxlcyddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLmZsdXNoQ3VzdG9tU3R5bGVzO1xuU2NvcGluZ1NoaW0ucHJvdG90eXBlWydzY29wZU5vZGUnXSA9IFNjb3BpbmdTaGltLnByb3RvdHlwZS5zY29wZU5vZGU7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3Vuc2NvcGVOb2RlJ10gPSBTY29waW5nU2hpbS5wcm90b3R5cGUudW5zY29wZU5vZGU7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3Njb3BlRm9yTm9kZSddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLnNjb3BlRm9yTm9kZTtcblNjb3BpbmdTaGltLnByb3RvdHlwZVsnY3VycmVudFNjb3BlRm9yTm9kZSddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLmN1cnJlbnRTY29wZUZvck5vZGU7XG5TY29waW5nU2hpbS5wcm90b3R5cGVbJ3ByZXBhcmVBZG9wdGVkQ3NzVGV4dCddID0gU2NvcGluZ1NoaW0ucHJvdG90eXBlLnByZXBhcmVBZG9wdGVkQ3NzVGV4dDtcbi8qIGVzbGludC1lbmFibGUgbm8tc2VsZi1hc3NpZ24gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFNjb3BpbmdTaGltLnByb3RvdHlwZSwge1xuICAnbmF0aXZlU2hhZG93Jzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTaGFkb3c7XG4gICAgfVxuICB9LFxuICAnbmF0aXZlQ3NzJzoge1xuICAgIGdldCgpIHtcbiAgICAgIHJldHVybiBuYXRpdmVDc3NWYXJpYWJsZXM7XG4gICAgfVxuICB9XG59KTtcbiIsIi8qKlxuQGxpY2Vuc2VcbkNvcHlyaWdodCAoYykgMjAxNyBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG5UaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG5UaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG5Db2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiovXG5cbid1c2Ugc3RyaWN0JztcblxuaW1wb3J0IFNjb3BpbmdTaGltIGZyb20gJy4uL3NyYy9zY29waW5nLXNoaW0uanMnO1xuaW1wb3J0IHtuYXRpdmVDc3NWYXJpYWJsZXMsIG5hdGl2ZVNoYWRvdywgY3NzQnVpbGQsIGRpc2FibGVSdW50aW1lfSBmcm9tICcuLi9zcmMvc3R5bGUtc2V0dGluZ3MuanMnO1xuXG4vKiogQGNvbnN0IHtTY29waW5nU2hpbX0gKi9cbmNvbnN0IHNjb3BpbmdTaGltID0gbmV3IFNjb3BpbmdTaGltKCk7XG5cbmxldCBBcHBseVNoaW0sIEN1c3RvbVN0eWxlSW50ZXJmYWNlO1xuXG5pZiAod2luZG93WydTaGFkeUNTUyddKSB7XG4gIEFwcGx5U2hpbSA9IHdpbmRvd1snU2hhZHlDU1MnXVsnQXBwbHlTaGltJ107XG4gIEN1c3RvbVN0eWxlSW50ZXJmYWNlID0gd2luZG93WydTaGFkeUNTUyddWydDdXN0b21TdHlsZUludGVyZmFjZSddO1xufVxuXG53aW5kb3cuU2hhZHlDU1MgPSB7XG4gIFNjb3BpbmdTaGltOiBzY29waW5nU2hpbSxcbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZz19IGVsZW1lbnRFeHRlbmRzXG4gICAqL1xuICBwcmVwYXJlVGVtcGxhdGUodGVtcGxhdGUsIGVsZW1lbnROYW1lLCBlbGVtZW50RXh0ZW5kcykge1xuICAgIHNjb3BpbmdTaGltLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgc2NvcGluZ1NoaW0ucHJlcGFyZVRlbXBsYXRlKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpXG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9IHRlbXBsYXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbGVtZW50TmFtZVxuICAgKi9cbiAgcHJlcGFyZVRlbXBsYXRlRG9tKHRlbXBsYXRlLCBlbGVtZW50TmFtZSkge1xuICAgIHNjb3BpbmdTaGltLnByZXBhcmVUZW1wbGF0ZURvbSh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MVGVtcGxhdGVFbGVtZW50fSB0ZW1wbGF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZWxlbWVudE5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBlbGVtZW50RXh0ZW5kc1xuICAgKi9cbiAgcHJlcGFyZVRlbXBsYXRlU3R5bGVzKHRlbXBsYXRlLCBlbGVtZW50TmFtZSwgZWxlbWVudEV4dGVuZHMpIHtcbiAgICBzY29waW5nU2hpbS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgIHNjb3BpbmdTaGltLnByZXBhcmVUZW1wbGF0ZVN0eWxlcyh0ZW1wbGF0ZSwgZWxlbWVudE5hbWUsIGVsZW1lbnRFeHRlbmRzKVxuICB9LFxuICAvKipcbiAgICogQHBhcmFtIHshSFRNTEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZVN1YnRyZWUoZWxlbWVudCwgcHJvcGVydGllcykge1xuICAgIHNjb3BpbmdTaGltLmZsdXNoQ3VzdG9tU3R5bGVzKCk7XG4gICAgc2NvcGluZ1NoaW0uc3R5bGVTdWJ0cmVlKGVsZW1lbnQsIHByb3BlcnRpZXMpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgc3R5bGVFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBzY29waW5nU2hpbS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgIHNjb3BpbmdTaGltLnN0eWxlRWxlbWVudChlbGVtZW50KTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzXG4gICAqL1xuICBzdHlsZURvY3VtZW50KHByb3BlcnRpZXMpIHtcbiAgICBzY29waW5nU2hpbS5mbHVzaEN1c3RvbVN0eWxlcygpO1xuICAgIHNjb3BpbmdTaGltLnN0eWxlRG9jdW1lbnQocHJvcGVydGllcyk7XG4gIH0sXG5cbiAgZmx1c2hDdXN0b21TdHlsZXMoKSB7XG4gICAgc2NvcGluZ1NoaW0uZmx1c2hDdXN0b21TdHlsZXMoKTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eVxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRDb21wdXRlZFN0eWxlVmFsdWUoZWxlbWVudCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gc2NvcGluZ1NoaW0uZ2V0Q29tcHV0ZWRTdHlsZVZhbHVlKGVsZW1lbnQsIHByb3BlcnR5KTtcbiAgfSxcblxuICBuYXRpdmVDc3M6IG5hdGl2ZUNzc1ZhcmlhYmxlcyxcblxuICBuYXRpdmVTaGFkb3c6IG5hdGl2ZVNoYWRvdyxcblxuICBjc3NCdWlsZDogY3NzQnVpbGQsXG5cbiAgZGlzYWJsZVJ1bnRpbWU6IGRpc2FibGVSdW50aW1lLFxufTtcblxuaWYgKEFwcGx5U2hpbSkge1xuICB3aW5kb3cuU2hhZHlDU1MuQXBwbHlTaGltID0gQXBwbHlTaGltO1xufVxuXG5pZiAoQ3VzdG9tU3R5bGVJbnRlcmZhY2UpIHtcbiAgd2luZG93LlNoYWR5Q1NTLkN1c3RvbVN0eWxlSW50ZXJmYWNlID0gQ3VzdG9tU3R5bGVJbnRlcmZhY2U7XG59IiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmNvbnN0IHJlc2VydmVkVGFnTGlzdCA9IG5ldyBTZXQoW1xuICAnYW5ub3RhdGlvbi14bWwnLFxuICAnY29sb3ItcHJvZmlsZScsXG4gICdmb250LWZhY2UnLFxuICAnZm9udC1mYWNlLXNyYycsXG4gICdmb250LWZhY2UtdXJpJyxcbiAgJ2ZvbnQtZmFjZS1mb3JtYXQnLFxuICAnZm9udC1mYWNlLW5hbWUnLFxuICAnbWlzc2luZy1nbHlwaCcsXG5dKTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsaWRDdXN0b21FbGVtZW50TmFtZShsb2NhbE5hbWUpIHtcbiAgY29uc3QgcmVzZXJ2ZWQgPSByZXNlcnZlZFRhZ0xpc3QuaGFzKGxvY2FsTmFtZSk7XG4gIGNvbnN0IHZhbGlkRm9ybSA9IC9eW2Etel1bLjAtOV9hLXpdKi1bXFwtLjAtOV9hLXpdKiQvLnRlc3QobG9jYWxOYW1lKTtcbiAgcmV0dXJuICFyZXNlcnZlZCAmJiB2YWxpZEZvcm07XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29ubmVjdGVkKG5vZGUpIHtcbiAgLy8gVXNlIGBOb2RlI2lzQ29ubmVjdGVkYCwgaWYgZGVmaW5lZC5cbiAgY29uc3QgbmF0aXZlVmFsdWUgPSBub2RlLmlzQ29ubmVjdGVkO1xuICBpZiAobmF0aXZlVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuYXRpdmVWYWx1ZTtcbiAgfVxuXG4gIC8qKiBAdHlwZSB7P05vZGV8dW5kZWZpbmVkfSAqL1xuICBsZXQgY3VycmVudCA9IG5vZGU7XG4gIHdoaWxlIChjdXJyZW50ICYmICEoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSkge1xuICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGUgfHwgKHdpbmRvdy5TaGFkb3dSb290ICYmIGN1cnJlbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290ID8gY3VycmVudC5ob3N0IDogdW5kZWZpbmVkKTtcbiAgfVxuICByZXR1cm4gISEoY3VycmVudCAmJiAoY3VycmVudC5fX0NFX2lzSW1wb3J0RG9jdW1lbnQgfHwgY3VycmVudCBpbnN0YW5jZW9mIERvY3VtZW50KSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICogQHBhcmFtIHshTm9kZX0gc3RhcnRcbiAqIEByZXR1cm4gez9Ob2RlfVxuICovXG5mdW5jdGlvbiBuZXh0U2libGluZ09yQW5jZXN0b3JTaWJsaW5nKHJvb3QsIHN0YXJ0KSB7XG4gIGxldCBub2RlID0gc3RhcnQ7XG4gIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHJvb3QgJiYgIW5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG4gIHJldHVybiAoIW5vZGUgfHwgbm9kZSA9PT0gcm9vdCkgPyBudWxsIDogbm9kZS5uZXh0U2libGluZztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFOb2RlfSByb290XG4gKiBAcGFyYW0geyFOb2RlfSBzdGFydFxuICogQHJldHVybiB7P05vZGV9XG4gKi9cbmZ1bmN0aW9uIG5leHROb2RlKHJvb3QsIHN0YXJ0KSB7XG4gIHJldHVybiBzdGFydC5maXJzdENoaWxkID8gc3RhcnQuZmlyc3RDaGlsZCA6IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgc3RhcnQpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAqIEBwYXJhbSB7IWZ1bmN0aW9uKCFFbGVtZW50KX0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7IVNldDxOb2RlPj19IHZpc2l0ZWRJbXBvcnRzXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBjYWxsYmFjaywgdmlzaXRlZEltcG9ydHMgPSBuZXcgU2V0KCkpIHtcbiAgbGV0IG5vZGUgPSByb290O1xuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgY29uc3QgZWxlbWVudCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovKG5vZGUpO1xuXG4gICAgICBjYWxsYmFjayhlbGVtZW50KTtcblxuICAgICAgY29uc3QgbG9jYWxOYW1lID0gZWxlbWVudC5sb2NhbE5hbWU7XG4gICAgICBpZiAobG9jYWxOYW1lID09PSAnbGluaycgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JlbCcpID09PSAnaW1wb3J0Jykge1xuICAgICAgICAvLyBJZiB0aGlzIGltcG9ydCAocG9seWZpbGxlZCBvciBub3QpIGhhcyBpdCdzIHJvb3Qgbm9kZSBhdmFpbGFibGUsXG4gICAgICAgIC8vIHdhbGsgaXQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgeyFOb2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuICAgICAgICBpZiAoaW1wb3J0Tm9kZSBpbnN0YW5jZW9mIE5vZGUgJiYgIXZpc2l0ZWRJbXBvcnRzLmhhcyhpbXBvcnROb2RlKSkge1xuICAgICAgICAgIC8vIFByZXZlbnQgbXVsdGlwbGUgd2Fsa3Mgb2YgdGhlIHNhbWUgaW1wb3J0IHJvb3QuXG4gICAgICAgICAgdmlzaXRlZEltcG9ydHMuYWRkKGltcG9ydE5vZGUpO1xuXG4gICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBpbXBvcnROb2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICB3YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhjaGlsZCwgY2FsbGJhY2ssIHZpc2l0ZWRJbXBvcnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZ25vcmUgZGVzY2VuZGFudHMgb2YgaW1wb3J0IGxpbmtzIHRvIHByZXZlbnQgYXR0ZW1wdGluZyB0byB3YWxrIHRoZVxuICAgICAgICAvLyBlbGVtZW50cyBjcmVhdGVkIGJ5IHRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgdGhhdCB3ZSBqdXN0IHdhbGtlZFxuICAgICAgICAvLyBhYm92ZS5cbiAgICAgICAgbm9kZSA9IG5leHRTaWJsaW5nT3JBbmNlc3RvclNpYmxpbmcocm9vdCwgZWxlbWVudCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChsb2NhbE5hbWUgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgICAgLy8gSWdub3JlIGRlc2NlbmRhbnRzIG9mIHRlbXBsYXRlcy4gVGhlcmUgc2hvdWxkbid0IGJlIGFueSBkZXNjZW5kYW50c1xuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgd2lsbCBiZSBtb3ZlZCBpbnRvIGAuY29udGVudGAgZHVyaW5nIGNvbnN0cnVjdGlvbiBpblxuICAgICAgICAvLyBicm93c2VycyB0aGF0IHN1cHBvcnQgdGVtcGxhdGUgYnV0LCBpbiBjYXNlIHRoZXkgZXhpc3QgYW5kIGFyZSBzdGlsbFxuICAgICAgICAvLyB3YWl0aW5nIHRvIGJlIG1vdmVkIGJ5IGEgcG9seWZpbGwsIHRoZXkgd2lsbCBiZSBpZ25vcmVkLlxuICAgICAgICBub2RlID0gbmV4dFNpYmxpbmdPckFuY2VzdG9yU2libGluZyhyb290LCBlbGVtZW50KTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhbGsgc2hhZG93IHJvb3RzLlxuICAgICAgY29uc3Qgc2hhZG93Um9vdCA9IGVsZW1lbnQuX19DRV9zaGFkb3dSb290O1xuICAgICAgaWYgKHNoYWRvd1Jvb3QpIHtcbiAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBzaGFkb3dSb290LmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHMoY2hpbGQsIGNhbGxiYWNrLCB2aXNpdGVkSW1wb3J0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gbmV4dE5vZGUocm9vdCwgbm9kZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBVc2VkIHRvIHN1cHByZXNzIENsb3N1cmUncyBcIk1vZGlmeWluZyB0aGUgcHJvdG90eXBlIGlzIG9ubHkgYWxsb3dlZCBpZiB0aGVcbiAqIGNvbnN0cnVjdG9yIGlzIGluIHRoZSBzYW1lIHNjb3BlXCIgd2FybmluZyB3aXRob3V0IHVzaW5nXG4gKiBgQHN1cHByZXNzIHtuZXdDaGVja1R5cGVzLCBkdXBsaWNhdGV9YCBiZWNhdXNlIGBuZXdDaGVja1R5cGVzYCBpcyB0b28gYnJvYWQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBkZXN0aW5hdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCBuYW1lLCB2YWx1ZSkge1xuICBkZXN0aW5hdGlvbltuYW1lXSA9IHZhbHVlO1xufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbi8qKlxuICogQGVudW0ge251bWJlcn1cbiAqL1xuY29uc3QgQ3VzdG9tRWxlbWVudFN0YXRlID0ge1xuICBjdXN0b206IDEsXG4gIGZhaWxlZDogMixcbn07XG5cbmV4cG9ydCBkZWZhdWx0IEN1c3RvbUVsZW1lbnRTdGF0ZTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgKiBhcyBVdGlsaXRpZXMgZnJvbSAnLi9VdGlsaXRpZXMuanMnO1xuaW1wb3J0IENFU3RhdGUgZnJvbSAnLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21FbGVtZW50SW50ZXJuYWxzIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIHshTWFwPHN0cmluZywgIUN1c3RvbUVsZW1lbnREZWZpbml0aW9uPn0gKi9cbiAgICB0aGlzLl9sb2NhbE5hbWVUb0RlZmluaXRpb24gPSBuZXcgTWFwKCk7XG5cbiAgICAvKiogQHR5cGUgeyFNYXA8IUZ1bmN0aW9uLCAhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fSAqL1xuICAgIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uID0gbmV3IE1hcCgpO1xuXG4gICAgLyoqIEB0eXBlIHshQXJyYXk8IWZ1bmN0aW9uKCFOb2RlKT59ICovXG4gICAgdGhpcy5fcGF0Y2hlc05vZGUgPSBbXTtcblxuICAgIC8qKiBAdHlwZSB7IUFycmF5PCFmdW5jdGlvbighRWxlbWVudCk+fSAqL1xuICAgIHRoaXMuX3BhdGNoZXNFbGVtZW50ID0gW107XG5cbiAgICAvKiogQHR5cGUge2Jvb2xlYW59ICovXG4gICAgdGhpcy5faGFzUGF0Y2hlcyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb259IGRlZmluaXRpb25cbiAgICovXG4gIHNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKSB7XG4gICAgdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLnNldChsb2NhbE5hbWUsIGRlZmluaXRpb24pO1xuICAgIHRoaXMuX2NvbnN0cnVjdG9yVG9EZWZpbml0aW9uLnNldChkZWZpbml0aW9uLmNvbnN0cnVjdG9yRnVuY3Rpb24sIGRlZmluaXRpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7IUN1c3RvbUVsZW1lbnREZWZpbml0aW9ufHVuZGVmaW5lZH1cbiAgICovXG4gIGxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9jYWxOYW1lVG9EZWZpbml0aW9uLmdldChsb2NhbE5hbWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBjb25zdHJ1Y3RvclxuICAgKiBAcmV0dXJuIHshQ3VzdG9tRWxlbWVudERlZmluaXRpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpIHtcbiAgICByZXR1cm4gdGhpcy5fY29uc3RydWN0b3JUb0RlZmluaXRpb24uZ2V0KGNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbighTm9kZSl9IHBhdGNoXG4gICAqL1xuICBhZGROb2RlUGF0Y2gocGF0Y2gpIHtcbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXRjaGVzTm9kZS5wdXNoKHBhdGNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFmdW5jdGlvbighRWxlbWVudCl9IHBhdGNoXG4gICAqL1xuICBhZGRFbGVtZW50UGF0Y2gocGF0Y2gpIHtcbiAgICB0aGlzLl9oYXNQYXRjaGVzID0gdHJ1ZTtcbiAgICB0aGlzLl9wYXRjaGVzRWxlbWVudC5wdXNoKHBhdGNoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAqL1xuICBwYXRjaFRyZWUobm9kZSkge1xuICAgIGlmICghdGhpcy5faGFzUGF0Y2hlcykgcmV0dXJuO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKG5vZGUsIGVsZW1lbnQgPT4gdGhpcy5wYXRjaEVsZW1lbnQoZWxlbWVudCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVcbiAgICovXG4gIHBhdGNoTm9kZShub2RlKSB7XG4gICAgaWYgKCF0aGlzLl9oYXNQYXRjaGVzKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5fX0NFX3BhdGNoZWQpIHJldHVybjtcbiAgICBub2RlLl9fQ0VfcGF0Y2hlZCA9IHRydWU7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3BhdGNoZXNOb2RlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLl9wYXRjaGVzTm9kZVtpXShub2RlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgcGF0Y2hFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuX2hhc1BhdGNoZXMpIHJldHVybjtcblxuICAgIGlmIChlbGVtZW50Ll9fQ0VfcGF0Y2hlZCkgcmV0dXJuO1xuICAgIGVsZW1lbnQuX19DRV9wYXRjaGVkID0gdHJ1ZTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGF0Y2hlc05vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhdGNoZXNOb2RlW2ldKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcGF0Y2hlc0VsZW1lbnQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX3BhdGNoZXNFbGVtZW50W2ldKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFOb2RlfSByb290XG4gICAqL1xuICBjb25uZWN0VHJlZShyb290KSB7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBlbGVtZW50ID0+IGVsZW1lbnRzLnB1c2goZWxlbWVudCkpO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBlbGVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGVsZW1lbnRzW2ldO1xuICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IU5vZGV9IHJvb3RcbiAgICovXG4gIGRpc2Nvbm5lY3RUcmVlKHJvb3QpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdO1xuXG4gICAgVXRpbGl0aWVzLndhbGtEZWVwRGVzY2VuZGFudEVsZW1lbnRzKHJvb3QsIGVsZW1lbnQgPT4gZWxlbWVudHMucHVzaChlbGVtZW50KSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBlbGVtZW50ID0gZWxlbWVudHNbaV07XG4gICAgICBpZiAoZWxlbWVudC5fX0NFX3N0YXRlID09PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlcyBhbGwgdW5jdXN0b21pemVkIGN1c3RvbSBlbGVtZW50cyBhdCBhbmQgYmVsb3cgYSByb290IG5vZGUgZm9yXG4gICAqIHdoaWNoIHRoZXJlIGlzIGEgZGVmaW5pdGlvbi4gV2hlbiBjdXN0b20gZWxlbWVudCByZWFjdGlvbiBjYWxsYmFja3MgYXJlXG4gICAqIGFzc3VtZWQgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHkgKHdoaWNoLCBieSB0aGUgY3VycmVudCBET00gLyBIVE1MIHNwZWNcbiAgICogZGVmaW5pdGlvbnMsIHRoZXkgYXJlICpub3QqKSwgY2FsbGJhY2tzIGZvciBib3RoIGVsZW1lbnRzIGN1c3RvbWl6ZWRcbiAgICogc3luY2hyb25vdXNseSBieSB0aGUgcGFyc2VyIGFuZCBlbGVtZW50cyBiZWluZyB1cGdyYWRlZCBvY2N1ciBpbiB0aGUgc2FtZVxuICAgKiByZWxhdGl2ZSBvcmRlci5cbiAgICpcbiAgICogTk9URTogVGhpcyBmdW5jdGlvbiwgd2hlbiB1c2VkIHRvIHNpbXVsYXRlIHRoZSBjb25zdHJ1Y3Rpb24gb2YgYSB0cmVlIHRoYXRcbiAgICogaXMgYWxyZWFkeSBjcmVhdGVkIGJ1dCBub3QgY3VzdG9taXplZCAoaS5lLiBieSB0aGUgcGFyc2VyKSwgZG9lcyAqbm90KlxuICAgKiBwcmV2ZW50IHRoZSBlbGVtZW50IGZyb20gcmVhZGluZyB0aGUgJ2ZpbmFsJyAodHJ1ZSkgc3RhdGUgb2YgdGhlIHRyZWUuIEZvclxuICAgKiBleGFtcGxlLCB0aGUgZWxlbWVudCwgZHVyaW5nIHRydWx5IHN5bmNocm9ub3VzIHBhcnNpbmcgLyBjb25zdHJ1Y3Rpb24gd291bGRcbiAgICogc2VlIHRoYXQgaXQgY29udGFpbnMgbm8gY2hpbGRyZW4gYXMgdGhleSBoYXZlIG5vdCB5ZXQgYmVlbiBpbnNlcnRlZC5cbiAgICogSG93ZXZlciwgdGhpcyBmdW5jdGlvbiBkb2VzIG5vdCBtb2RpZnkgdGhlIHRyZWUsIHRoZSBlbGVtZW50IHdpbGxcbiAgICogKGluY29ycmVjdGx5KSBoYXZlIGNoaWxkcmVuLiBBZGRpdGlvbmFsbHksIHNlbGYtbW9kaWZpY2F0aW9uIHJlc3RyaWN0aW9uc1xuICAgKiBmb3IgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3JzIGltcG9zZWQgYnkgdGhlIERPTSBzcGVjIGFyZSAqbm90KiBlbmZvcmNlZC5cbiAgICpcbiAgICpcbiAgICogVGhlIGZvbGxvd2luZyBuZXN0ZWQgbGlzdCBzaG93cyB0aGUgc3RlcHMgZXh0ZW5kaW5nIGRvd24gZnJvbSB0aGUgSFRNTFxuICAgKiBzcGVjJ3MgcGFyc2luZyBzZWN0aW9uIHRoYXQgY2F1c2UgZWxlbWVudHMgdG8gYmUgc3luY2hyb25vdXNseSBjcmVhdGVkIGFuZFxuICAgKiB1cGdyYWRlZDpcbiAgICpcbiAgICogVGhlIFwiaW4gYm9keVwiIGluc2VydGlvbiBtb2RlOlxuICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAqIC0gU3dpdGNoIG9uIHRva2VuOlxuICAgKiAgIC4uIG90aGVyIGNhc2VzIC4uXG4gICAqICAgLT4gQW55IG90aGVyIHN0YXJ0IHRhZ1xuICAgKiAgICAgIC0gW0luc2VydCBhbiBIVE1MIGVsZW1lbnRdKGJlbG93KSBmb3IgdGhlIHRva2VuLlxuICAgKlxuICAgKiBJbnNlcnQgYW4gSFRNTCBlbGVtZW50OlxuICAgKiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNpbnNlcnQtYW4taHRtbC1lbGVtZW50XG4gICAqIC0gSW5zZXJ0IGEgZm9yZWlnbiBlbGVtZW50IGZvciB0aGUgdG9rZW4gaW4gdGhlIEhUTUwgbmFtZXNwYWNlOlxuICAgKiAgIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2luc2VydC1hLWZvcmVpZ24tZWxlbWVudFxuICAgKiAgIC0gQ3JlYXRlIGFuIGVsZW1lbnQgZm9yIGEgdG9rZW46XG4gICAqICAgICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNjcmVhdGUtYW4tZWxlbWVudC1mb3ItdGhlLXRva2VuXG4gICAqICAgICAtIFdpbGwgZXhlY3V0ZSBzY3JpcHQgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAtIChFbGVtZW50IHF1ZXVlIHB1c2hlZCB0byB0aGUgY3VzdG9tIGVsZW1lbnQgcmVhY3Rpb25zIHN0YWNrLilcbiAgICogICAgIC0gQ3JlYXRlIGFuIGVsZW1lbnQ6XG4gICAqICAgICAgIGh0dHBzOi8vZG9tLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1jcmVhdGUtZWxlbWVudFxuICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyB0cnVlP1xuICAgKiAgICAgICAgIC0gQ29uc3RydWN0b3IgY2FsbGVkLlxuICAgKiAgICAgICAgIC0gU2VsZi1tb2RpZmljYXRpb24gcmVzdHJpY3Rpb25zIGVuZm9yY2VkLlxuICAgKiAgICAgICAtIFN5bmMgQ0UgZmxhZyBpcyBmYWxzZT9cbiAgICogICAgICAgICAtIChVcGdyYWRlIHJlYWN0aW9uIGVucXVldWVkLilcbiAgICogICAgIC0gQXR0cmlidXRlcyBhcHBlbmRlZCB0byBlbGVtZW50LlxuICAgKiAgICAgICAoYGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFja2AgcmVhY3Rpb25zIGVucXVldWVkLilcbiAgICogICAgIC0gV2lsbCBleGVjdXRlIHNjcmlwdCBmbGFnIGlzIHRydWU/XG4gICAqICAgICAgIC0gKEVsZW1lbnQgcXVldWUgcG9wcGVkIGZyb20gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay5cbiAgICogICAgICAgICBSZWFjdGlvbnMgaW4gdGhlIHBvcHBlZCBzdGFjayBhcmUgaW52b2tlZC4pXG4gICAqICAgLSAoRWxlbWVudCBxdWV1ZSBwdXNoZWQgdG8gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay4pXG4gICAqICAgLSBJbnNlcnQgdGhlIGVsZW1lbnQ6XG4gICAqICAgICBodHRwczovL2RvbS5zcGVjLndoYXR3Zy5vcmcvI2NvbmNlcHQtbm9kZS1pbnNlcnRcbiAgICogICAgIC0gU2hhZG93LWluY2x1ZGluZyBkZXNjZW5kYW50cyBhcmUgY29ubmVjdGVkLiBEdXJpbmcgcGFyc2luZ1xuICAgKiAgICAgICBjb25zdHJ1Y3Rpb24sIHRoZXJlIGFyZSBubyBzaGFkb3ctKmV4Y2x1ZGluZyogZGVzY2VuZGFudHMuXG4gICAqICAgICAgIEhvd2V2ZXIsIHRoZSBjb25zdHJ1Y3RvciBtYXkgaGF2ZSB2YWxpZGx5IGF0dGFjaGVkIGEgc2hhZG93XG4gICAqICAgICAgIHRyZWUgdG8gaXRzZWxmIGFuZCBhZGRlZCBkZXNjZW5kYW50cyB0byB0aGF0IHNoYWRvdyB0cmVlLlxuICAgKiAgICAgICAoYGNvbm5lY3RlZENhbGxiYWNrYCByZWFjdGlvbnMgZW5xdWV1ZWQuKVxuICAgKiAgIC0gKEVsZW1lbnQgcXVldWUgcG9wcGVkIGZyb20gdGhlIGN1c3RvbSBlbGVtZW50IHJlYWN0aW9ucyBzdGFjay5cbiAgICogICAgIFJlYWN0aW9ucyBpbiB0aGUgcG9wcGVkIHN0YWNrIGFyZSBpbnZva2VkLilcbiAgICpcbiAgICogQHBhcmFtIHshTm9kZX0gcm9vdFxuICAgKiBAcGFyYW0ge3tcbiAgICogICB2aXNpdGVkSW1wb3J0czogKCFTZXQ8IU5vZGU+fHVuZGVmaW5lZCksXG4gICAqICAgdXBncmFkZTogKCFmdW5jdGlvbighRWxlbWVudCl8dW5kZWZpbmVkKSxcbiAgICogfT19IG9wdGlvbnNcbiAgICovXG4gIHBhdGNoQW5kVXBncmFkZVRyZWUocm9vdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgdmlzaXRlZEltcG9ydHMgPSBvcHRpb25zLnZpc2l0ZWRJbXBvcnRzIHx8IG5ldyBTZXQoKTtcbiAgICBjb25zdCB1cGdyYWRlID0gb3B0aW9ucy51cGdyYWRlIHx8IChlbGVtZW50ID0+IHRoaXMudXBncmFkZUVsZW1lbnQoZWxlbWVudCkpO1xuXG4gICAgY29uc3QgZWxlbWVudHMgPSBbXTtcblxuICAgIGNvbnN0IGdhdGhlckVsZW1lbnRzID0gZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC5sb2NhbE5hbWUgPT09ICdsaW5rJyAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgncmVsJykgPT09ICdpbXBvcnQnKSB7XG4gICAgICAgIC8vIFRoZSBIVE1MIEltcG9ydHMgcG9seWZpbGwgc2V0cyBhIGRlc2NlbmRhbnQgZWxlbWVudCBvZiB0aGUgbGluayB0b1xuICAgICAgICAvLyB0aGUgYGltcG9ydGAgcHJvcGVydHksIHNwZWNpZmljYWxseSB0aGlzIGlzICpub3QqIGEgRG9jdW1lbnQuXG4gICAgICAgIGNvbnN0IGltcG9ydE5vZGUgPSAvKiogQHR5cGUgez9Ob2RlfSAqLyAoZWxlbWVudC5pbXBvcnQpO1xuXG4gICAgICAgIGlmIChpbXBvcnROb2RlIGluc3RhbmNlb2YgTm9kZSkge1xuICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9pc0ltcG9ydERvY3VtZW50ID0gdHJ1ZTtcbiAgICAgICAgICAvLyBDb25uZWN0ZWQgbGlua3MgYXJlIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbXBvcnROb2RlICYmIGltcG9ydE5vZGUucmVhZHlTdGF0ZSA9PT0gJ2NvbXBsZXRlJykge1xuICAgICAgICAgIGltcG9ydE5vZGUuX19DRV9kb2N1bWVudExvYWRIYW5kbGVkID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIGxpbmsncyBpbXBvcnQgcm9vdCBpcyBub3QgYXZhaWxhYmxlLCBpdHMgY29udGVudHMgY2FuJ3QgYmVcbiAgICAgICAgICAvLyB3YWxrZWQuIFdhaXQgZm9yICdsb2FkJyBhbmQgd2FsayBpdCB3aGVuIGl0J3MgcmVhZHkuXG4gICAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW1wb3J0Tm9kZSA9IC8qKiBAdHlwZSB7IU5vZGV9ICovIChlbGVtZW50LmltcG9ydCk7XG5cbiAgICAgICAgICAgIGlmIChpbXBvcnROb2RlLl9fQ0VfZG9jdW1lbnRMb2FkSGFuZGxlZCkgcmV0dXJuO1xuICAgICAgICAgICAgaW1wb3J0Tm9kZS5fX0NFX2RvY3VtZW50TG9hZEhhbmRsZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBDbG9uZSB0aGUgYHZpc2l0ZWRJbXBvcnRzYCBzZXQgdGhhdCB3YXMgcG9wdWxhdGVkIHN5bmMgZHVyaW5nXG4gICAgICAgICAgICAvLyB0aGUgYHBhdGNoQW5kVXBncmFkZVRyZWVgIGNhbGwgdGhhdCBjYXVzZWQgdGhpcyAnbG9hZCcgaGFuZGxlciB0b1xuICAgICAgICAgICAgLy8gYmUgYWRkZWQuIFRoZW4sIHJlbW92ZSAqdGhpcyogbGluaydzIGltcG9ydCBub2RlIHNvIHRoYXQgd2UgY2FuXG4gICAgICAgICAgICAvLyB3YWxrIHRoYXQgaW1wb3J0IGFnYWluLCBldmVuIGlmIGl0IHdhcyBwYXJ0aWFsbHkgd2Fsa2VkIGxhdGVyXG4gICAgICAgICAgICAvLyBkdXJpbmcgdGhlIHNhbWUgYHBhdGNoQW5kVXBncmFkZVRyZWVgIGNhbGwuXG4gICAgICAgICAgICBjb25zdCBjbG9uZWRWaXNpdGVkSW1wb3J0cyA9IG5ldyBTZXQodmlzaXRlZEltcG9ydHMpO1xuICAgICAgICAgICAgY2xvbmVkVmlzaXRlZEltcG9ydHMuZGVsZXRlKGltcG9ydE5vZGUpO1xuXG4gICAgICAgICAgICB0aGlzLnBhdGNoQW5kVXBncmFkZVRyZWUoaW1wb3J0Tm9kZSwge3Zpc2l0ZWRJbXBvcnRzOiBjbG9uZWRWaXNpdGVkSW1wb3J0cywgdXBncmFkZX0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBgd2Fsa0RlZXBEZXNjZW5kYW50RWxlbWVudHNgIHBvcHVsYXRlcyAoYW5kIGludGVybmFsbHkgY2hlY2tzIGFnYWluc3QpXG4gICAgLy8gYHZpc2l0ZWRJbXBvcnRzYCB3aGVuIHRyYXZlcnNpbmcgYSBsb2FkZWQgaW1wb3J0LlxuICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyhyb290LCBnYXRoZXJFbGVtZW50cywgdmlzaXRlZEltcG9ydHMpO1xuXG4gICAgaWYgKHRoaXMuX2hhc1BhdGNoZXMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5wYXRjaEVsZW1lbnQoZWxlbWVudHNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZ3JhZGUoZWxlbWVudHNbaV0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgdXBncmFkZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0ZSA9IGVsZW1lbnQuX19DRV9zdGF0ZTtcbiAgICBpZiAoY3VycmVudFN0YXRlICE9PSB1bmRlZmluZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgZWxlbWVudHMgY3JlYXRlZCBpbiBkb2N1bWVudHMgd2l0aG91dCBhIGJyb3dzaW5nIGNvbnRleHQgZnJvbVxuICAgIC8vIHVwZ3JhZGluZy5cbiAgICAvL1xuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2N1c3RvbS1lbGVtZW50cy5odG1sI2xvb2stdXAtYS1jdXN0b20tZWxlbWVudC1kZWZpbml0aW9uXG4gICAgLy8gICBcIklmIGRvY3VtZW50IGRvZXMgbm90IGhhdmUgYSBicm93c2luZyBjb250ZXh0LCByZXR1cm4gbnVsbC5cIlxuICAgIC8vXG4gICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvd2luZG93LW9iamVjdC5odG1sI2RvbS1kb2N1bWVudC1kZWZhdWx0dmlld1xuICAgIC8vICAgXCJUaGUgZGVmYXVsdFZpZXcgSURMIGF0dHJpYnV0ZSBvZiB0aGUgRG9jdW1lbnQgaW50ZXJmYWNlLCBvbiBnZXR0aW5nLFxuICAgIC8vICAgbXVzdCByZXR1cm4gdGhpcyBEb2N1bWVudCdzIGJyb3dzaW5nIGNvbnRleHQncyBXaW5kb3dQcm94eSBvYmplY3QsIGlmXG4gICAgLy8gICB0aGlzIERvY3VtZW50IGhhcyBhbiBhc3NvY2lhdGVkIGJyb3dzaW5nIGNvbnRleHQsIG9yIG51bGwgb3RoZXJ3aXNlLlwiXG4gICAgY29uc3Qgb3duZXJEb2N1bWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudDtcbiAgICBpZiAoXG4gICAgICAhb3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyAmJlxuICAgICAgIShvd25lckRvY3VtZW50Ll9fQ0VfaXNJbXBvcnREb2N1bWVudCAmJiBvd25lckRvY3VtZW50Ll9fQ0VfaGFzUmVnaXN0cnkpXG4gICAgKSByZXR1cm47XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5sb2NhbE5hbWVUb0RlZmluaXRpb24oZWxlbWVudC5sb2NhbE5hbWUpO1xuICAgIGlmICghZGVmaW5pdGlvbikgcmV0dXJuO1xuXG4gICAgZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjay5wdXNoKGVsZW1lbnQpO1xuXG4gICAgY29uc3QgY29uc3RydWN0b3IgPSBkZWZpbml0aW9uLmNvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgdHJ5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBuZXcgKGNvbnN0cnVjdG9yKSgpO1xuICAgICAgICBpZiAocmVzdWx0ICE9PSBlbGVtZW50KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tIGVsZW1lbnQgY29uc3RydWN0b3IgZGlkIG5vdCBwcm9kdWNlIHRoZSBlbGVtZW50IGJlaW5nIHVwZ3JhZGVkLicpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBkZWZpbml0aW9uLmNvbnN0cnVjdGlvblN0YWNrLnBvcCgpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGVsZW1lbnQuX19DRV9zdGF0ZSA9IENFU3RhdGUuZmFpbGVkO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBlbGVtZW50Ll9fQ0Vfc3RhdGUgPSBDRVN0YXRlLmN1c3RvbTtcbiAgICBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbiA9IGRlZmluaXRpb247XG5cbiAgICBpZiAoZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9ic2VydmVkQXR0cmlidXRlcyA9IGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYnNlcnZlZEF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IG9ic2VydmVkQXR0cmlidXRlc1tpXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgbnVsbCwgdmFsdWUsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChlbGVtZW50KSkge1xuICAgICAgdGhpcy5jb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gZWxlbWVudFxuICAgKi9cbiAgY29ubmVjdGVkQ2FsbGJhY2soZWxlbWVudCkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSBlbGVtZW50Ll9fQ0VfZGVmaW5pdGlvbjtcbiAgICBpZiAoZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjaykge1xuICAgICAgZGVmaW5pdGlvbi5jb25uZWN0ZWRDYWxsYmFjay5jYWxsKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAqL1xuICBkaXNjb25uZWN0ZWRDYWxsYmFjayhlbGVtZW50KSB7XG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IGVsZW1lbnQuX19DRV9kZWZpbml0aW9uO1xuICAgIGlmIChkZWZpbml0aW9uLmRpc2Nvbm5lY3RlZENhbGxiYWNrKSB7XG4gICAgICBkZWZpbml0aW9uLmRpc2Nvbm5lY3RlZENhbGxiYWNrLmNhbGwoZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUVsZW1lbnR9IGVsZW1lbnRcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHs/c3RyaW5nfSBvbGRWYWx1ZVxuICAgKiBAcGFyYW0gez9zdHJpbmd9IG5ld1ZhbHVlXG4gICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAqL1xuICBhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2soZWxlbWVudCwgbmFtZSwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBkZWZpbml0aW9uID0gZWxlbWVudC5fX0NFX2RlZmluaXRpb247XG4gICAgaWYgKFxuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2sgJiZcbiAgICAgIGRlZmluaXRpb24ub2JzZXJ2ZWRBdHRyaWJ1dGVzLmluZGV4T2YobmFtZSkgPiAtMVxuICAgICkge1xuICAgICAgZGVmaW5pdGlvbi5hdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2suY2FsbChlbGVtZW50LCBuYW1lLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIG5hbWVzcGFjZSk7XG4gICAgfVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciB7XG4gIGNvbnN0cnVjdG9yKGludGVybmFscywgZG9jKSB7XG4gICAgLyoqXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHshRG9jdW1lbnR9XG4gICAgICovXG4gICAgdGhpcy5fZG9jdW1lbnQgPSBkb2M7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSB7TXV0YXRpb25PYnNlcnZlcnx1bmRlZmluZWR9XG4gICAgICovXG4gICAgdGhpcy5fb2JzZXJ2ZXIgPSB1bmRlZmluZWQ7XG5cblxuICAgIC8vIFNpbXVsYXRlIHRyZWUgY29uc3RydWN0aW9uIGZvciBhbGwgY3VycmVudGx5IGFjY2Vzc2libGUgbm9kZXMgaW4gdGhlXG4gICAgLy8gZG9jdW1lbnQuXG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUodGhpcy5fZG9jdW1lbnQpO1xuXG4gICAgaWYgKHRoaXMuX2RvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdsb2FkaW5nJykge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcih0aGlzLl9oYW5kbGVNdXRhdGlvbnMuYmluZCh0aGlzKSk7XG5cbiAgICAgIC8vIE5vZGVzIGNyZWF0ZWQgYnkgdGhlIHBhcnNlciBhcmUgZ2l2ZW4gdG8gdGhlIG9ic2VydmVyICpiZWZvcmUqIHRoZSBuZXh0XG4gICAgICAvLyB0YXNrIHJ1bnMuIElubGluZSBzY3JpcHRzIGFyZSBydW4gaW4gYSBuZXcgdGFzay4gVGhpcyBtZWFucyB0aGF0IHRoZVxuICAgICAgLy8gb2JzZXJ2ZXIgd2lsbCBiZSBhYmxlIHRvIGhhbmRsZSB0aGUgbmV3bHkgcGFyc2VkIG5vZGVzIGJlZm9yZSB0aGUgaW5saW5lXG4gICAgICAvLyBzY3JpcHQgaXMgcnVuLlxuICAgICAgdGhpcy5fb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLl9kb2N1bWVudCwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICBkaXNjb25uZWN0KCkge1xuICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFBcnJheTwhTXV0YXRpb25SZWNvcmQ+fSBtdXRhdGlvbnNcbiAgICovXG4gIF9oYW5kbGVNdXRhdGlvbnMobXV0YXRpb25zKSB7XG4gICAgLy8gT25jZSB0aGUgZG9jdW1lbnQncyBgcmVhZHlTdGF0ZWAgaXMgJ2ludGVyYWN0aXZlJyBvciAnY29tcGxldGUnLCBhbGwgbmV3XG4gICAgLy8gbm9kZXMgY3JlYXRlZCB3aXRoaW4gdGhhdCBkb2N1bWVudCB3aWxsIGJlIHRoZSByZXN1bHQgb2Ygc2NyaXB0IGFuZFxuICAgIC8vIHNob3VsZCBiZSBoYW5kbGVkIGJ5IHBhdGNoaW5nLlxuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLl9kb2N1bWVudC5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAnaW50ZXJhY3RpdmUnIHx8IHJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbXV0YXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBhZGRlZE5vZGVzID0gbXV0YXRpb25zW2ldLmFkZGVkTm9kZXM7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGFkZGVkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGFkZGVkTm9kZXNbal07XG4gICAgICAgIHRoaXMuX2ludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbi8qKlxuICogQHRlbXBsYXRlIFRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGVmZXJyZWQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtUfHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge0Z1bmN0aW9ufHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICB0aGlzLl9yZXNvbHZlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IVByb21pc2U8VD59XG4gICAgICovXG4gICAgdGhpcy5fcHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgdGhpcy5fcmVzb2x2ZSA9IHJlc29sdmU7XG5cbiAgICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgICByZXNvbHZlKHRoaXMuX3ZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1R9IHZhbHVlXG4gICAqL1xuICByZXNvbHZlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FscmVhZHkgcmVzb2x2ZWQuJyk7XG4gICAgfVxuXG4gICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICh0aGlzLl9yZXNvbHZlKSB7XG4gICAgICB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IVByb21pc2U8VD59XG4gICAqL1xuICB0b1Byb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2U7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0IERvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXIgZnJvbSAnLi9Eb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyLmpzJztcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHVucmVzdHJpY3RlZFxuICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXN0b21FbGVtZW50UmVnaXN0cnkge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAgICovXG4gIGNvbnN0cnVjdG9yKGludGVybmFscykge1xuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICovXG4gICAgdGhpcy5fZWxlbWVudERlZmluaXRpb25Jc1J1bm5pbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfVxuICAgICAqL1xuICAgIHRoaXMuX2ludGVybmFscyA9IGludGVybmFscztcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFNYXA8c3RyaW5nLCAhRGVmZXJyZWQ8dW5kZWZpbmVkPj59XG4gICAgICovXG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZCA9IG5ldyBNYXAoKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBkZWZhdWx0IGZsdXNoIGNhbGxiYWNrIHRyaWdnZXJzIHRoZSBkb2N1bWVudCB3YWxrIHN5bmNocm9ub3VzbHkuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IUZ1bmN0aW9ufVxuICAgICAqL1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmbiA9PiBmbigpO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSBmYWxzZTtcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUgeyFBcnJheTwhQ3VzdG9tRWxlbWVudERlZmluaXRpb24+fVxuICAgICAqL1xuICAgIHRoaXMuX3BlbmRpbmdEZWZpbml0aW9ucyA9IFtdO1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAdHlwZSB7IURvY3VtZW50Q29uc3RydWN0aW9uT2JzZXJ2ZXJ9XG4gICAgICovXG4gICAgdGhpcy5fZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlciA9IG5ldyBEb2N1bWVudENvbnN0cnVjdGlvbk9ic2VydmVyKGludGVybmFscywgZG9jdW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGNvbnN0cnVjdG9yXG4gICAqL1xuICBkZWZpbmUobG9jYWxOYW1lLCBjb25zdHJ1Y3Rvcikge1xuICAgIGlmICghKGNvbnN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvcnMgbXVzdCBiZSBmdW5jdGlvbnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsaXRpZXMuaXNWYWxpZEN1c3RvbUVsZW1lbnROYW1lKGxvY2FsTmFtZSkpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIGVsZW1lbnQgbmFtZSAnJHtsb2NhbE5hbWV9JyBpcyBub3QgdmFsaWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ludGVybmFscy5sb2NhbE5hbWVUb0RlZmluaXRpb24obG9jYWxOYW1lKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBBIGN1c3RvbSBlbGVtZW50IHdpdGggbmFtZSAnJHtsb2NhbE5hbWV9JyBoYXMgYWxyZWFkeSBiZWVuIGRlZmluZWQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY3VzdG9tIGVsZW1lbnQgaXMgYWxyZWFkeSBiZWluZyBkZWZpbmVkLicpO1xuICAgIH1cbiAgICB0aGlzLl9lbGVtZW50RGVmaW5pdGlvbklzUnVubmluZyA9IHRydWU7XG5cbiAgICBsZXQgY29ubmVjdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGRpc2Nvbm5lY3RlZENhbGxiYWNrO1xuICAgIGxldCBhZG9wdGVkQ2FsbGJhY2s7XG4gICAgbGV0IGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjaztcbiAgICBsZXQgb2JzZXJ2ZWRBdHRyaWJ1dGVzO1xuICAgIHRyeSB7XG4gICAgICAvKiogQHR5cGUgeyFPYmplY3R9ICovXG4gICAgICBjb25zdCBwcm90b3R5cGUgPSBjb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gICAgICBpZiAoIShwcm90b3R5cGUgaW5zdGFuY2VvZiBPYmplY3QpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjdXN0b20gZWxlbWVudCBjb25zdHJ1Y3RvclxcJ3MgcHJvdG90eXBlIGlzIG5vdCBhbiBvYmplY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGdldENhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tWYWx1ZSA9IHByb3RvdHlwZVtuYW1lXTtcbiAgICAgICAgaWYgKGNhbGxiYWNrVmFsdWUgIT09IHVuZGVmaW5lZCAmJiAhKGNhbGxiYWNrVmFsdWUgaW5zdGFuY2VvZiBGdW5jdGlvbikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSAnJHtuYW1lfScgY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja1ZhbHVlO1xuICAgICAgfVxuXG4gICAgICBjb25uZWN0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdjb25uZWN0ZWRDYWxsYmFjaycpO1xuICAgICAgZGlzY29ubmVjdGVkQ2FsbGJhY2sgPSBnZXRDYWxsYmFjaygnZGlzY29ubmVjdGVkQ2FsbGJhY2snKTtcbiAgICAgIGFkb3B0ZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdhZG9wdGVkQ2FsbGJhY2snKTtcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayA9IGdldENhbGxiYWNrKCdhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2snKTtcbiAgICAgIG9ic2VydmVkQXR0cmlidXRlcyA9IGNvbnN0cnVjdG9yWydvYnNlcnZlZEF0dHJpYnV0ZXMnXSB8fCBbXTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX2VsZW1lbnREZWZpbml0aW9uSXNSdW5uaW5nID0gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgZGVmaW5pdGlvbiA9IHtcbiAgICAgIGxvY2FsTmFtZSxcbiAgICAgIGNvbnN0cnVjdG9yRnVuY3Rpb246IGNvbnN0cnVjdG9yLFxuICAgICAgY29ubmVjdGVkQ2FsbGJhY2ssXG4gICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjayxcbiAgICAgIGFkb3B0ZWRDYWxsYmFjayxcbiAgICAgIGF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayxcbiAgICAgIG9ic2VydmVkQXR0cmlidXRlcyxcbiAgICAgIGNvbnN0cnVjdGlvblN0YWNrOiBbXSxcbiAgICB9O1xuXG4gICAgdGhpcy5faW50ZXJuYWxzLnNldERlZmluaXRpb24obG9jYWxOYW1lLCBkZWZpbml0aW9uKTtcbiAgICB0aGlzLl9wZW5kaW5nRGVmaW5pdGlvbnMucHVzaChkZWZpbml0aW9uKTtcblxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgY2FsbGVkIHRoZSBmbHVzaCBjYWxsYmFjayBhbmQgaXQgaGFzbid0IGNhbGxlZCBiYWNrIHlldCxcbiAgICAvLyBkb24ndCBjYWxsIGl0IGFnYWluLlxuICAgIGlmICghdGhpcy5fZmx1c2hQZW5kaW5nKSB7XG4gICAgICB0aGlzLl9mbHVzaFBlbmRpbmcgPSB0cnVlO1xuICAgICAgdGhpcy5fZmx1c2hDYWxsYmFjaygoKSA9PiB0aGlzLl9mbHVzaCgpKTtcbiAgICB9XG4gIH1cblxuICB1cGdyYWRlKGVsZW1lbnQpIHtcbiAgICB0aGlzLl9pbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShlbGVtZW50KTtcbiAgfVxuXG4gIF9mbHVzaCgpIHtcbiAgICAvLyBJZiBubyBuZXcgZGVmaW5pdGlvbnMgd2VyZSBkZWZpbmVkLCBkb24ndCBhdHRlbXB0IHRvIGZsdXNoLiBUaGlzIGNvdWxkXG4gICAgLy8gaGFwcGVuIGlmIGEgZmx1c2ggY2FsbGJhY2sga2VlcHMgdGhlIGZ1bmN0aW9uIGl0IGlzIGdpdmVuIGFuZCBjYWxscyBpdFxuICAgIC8vIG11bHRpcGxlIHRpbWVzLlxuICAgIGlmICh0aGlzLl9mbHVzaFBlbmRpbmcgPT09IGZhbHNlKSByZXR1cm47XG4gICAgdGhpcy5fZmx1c2hQZW5kaW5nID0gZmFsc2U7XG5cbiAgICBjb25zdCBwZW5kaW5nRGVmaW5pdGlvbnMgPSB0aGlzLl9wZW5kaW5nRGVmaW5pdGlvbnM7XG5cbiAgICAvKipcbiAgICAgKiBVbnVwZ3JhZGVkIGVsZW1lbnRzIHdpdGggZGVmaW5pdGlvbnMgdGhhdCB3ZXJlIGRlZmluZWQgKmJlZm9yZSogdGhlIGxhc3RcbiAgICAgKiBmbHVzaCwgaW4gZG9jdW1lbnQgb3JkZXIuXG4gICAgICogQHR5cGUgeyFBcnJheTwhSFRNTEVsZW1lbnQ+fVxuICAgICAqL1xuICAgIGNvbnN0IGVsZW1lbnRzV2l0aFN0YWJsZURlZmluaXRpb25zID0gW107XG5cbiAgICAvKipcbiAgICAgKiBBIG1hcCBmcm9tIGBsb2NhbE5hbWVgcyBvZiBkZWZpbml0aW9ucyB0aGF0IHdlcmUgZGVmaW5lZCAqYWZ0ZXIqIHRoZSBsYXN0XG4gICAgICogZmx1c2ggdG8gdW51cGdyYWRlZCBlbGVtZW50cyBtYXRjaGluZyB0aGF0IGRlZmluaXRpb24sIGluIGRvY3VtZW50IG9yZGVyLlxuICAgICAqIEB0eXBlIHshTWFwPHN0cmluZywgIUFycmF5PCFIVE1MRWxlbWVudD4+fVxuICAgICAqL1xuICAgIGNvbnN0IGVsZW1lbnRzV2l0aFBlbmRpbmdEZWZpbml0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBlbmRpbmdEZWZpbml0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgZWxlbWVudHNXaXRoUGVuZGluZ0RlZmluaXRpb25zLnNldChwZW5kaW5nRGVmaW5pdGlvbnNbaV0ubG9jYWxOYW1lLCBbXSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoZG9jdW1lbnQsIHtcbiAgICAgIHVwZ3JhZGU6IGVsZW1lbnQgPT4ge1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGVsZW1lbnQgaWYgaXQgaGFzIGFscmVhZHkgdXBncmFkZWQgb3IgZmFpbGVkIHRvIHVwZ3JhZGUuXG4gICAgICAgIGlmIChlbGVtZW50Ll9fQ0Vfc3RhdGUgIT09IHVuZGVmaW5lZCkgcmV0dXJuO1xuXG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IGVsZW1lbnQubG9jYWxOYW1lO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFuIGFwcGxpY2FibGUgcGVuZGluZyBkZWZpbml0aW9uIGZvciB0aGUgZWxlbWVudCwgYWRkIHRoZVxuICAgICAgICAvLyBlbGVtZW50IHRvIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHRvIGJlIHVwZ3JhZGVkIHdpdGggdGhhdCBkZWZpbml0aW9uLlxuICAgICAgICBjb25zdCBwZW5kaW5nRWxlbWVudHMgPSBlbGVtZW50c1dpdGhQZW5kaW5nRGVmaW5pdGlvbnMuZ2V0KGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChwZW5kaW5nRWxlbWVudHMpIHtcbiAgICAgICAgICBwZW5kaW5nRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgLy8gSWYgdGhlcmUgaXMgKmFueSBvdGhlciogYXBwbGljYWJsZSBkZWZpbml0aW9uIGZvciB0aGUgZWxlbWVudCwgYWRkIGl0XG4gICAgICAgIC8vIHRvIHRoZSBsaXN0IG9mIGVsZW1lbnRzIHdpdGggc3RhYmxlIGRlZmluaXRpb25zIHRoYXQgbmVlZCB0byBiZSB1cGdyYWRlZC5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSkpIHtcbiAgICAgICAgICBlbGVtZW50c1dpdGhTdGFibGVEZWZpbml0aW9ucy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gVXBncmFkZSBlbGVtZW50cyB3aXRoICdzdGFibGUnIGRlZmluaXRpb25zIGZpcnN0LlxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZWxlbWVudHNXaXRoU3RhYmxlRGVmaW5pdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMuX2ludGVybmFscy51cGdyYWRlRWxlbWVudChlbGVtZW50c1dpdGhTdGFibGVEZWZpbml0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gVXBncmFkZSBlbGVtZW50cyB3aXRoICdwZW5kaW5nJyBkZWZpbml0aW9ucyBpbiB0aGUgb3JkZXIgdGhleSB3ZXJlIGRlZmluZWQuXG4gICAgd2hpbGUgKHBlbmRpbmdEZWZpbml0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBkZWZpbml0aW9uID0gcGVuZGluZ0RlZmluaXRpb25zLnNoaWZ0KCk7XG4gICAgICBjb25zdCBsb2NhbE5hbWUgPSBkZWZpbml0aW9uLmxvY2FsTmFtZTtcblxuICAgICAgLy8gQXR0ZW1wdCB0byB1cGdyYWRlIGFsbCBhcHBsaWNhYmxlIGVsZW1lbnRzLlxuICAgICAgY29uc3QgcGVuZGluZ1VwZ3JhZGFibGVFbGVtZW50cyA9IGVsZW1lbnRzV2l0aFBlbmRpbmdEZWZpbml0aW9ucy5nZXQoZGVmaW5pdGlvbi5sb2NhbE5hbWUpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwZW5kaW5nVXBncmFkYWJsZUVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2ludGVybmFscy51cGdyYWRlRWxlbWVudChwZW5kaW5nVXBncmFkYWJsZUVsZW1lbnRzW2ldKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzb2x2ZSBhbnkgcHJvbWlzZXMgY3JlYXRlZCBieSBgd2hlbkRlZmluZWRgIGZvciB0aGUgZGVmaW5pdGlvbi5cbiAgICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5nZXQobG9jYWxOYW1lKTtcbiAgICAgIGlmIChkZWZlcnJlZCkge1xuICAgICAgICBkZWZlcnJlZC5yZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICogQHJldHVybiB7RnVuY3Rpb258dW5kZWZpbmVkfVxuICAgKi9cbiAgZ2V0KGxvY2FsTmFtZSkge1xuICAgIGNvbnN0IGRlZmluaXRpb24gPSB0aGlzLl9pbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgIHJldHVybiBkZWZpbml0aW9uLmNvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgfVxuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAqIEByZXR1cm4geyFQcm9taXNlPHVuZGVmaW5lZD59XG4gICAqL1xuICB3aGVuRGVmaW5lZChsb2NhbE5hbWUpIHtcbiAgICBpZiAoIVV0aWxpdGllcy5pc1ZhbGlkQ3VzdG9tRWxlbWVudE5hbWUobG9jYWxOYW1lKSkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBTeW50YXhFcnJvcihgJyR7bG9jYWxOYW1lfScgaXMgbm90IGEgdmFsaWQgY3VzdG9tIGVsZW1lbnQgbmFtZS5gKSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpb3IgPSB0aGlzLl93aGVuRGVmaW5lZERlZmVycmVkLmdldChsb2NhbE5hbWUpO1xuICAgIGlmIChwcmlvcikge1xuICAgICAgcmV0dXJuIHByaW9yLnRvUHJvbWlzZSgpO1xuICAgIH1cblxuICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgdGhpcy5fd2hlbkRlZmluZWREZWZlcnJlZC5zZXQobG9jYWxOYW1lLCBkZWZlcnJlZCk7XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gdGhpcy5faW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgIC8vIFJlc29sdmUgaW1tZWRpYXRlbHkgb25seSBpZiB0aGUgZ2l2ZW4gbG9jYWwgbmFtZSBoYXMgYSBkZWZpbml0aW9uICphbmQqXG4gICAgLy8gdGhlIGZ1bGwgZG9jdW1lbnQgd2FsayB0byB1cGdyYWRlIGVsZW1lbnRzIHdpdGggdGhhdCBsb2NhbCBuYW1lIGhhc1xuICAgIC8vIGFscmVhZHkgaGFwcGVuZWQuXG4gICAgaWYgKGRlZmluaXRpb24gJiYgIXRoaXMuX3BlbmRpbmdEZWZpbml0aW9ucy5zb21lKGQgPT4gZC5sb2NhbE5hbWUgPT09IGxvY2FsTmFtZSkpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmZXJyZWQudG9Qcm9taXNlKCk7XG4gIH1cblxuICBwb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrKG91dGVyKSB7XG4gICAgdGhpcy5fZG9jdW1lbnRDb25zdHJ1Y3Rpb25PYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgY29uc3QgaW5uZXIgPSB0aGlzLl9mbHVzaENhbGxiYWNrO1xuICAgIHRoaXMuX2ZsdXNoQ2FsbGJhY2sgPSBmbHVzaCA9PiBvdXRlcigoKSA9PiBpbm5lcihmbHVzaCkpO1xuICB9XG59XG5cbi8vIENsb3N1cmUgY29tcGlsZXIgZXhwb3J0cy5cbndpbmRvd1snQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5J10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnk7XG5DdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlWydkZWZpbmUnXSA9IEN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGUuZGVmaW5lO1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsndXBncmFkZSddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS51cGdyYWRlO1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsnZ2V0J10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLmdldDtcbkN1c3RvbUVsZW1lbnRSZWdpc3RyeS5wcm90b3R5cGVbJ3doZW5EZWZpbmVkJ10gPSBDdXN0b21FbGVtZW50UmVnaXN0cnkucHJvdG90eXBlLndoZW5EZWZpbmVkO1xuQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZVsncG9seWZpbGxXcmFwRmx1c2hDYWxsYmFjayddID0gQ3VzdG9tRWxlbWVudFJlZ2lzdHJ5LnByb3RvdHlwZS5wb2x5ZmlsbFdyYXBGbHVzaENhbGxiYWNrO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgRG9jdW1lbnRfY3JlYXRlRWxlbWVudDogd2luZG93LkRvY3VtZW50LnByb3RvdHlwZS5jcmVhdGVFbGVtZW50LFxuICBEb2N1bWVudF9jcmVhdGVFbGVtZW50TlM6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGUuY3JlYXRlRWxlbWVudE5TLFxuICBEb2N1bWVudF9pbXBvcnROb2RlOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlLmltcG9ydE5vZGUsXG4gIERvY3VtZW50X3ByZXBlbmQ6IHdpbmRvdy5Eb2N1bWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRG9jdW1lbnRfYXBwZW5kOiB3aW5kb3cuRG9jdW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcbiAgRG9jdW1lbnRGcmFnbWVudF9wcmVwZW5kOiB3aW5kb3cuRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGVbJ3ByZXBlbmQnXSxcbiAgRG9jdW1lbnRGcmFnbWVudF9hcHBlbmQ6IHdpbmRvdy5Eb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZVsnYXBwZW5kJ10sXG4gIE5vZGVfY2xvbmVOb2RlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuY2xvbmVOb2RlLFxuICBOb2RlX2FwcGVuZENoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuYXBwZW5kQ2hpbGQsXG4gIE5vZGVfaW5zZXJ0QmVmb3JlOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUuaW5zZXJ0QmVmb3JlLFxuICBOb2RlX3JlbW92ZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ2hpbGQsXG4gIE5vZGVfcmVwbGFjZUNoaWxkOiB3aW5kb3cuTm9kZS5wcm90b3R5cGUucmVwbGFjZUNoaWxkLFxuICBOb2RlX3RleHRDb250ZW50OiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5Ob2RlLnByb3RvdHlwZSwgJ3RleHRDb250ZW50JyksXG4gIEVsZW1lbnRfYXR0YWNoU2hhZG93OiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2F0dGFjaFNoYWRvdyddLFxuICBFbGVtZW50X2lubmVySFRNTDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5nZXRBdHRyaWJ1dGUsXG4gIEVsZW1lbnRfc2V0QXR0cmlidXRlOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlLFxuICBFbGVtZW50X3JlbW92ZUF0dHJpYnV0ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLnJlbW92ZUF0dHJpYnV0ZSxcbiAgRWxlbWVudF9nZXRBdHRyaWJ1dGVOUzogd2luZG93LkVsZW1lbnQucHJvdG90eXBlLmdldEF0dHJpYnV0ZU5TLFxuICBFbGVtZW50X3NldEF0dHJpYnV0ZU5TOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGUuc2V0QXR0cmlidXRlTlMsXG4gIEVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlM6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZS5yZW1vdmVBdHRyaWJ1dGVOUyxcbiAgRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnaW5zZXJ0QWRqYWNlbnRFbGVtZW50J10sXG4gIEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MOiB3aW5kb3cuRWxlbWVudC5wcm90b3R5cGVbJ2luc2VydEFkamFjZW50SFRNTCddLFxuICBFbGVtZW50X3ByZXBlbmQ6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsncHJlcGVuZCddLFxuICBFbGVtZW50X2FwcGVuZDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydhcHBlbmQnXSxcbiAgRWxlbWVudF9iZWZvcmU6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYmVmb3JlJ10sXG4gIEVsZW1lbnRfYWZ0ZXI6IHdpbmRvdy5FbGVtZW50LnByb3RvdHlwZVsnYWZ0ZXInXSxcbiAgRWxlbWVudF9yZXBsYWNlV2l0aDogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydyZXBsYWNlV2l0aCddLFxuICBFbGVtZW50X3JlbW92ZTogd2luZG93LkVsZW1lbnQucHJvdG90eXBlWydyZW1vdmUnXSxcbiAgSFRNTEVsZW1lbnQ6IHdpbmRvdy5IVE1MRWxlbWVudCxcbiAgSFRNTEVsZW1lbnRfaW5uZXJIVE1MOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5IVE1MRWxlbWVudC5wcm90b3R5cGUsICdpbm5lckhUTUwnKSxcbiAgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50OiB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEVsZW1lbnQnXSxcbiAgSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MOiB3aW5kb3cuSFRNTEVsZW1lbnQucHJvdG90eXBlWydpbnNlcnRBZGphY2VudEhUTUwnXSxcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuLyoqXG4gKiBUaGlzIGNsYXNzIGV4aXN0cyBvbmx5IHRvIHdvcmsgYXJvdW5kIENsb3N1cmUncyBsYWNrIG9mIGEgd2F5IHRvIGRlc2NyaWJlXG4gKiBzaW5nbGV0b25zLiBJdCByZXByZXNlbnRzIHRoZSAnYWxyZWFkeSBjb25zdHJ1Y3RlZCBtYXJrZXInIHVzZWQgaW4gY3VzdG9tXG4gKiBlbGVtZW50IGNvbnN0cnVjdGlvbiBzdGFja3MuXG4gKlxuICogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1hbHJlYWR5LWNvbnN0cnVjdGVkLW1hcmtlclxuICogQGV4dGVuZHMgQWxyZWFkeUNvbnN0cnVjdGVkTWFya2VyVHlwZVxuICovXG5jbGFzcyBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIge31cblxuZXhwb3J0IGRlZmF1bHQgbmV3IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlcigpO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0IEFscmVhZHlDb25zdHJ1Y3RlZE1hcmtlciBmcm9tICcuLi9BbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgd2luZG93WydIVE1MRWxlbWVudCddID0gKGZ1bmN0aW9uKCkge1xuICAgIC8qKlxuICAgICAqIEB0eXBlIHtmdW5jdGlvbihuZXc6IEhUTUxFbGVtZW50KTogIUhUTUxFbGVtZW50fVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIEhUTUxFbGVtZW50KCkge1xuICAgICAgLy8gVGhpcyBzaG91bGQgcmVhbGx5IGJlIGBuZXcudGFyZ2V0YCBidXQgYG5ldy50YXJnZXRgIGNhbid0IGJlIGVtdWxhdGVkXG4gICAgICAvLyBpbiBFUzUuIEFzc3VtaW5nIHRoZSB1c2VyIGtlZXBzIHRoZSBkZWZhdWx0IHZhbHVlIG9mIHRoZSBjb25zdHJ1Y3RvcidzXG4gICAgICAvLyBwcm90b3R5cGUncyBgY29uc3RydWN0b3JgIHByb3BlcnR5LCB0aGlzIGlzIGVxdWl2YWxlbnQuXG4gICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IC8qKiBAdHlwZSB7IUZ1bmN0aW9ufSAqLyAodGhpcy5jb25zdHJ1Y3Rvcik7XG5cbiAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMuY29uc3RydWN0b3JUb0RlZmluaXRpb24oY29uc3RydWN0b3IpO1xuICAgICAgaWYgKCFkZWZpbml0aW9uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbSBlbGVtZW50IGJlaW5nIGNvbnN0cnVjdGVkIHdhcyBub3QgcmVnaXN0ZXJlZCB3aXRoIGBjdXN0b21FbGVtZW50c2AuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNvbnN0cnVjdGlvblN0YWNrID0gZGVmaW5pdGlvbi5jb25zdHJ1Y3Rpb25TdGFjaztcblxuICAgICAgaWYgKGNvbnN0cnVjdGlvblN0YWNrLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovIChOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudC5jYWxsKGRvY3VtZW50LCBkZWZpbml0aW9uLmxvY2FsTmFtZSkpO1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoZWxlbWVudCwgY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgZWxlbWVudC5fX0NFX3N0YXRlID0gQ0VTdGF0ZS5jdXN0b207XG4gICAgICAgIGVsZW1lbnQuX19DRV9kZWZpbml0aW9uID0gZGVmaW5pdGlvbjtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGxhc3RJbmRleCA9IGNvbnN0cnVjdGlvblN0YWNrLmxlbmd0aCAtIDE7XG4gICAgICBjb25zdCBlbGVtZW50ID0gY29uc3RydWN0aW9uU3RhY2tbbGFzdEluZGV4XTtcbiAgICAgIGlmIChlbGVtZW50ID09PSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgSFRNTEVsZW1lbnQgY29uc3RydWN0b3Igd2FzIGVpdGhlciBjYWxsZWQgcmVlbnRyYW50bHkgZm9yIHRoaXMgY29uc3RydWN0b3Igb3IgY2FsbGVkIG11bHRpcGxlIHRpbWVzLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9Db25zdHJ1Y3RFbGVtZW50ID0gLyoqIEB0eXBlIHshSFRNTEVsZW1lbnR9ICovIChlbGVtZW50KTtcbiAgICAgIGNvbnN0cnVjdGlvblN0YWNrW2xhc3RJbmRleF0gPSBBbHJlYWR5Q29uc3RydWN0ZWRNYXJrZXI7XG5cbiAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0b0NvbnN0cnVjdEVsZW1lbnQsIGNvbnN0cnVjdG9yLnByb3RvdHlwZSk7XG4gICAgICBpbnRlcm5hbHMucGF0Y2hFbGVtZW50KHRvQ29uc3RydWN0RWxlbWVudCk7XG5cbiAgICAgIHJldHVybiB0b0NvbnN0cnVjdEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgSFRNTEVsZW1lbnQucHJvdG90eXBlID0gTmF0aXZlLkhUTUxFbGVtZW50LnByb3RvdHlwZTtcbiAgICAvLyBTYWZhcmkgOSBoYXMgYHdyaXRhYmxlOiBmYWxzZWAgb24gdGhlIHByb3BlcnR5RGVzY3JpcHRvclxuICAgIC8vIE1ha2UgaXQgd3JpdGFibGUgc28gdGhhdCBUeXBlU2NyaXB0IGNhbiBwYXRjaCB1cCB0aGVcbiAgICAvLyBjb25zdHJ1Y3RvciBpbiB0aGUgRVM1IGNvbXBpbGVkIGNvZGUuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBIVE1MRWxlbWVudFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIEhUTUxFbGVtZW50O1xuICB9KSgpO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi8uLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi8uLi9VdGlsaXRpZXMuanMnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHt7XG4gKiAgIHByZXBlbmQ6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gICogIGFwcGVuZDogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqIH19XG4gKi9cbmxldCBQYXJlbnROb2RlTmF0aXZlTWV0aG9kcztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7IVBhcmVudE5vZGVOYXRpdmVNZXRob2RzfSBidWlsdEluXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscywgZGVzdGluYXRpb24sIGJ1aWx0SW4pIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7IWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKX0gYnVpbHRJbk1ldGhvZFxuICAgKiBAcmV0dXJuIHshZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpfVxuICAgKi9cbiAgZnVuY3Rpb24gYXBwZW5kUHJlcGVuZFBhdGNoKGJ1aWx0SW5NZXRob2QpIHtcbiAgICByZXR1cm4gLyoqIEB0aGlzIHshTm9kZX0gKi8gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBjb3B5IG9mIGBub2Rlc2AsIHdpdGggYW55IERvY3VtZW50RnJhZ21lbnQgcmVwbGFjZWQgYnkgaXRzIGNoaWxkcmVuLlxuICAgICAgICogQHR5cGUgeyFBcnJheTwhTm9kZT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZsYXR0ZW5lZE5vZGVzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogRWxlbWVudHMgaW4gYG5vZGVzYCB0aGF0IHdlcmUgY29ubmVjdGVkIGJlZm9yZSB0aGlzIGNhbGwuXG4gICAgICAgKiBAdHlwZSB7IUFycmF5PCFOb2RlPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY29ubmVjdGVkRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKSkge1xuICAgICAgICAgIGNvbm5lY3RlZEVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ1aWx0SW5NZXRob2QuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRFbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGF0dGVuZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBmbGF0dGVuZWROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKGJ1aWx0SW4ucHJlcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCAncHJlcGVuZCcsIGFwcGVuZFByZXBlbmRQYXRjaChidWlsdEluLnByZXBlbmQpKTtcbiAgfVxuXG4gIGlmIChidWlsdEluLmFwcGVuZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCAnYXBwZW5kJywgYXBwZW5kUHJlcGVuZFBhdGNoKGJ1aWx0SW4uYXBwZW5kKSk7XG4gIH1cbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuaW1wb3J0IE5hdGl2ZSBmcm9tICcuL05hdGl2ZS5qcyc7XG5pbXBvcnQgQ3VzdG9tRWxlbWVudEludGVybmFscyBmcm9tICcuLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCAqIGFzIFV0aWxpdGllcyBmcm9tICcuLi9VdGlsaXRpZXMuanMnO1xuXG5pbXBvcnQgUGF0Y2hQYXJlbnROb2RlIGZyb20gJy4vSW50ZXJmYWNlL1BhcmVudE5vZGUuanMnO1xuXG4vKipcbiAqIEBwYXJhbSB7IUN1c3RvbUVsZW1lbnRJbnRlcm5hbHN9IGludGVybmFsc1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbihpbnRlcm5hbHMpIHtcbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2NyZWF0ZUVsZW1lbnQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYWxOYW1lXG4gICAgICogQHJldHVybiB7IUVsZW1lbnR9XG4gICAgICovXG4gICAgZnVuY3Rpb24obG9jYWxOYW1lKSB7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKHRoaXMuX19DRV9oYXNSZWdpc3RyeSkge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gaW50ZXJuYWxzLmxvY2FsTmFtZVRvRGVmaW5pdGlvbihsb2NhbE5hbWUpO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbikge1xuICAgICAgICAgIHJldHVybiBuZXcgKGRlZmluaXRpb24uY29uc3RydWN0b3JGdW5jdGlvbikoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCByZXN1bHQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAoTmF0aXZlLkRvY3VtZW50X2NyZWF0ZUVsZW1lbnQuY2FsbCh0aGlzLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaEVsZW1lbnQocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKERvY3VtZW50LnByb3RvdHlwZSwgJ2ltcG9ydE5vZGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHBhcmFtIHtib29sZWFuPX0gZGVlcFxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUsIGRlZXApIHtcbiAgICAgIGNvbnN0IGNsb25lID0gLyoqIEB0eXBlIHshTm9kZX0gKi8gKE5hdGl2ZS5Eb2N1bWVudF9pbXBvcnROb2RlLmNhbGwodGhpcywgbm9kZSwgISFkZWVwKSk7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBkb2N1bWVudCBpcyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgaWYgKCF0aGlzLl9fQ0VfaGFzUmVnaXN0cnkpIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZShjbG9uZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZShjbG9uZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmU7XG4gICAgfSk7XG5cbiAgY29uc3QgTlNfSFRNTCA9IFwiaHR0cDovL3d3dy53My5vcmcvMTk5OS94aHRtbFwiO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChEb2N1bWVudC5wcm90b3R5cGUsICdjcmVhdGVFbGVtZW50TlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtEb2N1bWVudH1cbiAgICAgKiBAcGFyYW0gez9zdHJpbmd9IG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhbE5hbWVcbiAgICAgKiBAcmV0dXJuIHshRWxlbWVudH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIGxvY2FsTmFtZSkge1xuICAgICAgLy8gT25seSBjcmVhdGUgY3VzdG9tIGVsZW1lbnRzIGlmIHRoaXMgZG9jdW1lbnQgaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSByZWdpc3RyeS5cbiAgICAgIGlmICh0aGlzLl9fQ0VfaGFzUmVnaXN0cnkgJiYgKG5hbWVzcGFjZSA9PT0gbnVsbCB8fCBuYW1lc3BhY2UgPT09IE5TX0hUTUwpKSB7XG4gICAgICAgIGNvbnN0IGRlZmluaXRpb24gPSBpbnRlcm5hbHMubG9jYWxOYW1lVG9EZWZpbml0aW9uKGxvY2FsTmFtZSk7XG4gICAgICAgIGlmIChkZWZpbml0aW9uKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyAoZGVmaW5pdGlvbi5jb25zdHJ1Y3RvckZ1bmN0aW9uKSgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlc3VsdCA9IC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgIChOYXRpdmUuRG9jdW1lbnRfY3JlYXRlRWxlbWVudE5TLmNhbGwodGhpcywgbmFtZXNwYWNlLCBsb2NhbE5hbWUpKTtcbiAgICAgIGludGVybmFscy5wYXRjaEVsZW1lbnQocmVzdWx0KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgUGF0Y2hQYXJlbnROb2RlKGludGVybmFscywgRG9jdW1lbnQucHJvdG90eXBlLCB7XG4gICAgcHJlcGVuZDogTmF0aXZlLkRvY3VtZW50X3ByZXBlbmQsXG4gICAgYXBwZW5kOiBOYXRpdmUuRG9jdW1lbnRfYXBwZW5kLFxuICB9KTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICBQYXRjaFBhcmVudE5vZGUoaW50ZXJuYWxzLCBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZSwge1xuICAgIHByZXBlbmQ6IE5hdGl2ZS5Eb2N1bWVudEZyYWdtZW50X3ByZXBlbmQsXG4gICAgYXBwZW5kOiBOYXRpdmUuRG9jdW1lbnRGcmFnbWVudF9hcHBlbmQsXG4gIH0pO1xufTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAoYykgMjAxNiBUaGUgUG9seW1lciBQcm9qZWN0IEF1dGhvcnMuIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBUaGlzIGNvZGUgbWF5IG9ubHkgYmUgdXNlZCB1bmRlciB0aGUgQlNEIHN0eWxlIGxpY2Vuc2UgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0xJQ0VOU0UudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGF1dGhvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9BVVRIT1JTLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBjb250cmlidXRvcnMgbWF5IGJlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9DT05UUklCVVRPUlMudHh0XG4gKiBDb2RlIGRpc3RyaWJ1dGVkIGJ5IEdvb2dsZSBhcyBwYXJ0IG9mIHRoZSBwb2x5bWVyIHByb2plY3QgaXMgYWxzb1xuICogc3ViamVjdCB0byBhbiBhZGRpdGlvbmFsIElQIHJpZ2h0cyBncmFudCBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vUEFURU5UUy50eHRcbiAqL1xuXG5pbXBvcnQgTmF0aXZlIGZyb20gJy4vTmF0aXZlLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHBhcmFtIHshQ3VzdG9tRWxlbWVudEludGVybmFsc30gaW50ZXJuYWxzXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKGludGVybmFscykge1xuICAvLyBgTm9kZSNub2RlVmFsdWVgIGlzIGltcGxlbWVudGVkIG9uIGBBdHRyYC5cbiAgLy8gYE5vZGUjdGV4dENvbnRlbnRgIGlzIGltcGxlbWVudGVkIG9uIGBBdHRyYCwgYEVsZW1lbnRgLlxuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ2luc2VydEJlZm9yZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEBwYXJhbSB7P05vZGV9IHJlZk5vZGVcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihub2RlLCByZWZOb2RlKSB7XG4gICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgY29uc3QgaW5zZXJ0ZWROb2RlcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShub2RlLmNoaWxkTm9kZXMpO1xuICAgICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9pbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBub2RlLCByZWZOb2RlKTtcblxuICAgICAgICAvLyBEb2N1bWVudEZyYWdtZW50cyBjYW4ndCBiZSBjb25uZWN0ZWQsIHNvIGBkaXNjb25uZWN0VHJlZWAgd2lsbCBuZXZlclxuICAgICAgICAvLyBuZWVkIHRvIGJlIGNhbGxlZCBvbiBhIERvY3VtZW50RnJhZ21lbnQncyBjaGlsZHJlbiBhZnRlciBpbnNlcnRpbmcgaXQuXG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zZXJ0ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGluc2VydGVkTm9kZXNbaV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG5vZGVXYXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQobm9kZSk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9pbnNlcnRCZWZvcmUuY2FsbCh0aGlzLCBub2RlLCByZWZOb2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdhcHBlbmRDaGlsZCcsXG4gICAgLyoqXG4gICAgICogQHRoaXMge05vZGV9XG4gICAgICogQHBhcmFtIHshTm9kZX0gbm9kZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGUuY2hpbGROb2Rlcyk7XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgICAgLy8gRG9jdW1lbnRGcmFnbWVudHMgY2FuJ3QgYmUgY29ubmVjdGVkLCBzbyBgZGlzY29ubmVjdFRyZWVgIHdpbGwgbmV2ZXJcbiAgICAgICAgLy8gbmVlZCB0byBiZSBjYWxsZWQgb24gYSBEb2N1bWVudEZyYWdtZW50J3MgY2hpbGRyZW4gYWZ0ZXIgaW5zZXJ0aW5nIGl0LlxuXG4gICAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluc2VydGVkTm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShpbnNlcnRlZE5vZGVzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbmF0aXZlUmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBjb25zdCBub2RlV2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpO1xuICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbCh0aGlzLCBub2RlKTtcblxuICAgICAgaWYgKG5vZGVXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdjbG9uZU5vZGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbj19IGRlZXBcbiAgICAgKiBAcmV0dXJuIHshTm9kZX1cbiAgICAgKi9cbiAgICBmdW5jdGlvbihkZWVwKSB7XG4gICAgICBjb25zdCBjbG9uZSA9IE5hdGl2ZS5Ob2RlX2Nsb25lTm9kZS5jYWxsKHRoaXMsICEhZGVlcCk7XG4gICAgICAvLyBPbmx5IGNyZWF0ZSBjdXN0b20gZWxlbWVudHMgaWYgdGhpcyBlbGVtZW50J3Mgb3duZXIgZG9jdW1lbnQgaXNcbiAgICAgIC8vIGFzc29jaWF0ZWQgd2l0aCB0aGUgcmVnaXN0cnkuXG4gICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaFRyZWUoY2xvbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoQW5kVXBncmFkZVRyZWUoY2xvbmUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNsb25lO1xuICAgIH0pO1xuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChOb2RlLnByb3RvdHlwZSwgJ3JlbW92ZUNoaWxkJyxcbiAgICAvKipcbiAgICAgKiBAdGhpcyB7Tm9kZX1cbiAgICAgKiBAcGFyYW0geyFOb2RlfSBub2RlXG4gICAgICogQHJldHVybiB7IU5vZGV9XG4gICAgICovXG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgY29uc3Qgbm9kZVdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKTtcbiAgICAgIGNvbnN0IG5hdGl2ZVJlc3VsdCA9IE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgbm9kZSk7XG5cbiAgICAgIGlmIChub2RlV2FzQ29ubmVjdGVkKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShub2RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoTm9kZS5wcm90b3R5cGUsICdyZXBsYWNlQ2hpbGQnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtOb2RlfVxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb0luc2VydFxuICAgICAqIEBwYXJhbSB7IU5vZGV9IG5vZGVUb1JlbW92ZVxuICAgICAqIEByZXR1cm4geyFOb2RlfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uKG5vZGVUb0luc2VydCwgbm9kZVRvUmVtb3ZlKSB7XG4gICAgICBpZiAobm9kZVRvSW5zZXJ0IGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICBjb25zdCBpbnNlcnRlZE5vZGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KG5vZGVUb0luc2VydC5jaGlsZE5vZGVzKTtcbiAgICAgICAgY29uc3QgbmF0aXZlUmVzdWx0ID0gTmF0aXZlLk5vZGVfcmVwbGFjZUNoaWxkLmNhbGwodGhpcywgbm9kZVRvSW5zZXJ0LCBub2RlVG9SZW1vdmUpO1xuXG4gICAgICAgIC8vIERvY3VtZW50RnJhZ21lbnRzIGNhbid0IGJlIGNvbm5lY3RlZCwgc28gYGRpc2Nvbm5lY3RUcmVlYCB3aWxsIG5ldmVyXG4gICAgICAgIC8vIG5lZWQgdG8gYmUgY2FsbGVkIG9uIGEgRG9jdW1lbnRGcmFnbWVudCdzIGNoaWxkcmVuIGFmdGVyIGluc2VydGluZyBpdC5cblxuICAgICAgICBpZiAoVXRpbGl0aWVzLmlzQ29ubmVjdGVkKHRoaXMpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNlcnRlZE5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpbnRlcm5hbHMuY29ubmVjdFRyZWUoaW5zZXJ0ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hdGl2ZVJlc3VsdDtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgbm9kZVRvSW5zZXJ0V2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGVUb0luc2VydCk7XG4gICAgICBjb25zdCBuYXRpdmVSZXN1bHQgPSBOYXRpdmUuTm9kZV9yZXBsYWNlQ2hpbGQuY2FsbCh0aGlzLCBub2RlVG9JbnNlcnQsIG5vZGVUb1JlbW92ZSk7XG4gICAgICBjb25zdCB0aGlzSXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb1JlbW92ZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlVG9JbnNlcnRXYXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzSXNDb25uZWN0ZWQpIHtcbiAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKG5vZGVUb0luc2VydCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuYXRpdmVSZXN1bHQ7XG4gICAgfSk7XG5cblxuICBmdW5jdGlvbiBwYXRjaF90ZXh0Q29udGVudChkZXN0aW5hdGlvbiwgYmFzZURlc2NyaXB0b3IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVzdGluYXRpb24sICd0ZXh0Q29udGVudCcsIHtcbiAgICAgIGVudW1lcmFibGU6IGJhc2VEZXNjcmlwdG9yLmVudW1lcmFibGUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICBnZXQ6IGJhc2VEZXNjcmlwdG9yLmdldCxcbiAgICAgIHNldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSB0ZXh0IG5vZGUgdGhlbiB0aGVyZSBhcmUgbm8gbm9kZXMgdG8gZGlzY29ubmVjdC5cbiAgICAgICAgaWYgKHRoaXMubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgYXNzaWduZWRWYWx1ZSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IHJlbW92ZWROb2RlcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgLy8gQ2hlY2tpbmcgZm9yIGBmaXJzdENoaWxkYCBpcyBmYXN0ZXIgdGhhbiByZWFkaW5nIGBjaGlsZE5vZGVzLmxlbmd0aGBcbiAgICAgICAgLy8gdG8gY29tcGFyZSB3aXRoIDAuXG4gICAgICAgIGlmICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAvLyBVc2luZyBgY2hpbGROb2Rlc2AgaXMgZmFzdGVyIHRoYW4gYGNoaWxkcmVuYCwgZXZlbiB0aG91Z2ggd2Ugb25seVxuICAgICAgICAgIC8vIGNhcmUgYWJvdXQgZWxlbWVudHMuXG4gICAgICAgICAgY29uc3QgY2hpbGROb2RlcyA9IHRoaXMuY2hpbGROb2RlcztcbiAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzTGVuZ3RoID0gY2hpbGROb2Rlcy5sZW5ndGg7XG4gICAgICAgICAgaWYgKGNoaWxkTm9kZXNMZW5ndGggPiAwICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKSkge1xuICAgICAgICAgICAgLy8gQ29weWluZyBhbiBhcnJheSBieSBpdGVyYXRpbmcgaXMgZmFzdGVyIHRoYW4gdXNpbmcgc2xpY2UuXG4gICAgICAgICAgICByZW1vdmVkTm9kZXMgPSBuZXcgQXJyYXkoY2hpbGROb2Rlc0xlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkTm9kZXNMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICByZW1vdmVkTm9kZXNbaV0gPSBjaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJhc2VEZXNjcmlwdG9yLnNldC5jYWxsKHRoaXMsIGFzc2lnbmVkVmFsdWUpO1xuXG4gICAgICAgIGlmIChyZW1vdmVkTm9kZXMpIHtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbW92ZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKHJlbW92ZWROb2Rlc1tpXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50ICYmIE5hdGl2ZS5Ob2RlX3RleHRDb250ZW50LmdldCkge1xuICAgIHBhdGNoX3RleHRDb250ZW50KE5vZGUucHJvdG90eXBlLCBOYXRpdmUuTm9kZV90ZXh0Q29udGVudCk7XG4gIH0gZWxzZSB7XG4gICAgaW50ZXJuYWxzLmFkZE5vZGVQYXRjaChmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICBwYXRjaF90ZXh0Q29udGVudChlbGVtZW50LCB7XG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgLy8gTk9URTogVGhpcyBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgYHRleHRDb250ZW50YCBnZXR0ZXIgYXNzdW1lcyB0aGF0XG4gICAgICAgIC8vIHRleHQgbm9kZXMnIGB0ZXh0Q29udGVudGAgZ2V0dGVyIHdpbGwgbm90IGJlIHBhdGNoZWQuXG4gICAgICAgIGdldDogLyoqIEB0aGlzIHtOb2RlfSAqLyBmdW5jdGlvbigpIHtcbiAgICAgICAgICAvKiogQHR5cGUgeyFBcnJheTxzdHJpbmc+fSAqL1xuICAgICAgICAgIGNvbnN0IHBhcnRzID0gW107XG5cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2hpbGROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hpbGROb2RlID0gdGhpcy5jaGlsZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5DT01NRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKGNoaWxkTm9kZS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IC8qKiBAdGhpcyB7Tm9kZX0gKi8gZnVuY3Rpb24oYXNzaWduZWRWYWx1ZSkge1xuICAgICAgICAgIHdoaWxlICh0aGlzLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwodGhpcywgdGhpcy5maXJzdENoaWxkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gYHRleHRDb250ZW50ID0gbnVsbCB8IHVuZGVmaW5lZCB8ICcnYCBkb2VzIG5vdCByZXN1bHQgaW5cbiAgICAgICAgICAvLyBhIFRleHROb2RlIGNoaWxkTm9kZVxuICAgICAgICAgIGlmIChhc3NpZ25lZFZhbHVlICE9IG51bGwgJiYgYXNzaWduZWRWYWx1ZSAhPT0gJycpIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX2FwcGVuZENoaWxkLmNhbGwodGhpcywgZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYXNzaWduZWRWYWx1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCBDdXN0b21FbGVtZW50SW50ZXJuYWxzIGZyb20gJy4uLy4uL0N1c3RvbUVsZW1lbnRJbnRlcm5hbHMuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uLy4uL1V0aWxpdGllcy5qcyc7XG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgYmVmb3JlOiAhZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpLFxuICogICBhZnRlcjogIWZ1bmN0aW9uKC4uLighTm9kZXxzdHJpbmcpKSxcbiAqICAgcmVwbGFjZVdpdGg6ICFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSksXG4gKiAgIHJlbW92ZTogIWZ1bmN0aW9uKCksXG4gKiB9fVxuICovXG5sZXQgQ2hpbGROb2RlTmF0aXZlTWV0aG9kcztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqIEBwYXJhbSB7IU9iamVjdH0gZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7IUNoaWxkTm9kZU5hdGl2ZU1ldGhvZHN9IGJ1aWx0SW5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzLCBkZXN0aW5hdGlvbiwgYnVpbHRJbikge1xuICAvKipcbiAgICogQHBhcmFtIHshZnVuY3Rpb24oLi4uKCFOb2RlfHN0cmluZykpfSBidWlsdEluTWV0aG9kXG4gICAqIEByZXR1cm4geyFmdW5jdGlvbiguLi4oIU5vZGV8c3RyaW5nKSl9XG4gICAqL1xuICBmdW5jdGlvbiBiZWZvcmVBZnRlclBhdGNoKGJ1aWx0SW5NZXRob2QpIHtcbiAgICByZXR1cm4gLyoqIEB0aGlzIHshTm9kZX0gKi8gZnVuY3Rpb24oLi4ubm9kZXMpIHtcbiAgICAgIC8qKlxuICAgICAgICogQSBjb3B5IG9mIGBub2Rlc2AsIHdpdGggYW55IERvY3VtZW50RnJhZ21lbnQgcmVwbGFjZWQgYnkgaXRzIGNoaWxkcmVuLlxuICAgICAgICogQHR5cGUgeyFBcnJheTwhTm9kZT59XG4gICAgICAgKi9cbiAgICAgIGNvbnN0IGZsYXR0ZW5lZE5vZGVzID0gW107XG5cbiAgICAgIC8qKlxuICAgICAgICogRWxlbWVudHMgaW4gYG5vZGVzYCB0aGF0IHdlcmUgY29ubmVjdGVkIGJlZm9yZSB0aGlzIGNhbGwuXG4gICAgICAgKiBAdHlwZSB7IUFycmF5PCFOb2RlPn1cbiAgICAgICAqL1xuICAgICAgY29uc3QgY29ubmVjdGVkRWxlbWVudHMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ICYmIFV0aWxpdGllcy5pc0Nvbm5lY3RlZChub2RlKSkge1xuICAgICAgICAgIGNvbm5lY3RlZEVsZW1lbnRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIERvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICBmb3IgKGxldCBjaGlsZCA9IG5vZGUuZmlyc3RDaGlsZDsgY2hpbGQ7IGNoaWxkID0gY2hpbGQubmV4dFNpYmxpbmcpIHtcbiAgICAgICAgICAgIGZsYXR0ZW5lZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGF0dGVuZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ1aWx0SW5NZXRob2QuYXBwbHkodGhpcywgbm9kZXMpO1xuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludGVybmFscy5kaXNjb25uZWN0VHJlZShjb25uZWN0ZWRFbGVtZW50c1tpXSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcykpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGF0dGVuZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IG5vZGUgPSBmbGF0dGVuZWROb2Rlc1tpXTtcbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaWYgKGJ1aWx0SW4uYmVmb3JlICE9PSB1bmRlZmluZWQpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoZGVzdGluYXRpb24sICdiZWZvcmUnLCBiZWZvcmVBZnRlclBhdGNoKGJ1aWx0SW4uYmVmb3JlKSk7XG4gIH1cblxuICBpZiAoYnVpbHRJbi5iZWZvcmUgIT09IHVuZGVmaW5lZCkge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgJ2FmdGVyJywgYmVmb3JlQWZ0ZXJQYXRjaChidWlsdEluLmFmdGVyKSk7XG4gIH1cblxuICBpZiAoYnVpbHRJbi5yZXBsYWNlV2l0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKGRlc3RpbmF0aW9uLCAncmVwbGFjZVdpdGgnLFxuICAgICAgLyoqXG4gICAgICAgKiBAcGFyYW0gey4uLighTm9kZXxzdHJpbmcpfSBub2Rlc1xuICAgICAgICogQHRoaXMgeyFOb2RlfVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbiguLi5ub2Rlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBjb3B5IG9mIGBub2Rlc2AsIHdpdGggYW55IERvY3VtZW50RnJhZ21lbnQgcmVwbGFjZWQgYnkgaXRzIGNoaWxkcmVuLlxuICAgICAgICAgKiBAdHlwZSB7IUFycmF5PCFOb2RlfHN0cmluZz59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBmbGF0dGVuZWROb2RlcyA9IFtdO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFbGVtZW50cyBpbiBgbm9kZXNgIHRoYXQgd2VyZSBjb25uZWN0ZWQgYmVmb3JlIHRoaXMgY2FsbC5cbiAgICAgICAgICogQHR5cGUgeyFBcnJheTwhTm9kZT59XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBjb25uZWN0ZWRFbGVtZW50cyA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaV07XG5cbiAgICAgICAgICBpZiAobm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQgJiYgVXRpbGl0aWVzLmlzQ29ubmVjdGVkKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25uZWN0ZWRFbGVtZW50cy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgRG9jdW1lbnRGcmFnbWVudCkge1xuICAgICAgICAgICAgZm9yIChsZXQgY2hpbGQgPSBub2RlLmZpcnN0Q2hpbGQ7IGNoaWxkOyBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nKSB7XG4gICAgICAgICAgICAgIGZsYXR0ZW5lZE5vZGVzLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGF0dGVuZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgICAgICBidWlsdEluLnJlcGxhY2VXaXRoLmFwcGx5KHRoaXMsIG5vZGVzKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbm5lY3RlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGNvbm5lY3RlZEVsZW1lbnRzW2ldKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmbGF0dGVuZWROb2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGZsYXR0ZW5lZE5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICAgIGludGVybmFscy5jb25uZWN0VHJlZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICBpZiAoYnVpbHRJbi5yZW1vdmUgIT09IHVuZGVmaW5lZCkge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgJ3JlbW92ZScsXG4gICAgICAvKiogQHRoaXMgeyFOb2RlfSAqL1xuICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHdhc0Nvbm5lY3RlZCA9IFV0aWxpdGllcy5pc0Nvbm5lY3RlZCh0aGlzKTtcblxuICAgICAgICBidWlsdEluLnJlbW92ZS5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmICh3YXNDb25uZWN0ZWQpIHtcbiAgICAgICAgICBpbnRlcm5hbHMuZGlzY29ubmVjdFRyZWUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59O1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG5cbmltcG9ydCBOYXRpdmUgZnJvbSAnLi9OYXRpdmUuanMnO1xuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi4vQ3VzdG9tRWxlbWVudEludGVybmFscy5qcyc7XG5pbXBvcnQgQ0VTdGF0ZSBmcm9tICcuLi9DdXN0b21FbGVtZW50U3RhdGUuanMnO1xuaW1wb3J0ICogYXMgVXRpbGl0aWVzIGZyb20gJy4uL1V0aWxpdGllcy5qcyc7XG5cbmltcG9ydCBQYXRjaFBhcmVudE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvUGFyZW50Tm9kZS5qcyc7XG5pbXBvcnQgUGF0Y2hDaGlsZE5vZGUgZnJvbSAnLi9JbnRlcmZhY2UvQ2hpbGROb2RlLmpzJztcblxuLyoqXG4gKiBAcGFyYW0geyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSBpbnRlcm5hbHNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oaW50ZXJuYWxzKSB7XG4gIGlmIChOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cpIHtcbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdhdHRhY2hTaGFkb3cnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7IXttb2RlOiBzdHJpbmd9fSBpbml0XG4gICAgICAgKiBAcmV0dXJuIHtTaGFkb3dSb290fVxuICAgICAgICovXG4gICAgICBmdW5jdGlvbihpbml0KSB7XG4gICAgICAgIGNvbnN0IHNoYWRvd1Jvb3QgPSBOYXRpdmUuRWxlbWVudF9hdHRhY2hTaGFkb3cuY2FsbCh0aGlzLCBpbml0KTtcbiAgICAgICAgaW50ZXJuYWxzLnBhdGNoTm9kZShzaGFkb3dSb290KTtcbiAgICAgICAgdGhpcy5fX0NFX3NoYWRvd1Jvb3QgPSBzaGFkb3dSb290O1xuICAgICAgICByZXR1cm4gc2hhZG93Um9vdDtcbiAgICAgIH0pO1xuICB9XG5cblxuICBmdW5jdGlvbiBwYXRjaF9pbm5lckhUTUwoZGVzdGluYXRpb24sIGJhc2VEZXNjcmlwdG9yKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlc3RpbmF0aW9uLCAnaW5uZXJIVE1MJywge1xuICAgICAgZW51bWVyYWJsZTogYmFzZURlc2NyaXB0b3IuZW51bWVyYWJsZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIGdldDogYmFzZURlc2NyaXB0b3IuZ2V0LFxuICAgICAgc2V0OiAvKiogQHRoaXMge0VsZW1lbnR9ICovIGZ1bmN0aW9uKGh0bWxTdHJpbmcpIHtcbiAgICAgICAgY29uc3QgaXNDb25uZWN0ZWQgPSBVdGlsaXRpZXMuaXNDb25uZWN0ZWQodGhpcyk7XG5cbiAgICAgICAgLy8gTk9URTogSW4gSUUxMSwgd2hlbiB1c2luZyB0aGUgbmF0aXZlIGBpbm5lckhUTUxgIHNldHRlciwgYWxsIG5vZGVzXG4gICAgICAgIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlc2NlbmRhbnRzIG9mIHRoZSBjb250ZXh0IGVsZW1lbnQgaGF2ZSBhbGwgb2ZcbiAgICAgICAgLy8gdGhlaXIgY2hpbGRyZW4gcmVtb3ZlZCBhcyBwYXJ0IG9mIHRoZSBzZXQgLSB0aGUgZW50aXJlIHN1YnRyZWUgaXNcbiAgICAgICAgLy8gJ2Rpc2Fzc2VtYmxlZCcuIFRoaXMgd29yayBhcm91bmQgd2Fsa3MgdGhlIHN1YnRyZWUgKmJlZm9yZSogdXNpbmcgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBzZXR0ZXIuXG4gICAgICAgIC8qKiBAdHlwZSB7IUFycmF5PCFFbGVtZW50Pnx1bmRlZmluZWR9ICovXG4gICAgICAgIGxldCByZW1vdmVkRWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gICAgICAgIGlmIChpc0Nvbm5lY3RlZCkge1xuICAgICAgICAgIHJlbW92ZWRFbGVtZW50cyA9IFtdO1xuICAgICAgICAgIFV0aWxpdGllcy53YWxrRGVlcERlc2NlbmRhbnRFbGVtZW50cyh0aGlzLCBlbGVtZW50ID0+IHtcbiAgICAgICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzKSB7XG4gICAgICAgICAgICAgIHJlbW92ZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgYmFzZURlc2NyaXB0b3Iuc2V0LmNhbGwodGhpcywgaHRtbFN0cmluZyk7XG5cbiAgICAgICAgaWYgKHJlbW92ZWRFbGVtZW50cykge1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlZEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gcmVtb3ZlZEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnQuX19DRV9zdGF0ZSA9PT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RlZENhbGxiYWNrKGVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY3JlYXRlIGN1c3RvbSBlbGVtZW50cyBpZiB0aGlzIGVsZW1lbnQncyBvd25lciBkb2N1bWVudCBpc1xuICAgICAgICAvLyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICAgICAgICBpZiAoIXRoaXMub3duZXJEb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5KSB7XG4gICAgICAgICAgaW50ZXJuYWxzLnBhdGNoVHJlZSh0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbnRlcm5hbHMucGF0Y2hBbmRVcGdyYWRlVHJlZSh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaHRtbFN0cmluZztcbiAgICAgIH0sXG4gICAgfSk7XG4gIH1cblxuICBpZiAoTmF0aXZlLkVsZW1lbnRfaW5uZXJIVE1MICYmIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTC5nZXQpIHtcbiAgICBwYXRjaF9pbm5lckhUTUwoRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5FbGVtZW50X2lubmVySFRNTCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkhUTUxFbGVtZW50X2lubmVySFRNTCAmJiBOYXRpdmUuSFRNTEVsZW1lbnRfaW5uZXJIVE1MLmdldCkge1xuICAgIHBhdGNoX2lubmVySFRNTChIVE1MRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5IVE1MRWxlbWVudF9pbm5lckhUTUwpO1xuICB9IGVsc2Uge1xuICAgIGludGVybmFscy5hZGRFbGVtZW50UGF0Y2goZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgcGF0Y2hfaW5uZXJIVE1MKGVsZW1lbnQsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAvLyBJbXBsZW1lbnRzIGdldHRpbmcgYGlubmVySFRNTGAgYnkgcGVyZm9ybWluZyBhbiB1bnBhdGNoZWQgYGNsb25lTm9kZWBcbiAgICAgICAgLy8gb2YgdGhlIGVsZW1lbnQgYW5kIHJldHVybmluZyB0aGUgcmVzdWx0aW5nIGVsZW1lbnQncyBgaW5uZXJIVE1MYC5cbiAgICAgICAgLy8gVE9ETzogSXMgdGhpcyB0b28gZXhwZW5zaXZlP1xuICAgICAgICBnZXQ6IC8qKiBAdGhpcyB7RWxlbWVudH0gKi8gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovIChcbiAgICAgICAgICAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX2Nsb25lTm9kZS5jYWxsKHRoaXMsIHRydWUpKVxuICAgICAgICAgICAgICAuaW5uZXJIVE1MO1xuICAgICAgICB9LFxuICAgICAgICAvLyBJbXBsZW1lbnRzIHNldHRpbmcgYGlubmVySFRNTGAgYnkgY3JlYXRpbmcgYW4gdW5wYXRjaGVkIGVsZW1lbnQsXG4gICAgICAgIC8vIHNldHRpbmcgYGlubmVySFRNTGAgb2YgdGhhdCBlbGVtZW50IGFuZCByZXBsYWNpbmcgdGhlIHRhcmdldFxuICAgICAgICAvLyBlbGVtZW50J3MgY2hpbGRyZW4gd2l0aCB0aG9zZSBvZiB0aGUgdW5wYXRjaGVkIGVsZW1lbnQuXG4gICAgICAgIHNldDogLyoqIEB0aGlzIHtFbGVtZW50fSAqLyBmdW5jdGlvbihhc3NpZ25lZFZhbHVlKSB7XG4gICAgICAgICAgLy8gTk9URTogcmUtcm91dGUgdG8gYGNvbnRlbnRgIGZvciBgdGVtcGxhdGVgIGVsZW1lbnRzLlxuICAgICAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBiZWNhdXNlIGB0ZW1wbGF0ZS5hcHBlbmRDaGlsZGAgZG9lcyBub3RcbiAgICAgICAgICAvLyByb3V0ZSBpbnRvIGB0ZW1wbGF0ZS5jb250ZW50YC5cbiAgICAgICAgICBjb25zdCBpc1RlbXBsYXRlID0gKHRoaXMubG9jYWxOYW1lID09PSAndGVtcGxhdGUnKTtcbiAgICAgICAgICAvKiogQHR5cGUgeyFOb2RlfSAqL1xuICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBpc1RlbXBsYXRlID8gKC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovXG4gICAgICAgICAgICAodGhpcykpLmNvbnRlbnQgOiB0aGlzO1xuICAgICAgICAgIC8qKiBAdHlwZSB7IUVsZW1lbnR9ICovXG4gICAgICAgICAgY29uc3QgcmF3RWxlbWVudCA9IE5hdGl2ZS5Eb2N1bWVudF9jcmVhdGVFbGVtZW50TlMuY2FsbChkb2N1bWVudCxcbiAgICAgICAgICAgICAgdGhpcy5uYW1lc3BhY2VVUkksIHRoaXMubG9jYWxOYW1lKTtcbiAgICAgICAgICByYXdFbGVtZW50LmlubmVySFRNTCA9IGFzc2lnbmVkVmFsdWU7XG5cbiAgICAgICAgICB3aGlsZSAoY29udGVudC5jaGlsZE5vZGVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIE5hdGl2ZS5Ob2RlX3JlbW92ZUNoaWxkLmNhbGwoY29udGVudCwgY29udGVudC5jaGlsZE5vZGVzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgY29udGFpbmVyID0gaXNUZW1wbGF0ZSA/XG4gICAgICAgICAgICAgIC8qKiBAdHlwZSB7IUhUTUxUZW1wbGF0ZUVsZW1lbnR9ICovIChyYXdFbGVtZW50KS5jb250ZW50IDpcbiAgICAgICAgICAgICAgcmF3RWxlbWVudDtcbiAgICAgICAgICB3aGlsZSAoY29udGFpbmVyLmNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgTmF0aXZlLk5vZGVfYXBwZW5kQ2hpbGQuY2FsbChjb250ZW50LCBjb250YWluZXIuY2hpbGROb2Rlc1swXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuXG4gIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChFbGVtZW50LnByb3RvdHlwZSwgJ3NldEF0dHJpYnV0ZScsXG4gICAgLyoqXG4gICAgICogQHRoaXMge0VsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lLCBuZXdWYWx1ZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGUuY2FsbCh0aGlzLCBuYW1lKTtcbiAgICAgIE5hdGl2ZS5FbGVtZW50X3NldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbnVsbCk7XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAnc2V0QXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3VmFsdWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKSB7XG4gICAgICAvLyBGYXN0IHBhdGggZm9yIG5vbi1jdXN0b20gZWxlbWVudHMuXG4gICAgICBpZiAodGhpcy5fX0NFX3N0YXRlICE9PSBDRVN0YXRlLmN1c3RvbSkge1xuICAgICAgICByZXR1cm4gTmF0aXZlLkVsZW1lbnRfc2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUsIG5ld1ZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb2xkVmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBOYXRpdmUuRWxlbWVudF9zZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSwgbmV3VmFsdWUpO1xuICAgICAgbmV3VmFsdWUgPSBOYXRpdmUuRWxlbWVudF9nZXRBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICB9KTtcblxuICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoRWxlbWVudC5wcm90b3R5cGUsICdyZW1vdmVBdHRyaWJ1dGUnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgZnVuY3Rpb24obmFtZSkge1xuICAgICAgLy8gRmFzdCBwYXRoIGZvciBub24tY3VzdG9tIGVsZW1lbnRzLlxuICAgICAgaWYgKHRoaXMuX19DRV9zdGF0ZSAhPT0gQ0VTdGF0ZS5jdXN0b20pIHtcbiAgICAgICAgcmV0dXJuIE5hdGl2ZS5FbGVtZW50X3JlbW92ZUF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBvbGRWYWx1ZSA9IE5hdGl2ZS5FbGVtZW50X2dldEF0dHJpYnV0ZS5jYWxsKHRoaXMsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlLmNhbGwodGhpcywgbmFtZSk7XG4gICAgICBpZiAob2xkVmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgaW50ZXJuYWxzLmF0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayh0aGlzLCBuYW1lLCBvbGRWYWx1ZSwgbnVsbCwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgVXRpbGl0aWVzLnNldFByb3BlcnR5VW5jaGVja2VkKEVsZW1lbnQucHJvdG90eXBlLCAncmVtb3ZlQXR0cmlidXRlTlMnLFxuICAgIC8qKlxuICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAqIEBwYXJhbSB7P3N0cmluZ30gbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbihuYW1lc3BhY2UsIG5hbWUpIHtcbiAgICAgIC8vIEZhc3QgcGF0aCBmb3Igbm9uLWN1c3RvbSBlbGVtZW50cy5cbiAgICAgIGlmICh0aGlzLl9fQ0Vfc3RhdGUgIT09IENFU3RhdGUuY3VzdG9tKSB7XG4gICAgICAgIHJldHVybiBOYXRpdmUuRWxlbWVudF9yZW1vdmVBdHRyaWJ1dGVOUy5jYWxsKHRoaXMsIG5hbWVzcGFjZSwgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9sZFZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgTmF0aXZlLkVsZW1lbnRfcmVtb3ZlQXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgLy8gSW4gb2xkZXIgYnJvd3NlcnMsIGBFbGVtZW50I2dldEF0dHJpYnV0ZU5TYCBtYXkgcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmdcbiAgICAgIC8vIGluc3RlYWQgb2YgbnVsbCBpZiB0aGUgYXR0cmlidXRlIGRvZXMgbm90IGV4aXN0LiBGb3IgZGV0YWlscywgc2VlO1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0VsZW1lbnQvZ2V0QXR0cmlidXRlTlMjTm90ZXNcbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gTmF0aXZlLkVsZW1lbnRfZ2V0QXR0cmlidXRlTlMuY2FsbCh0aGlzLCBuYW1lc3BhY2UsIG5hbWUpO1xuICAgICAgaWYgKG9sZFZhbHVlICE9PSBuZXdWYWx1ZSkge1xuICAgICAgICBpbnRlcm5hbHMuYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKHRoaXMsIG5hbWUsIG9sZFZhbHVlLCBuZXdWYWx1ZSwgbmFtZXNwYWNlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuXG4gIGZ1bmN0aW9uIHBhdGNoX2luc2VydEFkamFjZW50RWxlbWVudChkZXN0aW5hdGlvbiwgYmFzZU1ldGhvZCkge1xuICAgIFV0aWxpdGllcy5zZXRQcm9wZXJ0eVVuY2hlY2tlZChkZXN0aW5hdGlvbiwgJ2luc2VydEFkamFjZW50RWxlbWVudCcsXG4gICAgICAvKipcbiAgICAgICAqIEB0aGlzIHtFbGVtZW50fVxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBvc2l0aW9uXG4gICAgICAgKiBAcGFyYW0geyFFbGVtZW50fSBlbGVtZW50XG4gICAgICAgKiBAcmV0dXJuIHs/RWxlbWVudH1cbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24ocG9zaXRpb24sIGVsZW1lbnQpIHtcbiAgICAgICAgY29uc3Qgd2FzQ29ubmVjdGVkID0gVXRpbGl0aWVzLmlzQ29ubmVjdGVkKGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpbnNlcnRlZEVsZW1lbnQgPSAvKiogQHR5cGUgeyFFbGVtZW50fSAqL1xuICAgICAgICAgIChiYXNlTWV0aG9kLmNhbGwodGhpcywgcG9zaXRpb24sIGVsZW1lbnQpKTtcblxuICAgICAgICBpZiAod2FzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmRpc2Nvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFV0aWxpdGllcy5pc0Nvbm5lY3RlZChpbnNlcnRlZEVsZW1lbnQpKSB7XG4gICAgICAgICAgaW50ZXJuYWxzLmNvbm5lY3RUcmVlKGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpbnNlcnRlZEVsZW1lbnQ7XG4gICAgICB9KTtcbiAgfVxuXG4gIGlmIChOYXRpdmUuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEhUTUxFbGVtZW50LnByb3RvdHlwZSwgTmF0aXZlLkhUTUxFbGVtZW50X2luc2VydEFkamFjZW50RWxlbWVudCk7XG4gIH0gZWxzZSBpZiAoTmF0aXZlLkVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KSB7XG4gICAgcGF0Y2hfaW5zZXJ0QWRqYWNlbnRFbGVtZW50KEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuRWxlbWVudF9pbnNlcnRBZGphY2VudEVsZW1lbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnNvbGUud2FybignQ3VzdG9tIEVsZW1lbnRzOiBgRWxlbWVudCNpbnNlcnRBZGphY2VudEVsZW1lbnRgIHdhcyBub3QgcGF0Y2hlZC4nKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gcGF0Y2hfaW5zZXJ0QWRqYWNlbnRIVE1MKGRlc3RpbmF0aW9uLCBiYXNlTWV0aG9kKSB7XG4gICAgLyoqXG4gICAgICogUGF0Y2hlcyBhbmQgdXBncmFkZXMgYWxsIG5vZGVzIHdoaWNoIGFyZSBzaWJsaW5ncyBiZXR3ZWVuIGBzdGFydGBcbiAgICAgKiAoaW5jbHVzaXZlKSBhbmQgYGVuZGAgKGV4Y2x1c2l2ZSkuIElmIGBlbmRgIGlzIGBudWxsYCwgdGhlbiBhbGwgc2libGluZ3NcbiAgICAgKiBmb2xsb3dpbmcgYHN0YXJ0YCB3aWxsIGJlIHBhdGNoZWQgYW5kIHVwZ3JhZGVkLlxuICAgICAqIEBwYXJhbSB7IU5vZGV9IHN0YXJ0XG4gICAgICogQHBhcmFtIHs/Tm9kZX0gZW5kXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBncmFkZU5vZGVzSW5SYW5nZShzdGFydCwgZW5kKSB7XG4gICAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgbm9kZSA9IHN0YXJ0OyBub2RlICE9PSBlbmQ7IG5vZGUgPSBub2RlLm5leHRTaWJsaW5nKSB7XG4gICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGludGVybmFscy5wYXRjaEFuZFVwZ3JhZGVUcmVlKG5vZGVzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBVdGlsaXRpZXMuc2V0UHJvcGVydHlVbmNoZWNrZWQoZGVzdGluYXRpb24sICdpbnNlcnRBZGphY2VudEhUTUwnLFxuICAgICAgLyoqXG4gICAgICAgKiBAdGhpcyB7RWxlbWVudH1cbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwb3NpdGlvblxuICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHRleHRcbiAgICAgICAqL1xuICAgICAgZnVuY3Rpb24ocG9zaXRpb24sIHRleHQpIHtcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbi50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gXCJiZWZvcmViZWdpblwiKSB7XG4gICAgICAgICAgY29uc3QgbWFya2VyID0gdGhpcy5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHBvc2l0aW9uLCB0ZXh0KTtcbiAgICAgICAgICB1cGdyYWRlTm9kZXNJblJhbmdlKG1hcmtlciB8fCAvKiogQHR5cGUgeyFOb2RlfSAqLyAodGhpcy5wYXJlbnROb2RlLmZpcnN0Q2hpbGQpLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gXCJhZnRlcmJlZ2luXCIpIHtcbiAgICAgICAgICBjb25zdCBtYXJrZXIgPSB0aGlzLmZpcnN0Q2hpbGQ7XG4gICAgICAgICAgYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHBvc2l0aW9uLCB0ZXh0KTtcbiAgICAgICAgICB1cGdyYWRlTm9kZXNJblJhbmdlKC8qKiBAdHlwZSB7IU5vZGV9ICovICh0aGlzLmZpcnN0Q2hpbGQpLCBtYXJrZXIpO1xuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSBcImJlZm9yZWVuZFwiKSB7XG4gICAgICAgICAgY29uc3QgbWFya2VyID0gdGhpcy5sYXN0Q2hpbGQ7XG4gICAgICAgICAgYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHBvc2l0aW9uLCB0ZXh0KTtcbiAgICAgICAgICB1cGdyYWRlTm9kZXNJblJhbmdlKG1hcmtlciB8fCAvKiogQHR5cGUgeyFOb2RlfSAqLyAodGhpcy5maXJzdENoaWxkKSwgbnVsbCk7XG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09IFwiYWZ0ZXJlbmRcIikge1xuICAgICAgICAgIGNvbnN0IG1hcmtlciA9IHRoaXMubmV4dFNpYmxpbmc7XG4gICAgICAgICAgYmFzZU1ldGhvZC5jYWxsKHRoaXMsIHBvc2l0aW9uLCB0ZXh0KTtcbiAgICAgICAgICB1cGdyYWRlTm9kZXNJblJhbmdlKC8qKiBAdHlwZSB7IU5vZGV9ICovICh0aGlzLm5leHRTaWJsaW5nKSwgbWFya2VyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSB2YWx1ZSBwcm92aWRlZCAoJHtTdHJpbmcocG9zaXRpb24pfSkgaXMgYCArXG4gICAgICAgICAgICBcIm5vdCBvbmUgb2YgJ2JlZm9yZWJlZ2luJywgJ2FmdGVyYmVnaW4nLCAnYmVmb3JlZW5kJywgb3IgJ2FmdGVyZW5kJy5cIik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgaWYgKE5hdGl2ZS5IVE1MRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUwpIHtcbiAgICBwYXRjaF9pbnNlcnRBZGphY2VudEhUTUwoSFRNTEVsZW1lbnQucHJvdG90eXBlLCBOYXRpdmUuSFRNTEVsZW1lbnRfaW5zZXJ0QWRqYWNlbnRIVE1MKTtcbiAgfSBlbHNlIGlmIChOYXRpdmUuRWxlbWVudF9pbnNlcnRBZGphY2VudEhUTUwpIHtcbiAgICBwYXRjaF9pbnNlcnRBZGphY2VudEhUTUwoRWxlbWVudC5wcm90b3R5cGUsIE5hdGl2ZS5FbGVtZW50X2luc2VydEFkamFjZW50SFRNTCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc29sZS53YXJuKCdDdXN0b20gRWxlbWVudHM6IGBFbGVtZW50I2luc2VydEFkamFjZW50SFRNTGAgd2FzIG5vdCBwYXRjaGVkLicpO1xuICB9XG5cblxuICBQYXRjaFBhcmVudE5vZGUoaW50ZXJuYWxzLCBFbGVtZW50LnByb3RvdHlwZSwge1xuICAgIHByZXBlbmQ6IE5hdGl2ZS5FbGVtZW50X3ByZXBlbmQsXG4gICAgYXBwZW5kOiBOYXRpdmUuRWxlbWVudF9hcHBlbmQsXG4gIH0pO1xuXG4gIFBhdGNoQ2hpbGROb2RlKGludGVybmFscywgRWxlbWVudC5wcm90b3R5cGUsIHtcbiAgICBiZWZvcmU6IE5hdGl2ZS5FbGVtZW50X2JlZm9yZSxcbiAgICBhZnRlcjogTmF0aXZlLkVsZW1lbnRfYWZ0ZXIsXG4gICAgcmVwbGFjZVdpdGg6IE5hdGl2ZS5FbGVtZW50X3JlcGxhY2VXaXRoLFxuICAgIHJlbW92ZTogTmF0aXZlLkVsZW1lbnRfcmVtb3ZlLFxuICB9KTtcbn07XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFBvbHltZXIgUHJvamVjdCBBdXRob3JzLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogVGhpcyBjb2RlIG1heSBvbmx5IGJlIHVzZWQgdW5kZXIgdGhlIEJTRCBzdHlsZSBsaWNlbnNlIGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9MSUNFTlNFLnR4dFxuICogVGhlIGNvbXBsZXRlIHNldCBvZiBhdXRob3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQVVUSE9SUy50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgY29udHJpYnV0b3JzIG1heSBiZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vQ09OVFJJQlVUT1JTLnR4dFxuICogQ29kZSBkaXN0cmlidXRlZCBieSBHb29nbGUgYXMgcGFydCBvZiB0aGUgcG9seW1lciBwcm9qZWN0IGlzIGFsc29cbiAqIHN1YmplY3QgdG8gYW4gYWRkaXRpb25hbCBJUCByaWdodHMgZ3JhbnQgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL1BBVEVOVFMudHh0XG4gKi9cblxuaW1wb3J0IEN1c3RvbUVsZW1lbnRJbnRlcm5hbHMgZnJvbSAnLi9DdXN0b21FbGVtZW50SW50ZXJuYWxzLmpzJztcbmltcG9ydCBDdXN0b21FbGVtZW50UmVnaXN0cnkgZnJvbSAnLi9DdXN0b21FbGVtZW50UmVnaXN0cnkuanMnO1xuXG5pbXBvcnQgUGF0Y2hIVE1MRWxlbWVudCBmcm9tICcuL1BhdGNoL0hUTUxFbGVtZW50LmpzJztcbmltcG9ydCBQYXRjaERvY3VtZW50IGZyb20gJy4vUGF0Y2gvRG9jdW1lbnQuanMnO1xuaW1wb3J0IFBhdGNoRG9jdW1lbnRGcmFnbWVudCBmcm9tICcuL1BhdGNoL0RvY3VtZW50RnJhZ21lbnQuanMnO1xuaW1wb3J0IFBhdGNoTm9kZSBmcm9tICcuL1BhdGNoL05vZGUuanMnO1xuaW1wb3J0IFBhdGNoRWxlbWVudCBmcm9tICcuL1BhdGNoL0VsZW1lbnQuanMnO1xuXG5jb25zdCBwcmlvckN1c3RvbUVsZW1lbnRzID0gd2luZG93WydjdXN0b21FbGVtZW50cyddO1xuXG5pZiAoIXByaW9yQ3VzdG9tRWxlbWVudHMgfHxcbiAgICAgcHJpb3JDdXN0b21FbGVtZW50c1snZm9yY2VQb2x5ZmlsbCddIHx8XG4gICAgICh0eXBlb2YgcHJpb3JDdXN0b21FbGVtZW50c1snZGVmaW5lJ10gIT0gJ2Z1bmN0aW9uJykgfHxcbiAgICAgKHR5cGVvZiBwcmlvckN1c3RvbUVsZW1lbnRzWydnZXQnXSAhPSAnZnVuY3Rpb24nKSkge1xuICAvKiogQHR5cGUgeyFDdXN0b21FbGVtZW50SW50ZXJuYWxzfSAqL1xuICBjb25zdCBpbnRlcm5hbHMgPSBuZXcgQ3VzdG9tRWxlbWVudEludGVybmFscygpO1xuXG4gIFBhdGNoSFRNTEVsZW1lbnQoaW50ZXJuYWxzKTtcbiAgUGF0Y2hEb2N1bWVudChpbnRlcm5hbHMpO1xuICBQYXRjaERvY3VtZW50RnJhZ21lbnQoaW50ZXJuYWxzKTtcbiAgUGF0Y2hOb2RlKGludGVybmFscyk7XG4gIFBhdGNoRWxlbWVudChpbnRlcm5hbHMpO1xuXG4gIC8vIFRoZSBtYWluIGRvY3VtZW50IGlzIGFsd2F5cyBhc3NvY2lhdGVkIHdpdGggdGhlIHJlZ2lzdHJ5LlxuICBkb2N1bWVudC5fX0NFX2hhc1JlZ2lzdHJ5ID0gdHJ1ZTtcblxuICAvKiogQHR5cGUgeyFDdXN0b21FbGVtZW50UmVnaXN0cnl9ICovXG4gIGNvbnN0IGN1c3RvbUVsZW1lbnRzID0gbmV3IEN1c3RvbUVsZW1lbnRSZWdpc3RyeShpbnRlcm5hbHMpO1xuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csICdjdXN0b21FbGVtZW50cycsIHtcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICB2YWx1ZTogY3VzdG9tRWxlbWVudHMsXG4gIH0pO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==